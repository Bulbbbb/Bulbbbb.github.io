---
aliases: 
tags: 
---

|              | 外部类/接口 | 成员属性 | 方法 | 构造器 | 初始化块 | 成员内部类 | 局部成员 |
|:------------:|:-----------:|:--------:|:----:|:------:|:--------:|:----------:|:--------:|
| 包访问控制符 |      ✔      |    ✔     |  ✔   |   ✔    |    ⭕    |     ✔      |    ⭕    |
|    public    |      ✔      |    ✔     |  ✔   |   ✔    |          |     ✔      |          |
|  protected   |             |    ✔     |  ✔   |   ✔    |          |     ✔      |          |
|   private    |             |    ✔     |  ✔   |   ✔    |          |     ✔      |          |
|   abstract   |      ✔      |          |  ✔   |        |          |     ✔      |          |
|    final     |      ✔      |    ✔     |  ✔   |        |          |     ✔      |    ✔     |
|    static    |             |    ✔     |  ✔   |        |    ✔     |     ✔      |          |
|   strictfp   |      ✔      |          |  ✔   |        |          |     ✔      |          |
| synchronized |             |          |  ✔   |        |          |            |          |
|    native    |             |          |  ✔   |        |          |            |          |
|  transient   |             |    ✔     |      |        |          |            |          |
|   volatile   |             |    ✔     |      |        |          |            |          |
|   default    |             |          |  ✔   |        |          |            |          |

+ _包访问控制符：不适用任何访问控制符就是包访问控制符，对于初始化块和局部成员而言，它们不能使用任何访问控制符，所以看起来像使用了包访问控制符。_
+ _包访问控制符、public、protected、private 只能同时出现一个。_
+ _abstract 和 final 不能同时出现_
+ _abstract 和 static 不能同时修饰方法，可以同时修饰内部类，子类无法继承static方法，也就不能重写，如果定义 static abstract 方法 ，那这个方法就永远是抽象的，static方法可以不实例化掉用，掉用一个没有方法体的方法有什么意义呢_ 
+ _abstract 和 private 不能同时修饰方法，可以同时修饰内部类_
+ _private 和 final 同时修饰方法时语法是合法的，但是没有任何意义，因为 private 修饰的方法不可能被子类重写_

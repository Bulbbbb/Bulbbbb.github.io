---
aliases: 
tags: 
---

## 声明成员内部类

```java
class Outer{
	[修饰符] class Inner{
		。。。
	}
}
```

+ _修饰符可以为 private、protect、public、abstract、final 和 static，当修饰为 static 时为静态内部类。_
	*使用 abstract 和 final 修饰时就和外部类的意义相同，使用 abstract 修饰时为抽象类不能实例化，使用 final 修饰时不能被继承*

## 成员内部类的构成

+ _成员内部类和普通内部类的构成一样，可以有构造器、成员变量、方法、初始化块、内部类。_
+ _成员内部类内的成员不能单独使用 static 进行修饰，必须使用 static final_

*成员内部类必须依赖于外部类实例，有一个外部类实例时才能实例化内部类。*

*首先，成员内部类是外部类的一个成员，并且是属于外部类实例的，先有外部类实例再有内部类实例*
*其次内部类使用懒加载机制，使用的时候才加载，主动使用包括 new(实例化)、getstatic(读取静态属性)、putstatic(设置静态属性)、invokestatic(调用静态方法)，以及 Class.forName() 作为一种特例。*

*如果内部类出现 static 变量，此 static 变量应该是不依赖内部类对象的，不需要通过外部类对象就能访问，此时内部类还没有加载。*

*大多数博客从这方面考虑，但是，访问 static 成员的时候，会引起类的加载，而类的加载不需要依赖外部类实例，所以这是解释不通的。*

*因为成员内部类不能有 static 方法，所以 static final 成员必须使用字面量初始化，访问 static final 成员不会引起加载。*

> [!note] *最新的 jdk1.7 中，成员内部类是支持静态成员和静态方法的。*

## 实例化成员内部类

_实例化成员内部类的对象按照不同的情况有几种方法：_

```java
// 情况一 在外部类中进行实例化
Inner inner = new Inner();
// 情况二 在外部类之外进行实例化 
Inner inner = Outer_instance.new Inner();
// 情况三 在静态成员成员中进行实例化
Inner inner = Outer_instance.new Inner();
```

*内部类中持有外部类实例的引用，所以创建内部类实例的时候，需要使用外部类对象初始化这个引用，所以要先有外部类实例再有内部类实例。*

> [!summary]+ _对上面几种实例化方法解释一下:_
> _内部类一个非常重要的特性就是可以访问外部类的成员，不管是不是 private。_
> _在 Java 中实现这种特性的方法是，内部类对象中持有一个外部类对象的引用。_
> _在实例化内部类对象的过程中，需要传递给内部类对象一个外部类对象的引用。因此，虚拟机需要知道该内部类的外部类是哪一个。_
> _在方法 1 中，因为是在外部类内部，所以不需要显式告诉虚拟机。在方法 2 中，则需要显式告诉虚拟机。方法 3 是因为静态成员不能访问非静态成员，要想访问只能通过对象进行方法。_

*静态成员和非静态成员的生命周期不同，静态成员初始化的时候，非静态成员还没有初始化，所以必须通过对象进行访问，确保非静态成员已经被初始化。*

## 成员内部类与外部类的相互访问

+ *成员内部类可以访问外部类所有属性和方法，即使是 private。*
+ _当成员内部类和外部类中有相同的方法和变量时，遵循“就近原则”访问。如何要使用外部类中的方法和变量可以使用 `外部类名.this` 拿到外部类的引用。_

---
aliases: 
tags: 
---

## 多线程带来的问题

_由于线程调度的不确定性，两个线程在操作同一个对象是可能造成异常，常见的异常有下面两个:_
+ *产生竟态条件*
+ *内存可见性问题*

### 竟态条件

_当两个或者多个进程或线程并发执行时，在同一个条件下，其最终结果依赖于进程或者线程的执行顺序。此条件为==竟态条件==。_

_发生竟态条件的代码称为==临界区==。_

_最常见的错误莫过于 count++，因为 count++ 并不是一个原子操作，它分为三个步骤：_
1. _取 count 的当前值_
2. _在当前值的基础上 +1_
3. _将新值重新赋给 count_
_两个线程可能同时执行第一步，取到了相同的 count 值，如 100，第一个线程执行之后 count=101，第二个线程执行之后 count 还是 101，我们期待的结果应该为 102。_

_在 Java 中有 3 中方法来解决：_
+ _使用 synchronized 关键字 (同步监视器)_
+ _使用显示锁_
+ _使用原子变量_

### 内存可见性问题

_在计算机系统中，除了内存，数据还会被缓存在 CPU 的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或 CPU 缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中。这就是==内存可见性==。_

_简单来说，就是一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。_

_解决内存可见性的方法有下面几个：_
1. _使用 volatile 关键字_
2. _使用 synchronized 关键字或显示锁同步。_

## 多线程的优点

1. _充分利用多 CPU 的优势_
2. _防止单线程阻塞时，程序无法响应_

## 同步代码块

```java
synchronized(obj)
{
	....
}
```

_上面代码中的 obj 为同步监视器，线程开始执行下面代码之前必须获得对同步监视器的锁定。_

## 同步方法

_使用 synchronized 关键字修饰的方法叫做同步方法。_
_对于同步方法无需显示指定同步监视器，其同步监视器为 this，也就是调用该方法的对象。_

## 释放同步监视器

_同步监视器会在下面情况释放：_
+ _当前线程的同步方法、同步代码块执行结束，当前线程即释放同步监视器。_
+ _当前线程在同步代码块、同步方法中遇到 break、return 终止了该代码块、该方法的继续执行，当前线程将会释放同步监视器。_
+ _当前线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception，导致了该代码块、该方法异常结束时，当前线程将会释放同步监视器。_
+ _当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的 wait() 方法，则当前线程暂停，并释放同步监视器。_

_在下面情况下，同步监视器并不会释放：_
+ _线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield() 方法来暂停当前线程的执行，当前线程不会释放同步监视器。_
+ _线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放同步监视器。当然，程序应该尽量避免使用 suspend() 和 resume() 方法来控制线程。_

> [!note] *wait 会释放锁，sleep、yield、suspend 不会释放锁。*

## 锁

_可以看一下这篇文章 -->[java 锁的本质](https://blog.csdn.net/sinat_14913533/article/details/129156560)。_

_对于锁，需要考虑两个问题：_
1. _锁标志存放到哪里_
2. _遇到锁冲突怎么办_

_对于 Java 来说，都是对对象进行加锁，锁标志存放到对象头中，使用 synchronized 修饰非静态方法，锁的是调用该方法的对象，修饰静态方法和类，锁的是所有对象。_

_Java 的对象头由三部分组成：_
+ _类型指针，指向当前对象所属类的元数据_
+ _mark world，32bit/64bit_
+ _数组长度_

_当 mark world 低 2 位为 00、01、10 时，高 30 位存储锁标志相关信息。_
![[Pasted image 20230427214155.png|400]]
_对于上面不同的锁就在于，遇到锁冲突时的解决措施：_

---
aliases: 
tags: 
---

> [!note] *volatile 作用有两个：*
> + *保证内存可见性*
> + *禁止指令重排*

*按照 happens-before 原则， volatile 域的写操作 happens-before 读操作，也就是 volatile 域的写操作在逻辑层面上先于 volatile 域的读操作，并且对后续所有读操作可见。*

*所以 volatile 可以保证可见性和有序性。*

> [!note] *出现内存可见性的原因：*
> + *变量 1 修改后，不会立即将修改后的值刷新到内存中*
> + *变量 2 读取变量后，会从主存中读取*

*缓存一致性协议：*
***MESI 协议：***
+ *M：Modify：当缓存行中的数据被修改后，该缓存行状态置为 M*
+ *E：Exclusive，当只有一个缓存行中有某个数据时，置为 E*
+ *S：Shared：当缓存行中的数据存在多个缓存行中，置为 S*
+ *I：Invalida：当某个缓存行数据被修改后，其他缓存行的状态置为 I*

> [!note] *总结一下就是，当缓存行中的数据被修改时，如果该缓存行状态为 S，则将该缓存行状态置为 M，其他缓存行的状态置为 I，并将数据刷新到主存中，这里的缓存行指的是不同 CPU，因为同一个 CPU 不会命中的状态下再将数据读到缓存中*
> *当 cpu 检测到缓存中状态为 I，就会到内存中读取*

*MESI 需要配合总线嗅探机制使用，变量的状态的修改时使用类似消息发送与接受的方式修改的，嗅探就是不断修改嗅探总线上的消息。*

### 指令重排

[Java并发：volatile内存可见性和指令重排 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/151443733)
*JVM 为了提高性能会进行指令重排*
*指令重排可能导致出现结果不正确*
*volatile 可以禁止指令重排*
![[Pasted image 20230823105033.png]]
*volatile 通过内存屏障来禁止指令重排：*
[指令重排序、内存屏障很难？看完这篇你就懂了！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/326260623)
*如果两条指令之间可能进行排序，那就再两条指令之间插入一条指令重排指令*


---
aliases: 
tags: 
---
*线程池指的是 ThreadPoolExecutor，JUC 中借助 Executor 实现了线程池，ThreadPoolExecutor 是 Executor 接口的实现类。*

*在 Executor 中，我们说过，当 submit 一个任务后，Executor 会执行该任务，但是 Executor 如果执行该任务就需要通过具体的子类来实现，比如是创建一个线程来执行还是等待上一个线程执行完后使用上一个线程。*

*所以 ThreadPoolExecutor 就是对 Executor 中具体逻辑的实现。*
*下面来看 ThreadPoolExecutor 的具体思想。*

## AbstractExecutorService

*ThreadPoolExecutor 继承了 AbstractExecutorService，AbstractExecutorService 是对 ExecutorService 的抽象类，在 AbstractExecutorService 已经将大部分代码给我们写好了，要实现一个 Executor 只需要继承 AbstractExecutorService，重写小部分函数就行了*

*在 AbstractExecutorService 的实现类中 submit 方法会调用 execute()，我们只需要实现 execute() 方法就行。*

```java
public abstract class AbstractExecutorService implements ExecutorService {
	public Future<?> submit(Runnable task) {  
		if (task == null) throw new NullPointerException();  
		RunnableFuture<Void> ftask = newTaskFor(task, null);  
		execute(ftask);  
		return ftask;  
	}
}
```

## ThreadPoolExecutor

*线程池是一种池化思想的实现，线程池中会先启动若干数量的线程，这些线程都处于睡眠状态。当客户端有一个新的请求时，就会唤醒线程池中的某一个睡眠的线程，让它来处理客户端的这个请求，当处理完这个请求之后，线程又处于睡眠的状态。*

*线程池有许多优点，在没有线程池的情况下，这样实现起来非常简便，但是就会有一个问题: 如果并发的线程数星很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。*

> [!note] *线程池：*
> 1. *防止创建大量线程*
> 2. *防止线程频繁创建和销毁*

+ *降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。*
+ *提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。*
+ *提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。*

*首先看一下线程池的构造方法：*

```java
public ThreadPoolExecutor(int corePoolSize,  // 核心线程数
						  int maximumPoolSize,  // 最大线程数
						  long keepAliveTime,  // 存活时间
						  TimeUnit unit,   
						  BlockingQueue<Runnable> workQueue,  // 任务等待队列
						  ThreadFactory threadFactory,  // 线程工厂
						  RejectedExecutionHandler handler) // 拒绝策略
```

*下面是线程池的 execute() 方法：*

```java
public void execute(Runnable command) {  
	if (command == null)  // 任务不能为空
		throw new NullPointerException();  
	int c = ctl.get();  // 获取线程池工作状态和当前工作的线程数
	if (workerCountOf(c) < corePoolSize) {  // 如果当前工作的线程数 < corePoolSize
		if (addWorker(command, true))  // 新建线程运行任务
			return;  
		// 新建线程失败后，重新获取此时的线程池工作状态和工作线程数
		// 失败的原因可能为此时工作线程数超过 corePoolSize
		c = ctl.get();  
	}  
	// 如果当前线程池是运行状态 并且可以将 任务添加到工作阻塞队列中（工作队列未满）
	if (isRunning(c) && workQueue.offer(command)) {  
		int recheck = ctl.get();  // 添加到队列成功，获取状态
		// 双重验证，防止判断状态后，加入队列前，线程池状态发生改变
		if (! isRunning(recheck) && remove(command))  // 如果不是运行状态，移除任务
			reject(command);  // 通过handler拒绝任务
		// 移除任务失败，如果当前工作线程数为0，创建一个新线程，但是不指定任务
		else if (workerCountOf(recheck) == 0)  // 当前工作的线程数为0
			addWorker(null, false);  
	}  
	// 如果工作队列已满，创建非核心线程，失败后拒绝任务,失败代表线程数达到maximumPoolSize
	else if (!addWorker(command, false))  
		reject(command);  
}
```

*通过上面代码可以总结出，线程池的工作流程：*
1. *工作线程数小于核心线程数，则直接调用 addWorker() 方法创建核心线程来执行任务。*
2. *如果工作线程数大于核心线程数，如果工作队列未满，加入工作队列*
3. *如果工作队列已满，如果工作线程数小于 maximumPoolSize，调用 addWorker() 创建非核心线程执行任务。*
4. *如果工作线程数达到 maximumPoolSize，执行拒绝策略。*

> [!note] *核心线程创建后会一直存在，非核心线程如果空闲时间超过 keepAliveTime 会被终止。*

*获取线程池状态和当前工作线程的方法可以看一下这里 -->[详解Java线程池的ctl(线程池控制状态)【源码分析】](https://www.cnblogs.com/moonfair/p/13477974.html)*

### workQueue

*workQueue 是线程池中的工作队列，工作队列应该是一个阻塞队列，BlockingQueue 类型的。*
*比较简单的有：ArrayBlockingQueue、LinkedBlockingQueue。*

### 线程工厂 threadFactory

*线程工厂用于创建线程。`ThreadFactory` 是一个接口，只有一个方法。*

```java
public interface ThreadFactory {  
	Thread newThread(Runnable r);  
}
```

*默认的线程工厂为：DefaultThreadFactory。*

### 拒绝策略 handler

| 策略名              | 描述                                                                                                                                                       |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| AbortPolicy         | 默认的拒绝策略。丢弃任务并抛出异常。与第二个相比抛出异常可以试试发现异常状态。                                                                             |
| DIscardPolicy       | 丢弃任务但是不抛出异常。使用次策略无法发现系统的异常状态。                                                                                                 |
| DiscardOldestPolicy | 丢弃队列最前面的任务，然后重新提交被拒绝的任务。具体是否使用，需要看具体的业务衡量。                                                                       |
| CallerRunsPolicy    | 由提交任务的线程处理该任务。这种情况时需要让所有的任务都处理完毕，那么就适大量的计算任务类型去执行，多线程仅仅是增大吞吐量的手段，最终必须要全部执行完毕。 | 

### 提交任务的几种方式

1. *execute()*
2. *submit()*

*前面我们说过在 AbstractExecutorService 的实现类中 submit 方法会调用 execute()*

```java
public abstract class AbstractExecutorService implements ExecutorService {
	public Future<?> submit(Runnable task) {  
		if (task == null) throw new NullPointerException();  
		RunnableFuture<Void> ftask = newTaskFor(task, null);  
		execute(ftask);  
		return ftask;  
	}
}
```

*两个方法的不同就是，调用 execute() 的时候是没有返回值，所以如果需要返回结果就需要使用 submit() 提交。*

### 关闭线程池

*我们可以调用线程池对象的 `shutdown()` 和 `shutdownNow()` 方法来关闭线程池。*

*这两个方法都是关闭操作，又有什么不同呢？*
- *`shutdown()` 会将线程池状态置为 `SHUTDOWN`，不再接受新的任务，同时会等待线程池中已有的任务执行完成再结束。*
- *`shutdownNow()` 会将线程池状态置为 `SHUTDOWN`，对所有线程执行 `interrupt()` 操作，清空队列，并将队列中的任务返回回来。*

*[Java线程池的使用 - 简书 (jianshu.com)](https://www.jianshu.com/p/7ab4ae9443b9)*


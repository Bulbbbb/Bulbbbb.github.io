---
aliases: 
tags: 
---
_synchronized 解决了多线程的竞争，但是没有解决多线程的协作。_

```java
class TaskQueue {
    Queue<String> queue = new LinkedList<>();

    public synchronized void addTask(String s) {
        this.queue.add(s);
    }

    public synchronized String getTask() {
        while (queue.isEmpty()) {  // 循环等待，直到队列不为空
        }
        return queue.remove();
    }
}
```

_在上面代码中，`getTask()` 内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，`while()` 循环退出，就可以返回队列的元素了。_
_但实际上 `while()` 循环永远不会退出。因为线程在执行 `while()` 循环时，已经在 `getTask()` 入口获取了 `this` 锁，其他线程根本无法调用 `addTask()`，因为 `addTask()` 执行条件也是获取 `this` 锁_

## 协作的场景

### 生产者/消费者协作模式⭐

_在生产者消费者协作场景中，==生产者线程和消费者线程通过共享队列进行协作==，生产者将数据或任务放到队列上，而消费者从队列上取数据或任务，如果队列长度有限，在队列满的时候，生产者需要等待，而在队列为空的时候，消费者需要等待。_

### 同时开始

_要求多个线程能同时开始。_

### 等待结束（主从协作）

_主线程将任务分解为若干子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕。_

### 异步结果

_在主从协作模式中，主线程手工创建子线程的写法往往比较麻烦，一种常见的模式是将子线程的管理封装为异步调用，异步调用马上返回，但返回的不是最终的结果，而是一个一般称为 Future 的对象,通过它可以在随后获得最终的结果。_

### 集合点

_每个线程负责一部分计算，然后在集合点等待其他线程完成，所有线程到齐后，交换数据和计算结果，再进行下一次迭代。_

## 协作方法

*在 Java 中提供了下面方法来进行线程协作：*
1. *wait、notify*
---
aliases: 
tags: 
---
*显式条件同样借助于 AQS 实现：*

```java
public Condition newCondition() {  
	return sync.newCondition();  
}
```

*可以看到，会调用 AQS 中的 newCondition() 方法,newCondition() 返回一个 ConditionObject 队列，而 ConditionObject 是 AQS 的内部类，实现了 Condition 接口。*

```java
final ConditionObject newCondition() {  
	return new ConditionObject();  
}
```

*在 ConditionObject 类中，也维持着一个队列，被称为条件队列。显式条件就是借助条件队列实现的。*

```java
public class ConditionObject implements Condition {
	private transient Node firstWaiter;  // 指向条件队列第一个结点
	private transient Node lastWaiter; // 指向条件队列中最后一个结点
}
```

*在这里我们通过 AQS 是如何实现 Condition 接口中的 await 和 signal 来了解条件变量的实现原理。*

## await

```java
public final void await() throws InterruptedException {  
	if (Thread.interrupted())  // 如果等待前中断标志被设置了，抛异常
		throw new InterruptedException();  
	Node node = addConditionWaiter();  // 新建结点插入队尾，并返回该节点
	int savedState = fullyRelease(node);  // 当前线程释放锁
	int interruptMode = 0;  
	while (!isOnSyncQueue(node)) {  // 循环判断是否在同步队列中
		LockSupport.park(this);  // 挂起线程
		/*unpark后执行下面操作*/
		if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)  //被唤醒后判断，断是否发生在 signal 将线程加入同步队列之后还是之前
			break;  
	}  
	// 只要退出同步队列，结点就一定在同步队列中
	// acquireQueued(),返回的时候一定会申请到锁，如果返回true，说明在获取锁的过程中发生过中断，此时中断标志因为判断被清除
	// 然后，如果中断唤醒发生在加入同步队列之后，再设置一次，因为可能为0
	if (acquireQueued(node, savedState) && interruptMode != THROW_IE)  
		interruptMode = REINTERRUPT;  // 需要重新设置中断标志（检查时被清除）
	if (node.nextWaiter != null) // clean up if cancelled  
		unlinkCancelledWaiters();  // // 把节点等待状态（waitStatus）不为 CONDITION 的节点移除
	if (interruptMode != 0)  
		reportInterruptAfterWait(interruptMode);  // 根据不同的中断模式决定是抛出中断异常还是重新标记中断
}
```

*addConditionWaiter() 新建结点，并采用尾插法将节点插入队尾。*
*从代码中可以看出，条件队列为单向队列，且头节点并不是虚结点。*

```java
private Node addConditionWaiter() {  
	if (!isHeldExclusively())  
		throw new IllegalMonitorStateException();  
	Node t = lastWaiter;  // 获取尾节点
	// If lastWaiter is cancelled, clean out.  
	if (t != null && t.waitStatus != Node.CONDITION) {   // 最后一个结点不为null，且不为CONDITION
		unlinkCancelledWaiters();  // 遍历条件队列，移除cancelled结点
		t = lastWaiter;  // 再次获取尾结点
	}  
	Node node = new Node(Node.CONDITION);  // 新建结点
	if (t == null)  // 队列为空
		firstWaiter = node;  // 头指针指向新建结点
	else   // 队列不为空
		t.nextWaiter = node;  // 尾指针的nextWaiter指向新建结点
	lastWaiter = node;   // 尾指针指向新建系结点
	return node;  
}
```

*unlinkCancelledWaiters() 的作用是遍历条件队列，将非 CONDITION 状态到的节点移除。*
*处于条件队列中的线程的状态都应该为 CONDITION，如果不为 CONDITION，则可能为 CANCELLED。*

```java
private void unlinkCancelledWaiters() {  
	Node t = firstWaiter;  // t指向头节点
	Node trail = null;  
	while (t != null) {  
		Node next = t.nextWaiter;  // t的后继结点
		if (t.waitStatus != Node.CONDITION) {  // 如果t指向的结点状态不为CONDITION
			t.nextWaiter = null;  // 将t指向结点的nextWaiter指针设为null
			if (trail == null)  // t结点之前没有CONDITION结点
				firstWaiter = next; // 则改变头指针
			else  // t之前有CONDITION结点，tail表示上一个CONDITION结点
				trail.nextWaiter = next;  // 将CONDITION结点的nextWaiter指针t的后继结点
			if (next == null)  // t后继结点为null，说明trail为最后一个CONDITION结点
				lastWaiter = trail;  
		}  else  
			trail = t;  // 如果结点状态为CONDITION，使用trail指针指向此结点
		t = next;  // t指向下一个结点
	}  
}
```

```java
final int fullyRelease(Node node) {  
	try {  
		int savedState = getState();  // 获取state
		if (release(savedState))  // 调用release()释放锁
			return savedState;  // 释放成功返回state
		throw new IllegalMonitorStateException();  // 否则抛出异常
	} catch (Throwable t) {  
		node.waitStatus = Node.CANCELLED;  
		throw t;  
	}  
}
```

*调用 wait 的线程一定获取到了，一定不在同步队列中，为什么还需要调用 isOnSyncQueue() 判断?*
*在等到某一个线程 signal 后，会头从开始唤醒，不一定唤醒这一个线程。*

```java
final boolean isOnSyncQueue(Node node) {  
	/*
	* 1. Node的状态为CONDITION，状态为CONDITION的结点，在addConditionWaiter()中被从条件队列移除
	* 2. prev = null 的结点为头节点
	*/
	if (node.waitStatus == Node.CONDITION || node.prev == null)  
		return false;  
	// 存在后继结点，则该结点一定在等待队列中
	if (node.next != null) // If has successor, it must be on queue  
		return true;  
	return findNodeFromTail(node);  // 如果prev不为null，或者next为null
}
```

*为什么需要调用 findNodeFromTail() 判断？*
*当 prev 不为 null 时，或者 next 为 null 时，无法判断结点在不在同步队列中。*
*在入队操作时，分为以下步骤：*
1. *将当前节点的 prev 指向 oldTail*
2. *将 tail 指向当前结点*
3. *将 oldTail 的 next 指向当前结点*

*第 2 步采用 CAS 机制，CAS 可能失败，如果失败，则 prev 不为 null，next 为 null。*

*findNodeFromTail() 从后往前遍历同步队列，在以下两种情况退出：*
+ *尾结点为 null，等待队列为空，当前结点肯定不在等待队列*
+ *等一个结点等于当前结点，证明当前结点在等待队列中*

```java
private boolean findNodeFromTail(Node node) {  
	for (Node p = tail;;) {  // p指向尾结点
		if (p == node)  // 判断当前结点是不是尾结点
			return true;  
		if (p == null)  // 
			return false;  
		p = p.prev;  // 指向前继结点
	}  
}
```

*在使用 signal 唤醒的时候，signal 的逻辑是先将结点加入同步队列，然后唤醒线程，中段唤醒可能发生在 signal 将线程加入同步队列之后，也可以发生在 signal 将线程加入同步队列之前。*

*checkInterruptWhileWaiting() 函数可以判断是否发生过中断，中断是否发生在 signal 将线程加入同步队列之后还是之前。*
如果 checkInterruptWhileWaiting() 函数返回 0，说明没有发生过中断
*如果 发生过中断，调用 transferAfterCancelledWait 判断发生在 signal 将线程加入同步队列之前还是之后。*
*如果发生在 signal 将线程加入同步队列之前，返回 THROW_IE。*
*如果发生在 signal 将线程加入同步队列之后，返回 REINTERRUPT。*

```java
private int checkInterruptWhileWaiting(Node node) {  
	return Thread.interrupted() ?  // 中断标识被设置过
		(transferAfterCancelledWait(node) ? // transferAfterCancelledWait返回true，THROW_IE
		THROW_IE : REINTERRUPT) :  // transferAfterCancelledWait返回false，REINTERRUPT
		0;  // 中断标识未被设置过
}
```

*node.compareAndSetWaitStatus(Node.CONDITION, 0) 设置成功，线程的结点状态为 CONDITION，说明此时结点未处于同步队列中，中断发生在 signal 将结点加入同步队列之前，此时将结点加入同步队列，返回 true*
*如果设置失败，说明线程的结点状态不为 CONDITION，已经加入了同步队列，返回 false。*

```java
final boolean transferAfterCancelledWait(Node node) {  
	if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {  
		enq(node);  // 在signal之前调用中断返回true
		return true;  
	}  
	while (!isOnSyncQueue(node))  
		Thread.yield();  
	return false;  // 加入失败
}
```

```java
private void reportInterruptAfterWait(int interruptMode)
    throws InterruptedException {
    // signal 之前的中断， 需要抛出异常
    if (interruptMode == THROW_IE)
        throw new InterruptedException();
    // signal 之后发生的中断， 需要重新中断
    else if (interruptMode == REINTERRUPT)
        selfInterrupt();
}
```

## signal

```java
public final void signal() {  
	if (!isHeldExclusively()) throw new IllegalMonitorStateException();  
		Node first = firstWaiter;   // 头节点
	if (first != null)  
		doSignal(first);  // 从头节点开始唤醒
}
```

```java
private void doSignal(Node first) {  
	do {  
		if ( (firstWaiter = first.nextWaiter) == null)  // firstWaiter指向下一个结点
			lastWaiter = null;  
		first.nextWaiter = null;  // 头节点的nextWaiter设为null
	} while (!transferForSignal(first)  // 迁移头节点到同步队列
		&& (first = firstWaiter) != null);  // 迁移失败后 first 指向 firstWaiter，即下一个结点
}
```

```java
final boolean transferForSignal(Node node) {  

	if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))   // 通过CAS将状态更新为0
		return false;  // 更新失败，结点的状态不为CONDITION，使用下一个结点
	Node p = enq(node);  // 入同步队列,enq返回的是未插入前队列中尾结点
	int ws = p.waitStatus;  
	if (ws > 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))  // 上一个结点状态为CANCLED，或不不能设置为SIGNAL
		LockSupport.unpark(node.thread);  // 唤醒当前结点，避免不能唤醒
	return true;  
}
```

![[Pasted image 20230509170505.png]]


---
aliases: 
tags: 
---
*显式条件用于实现线程间的协作，wait/notify 与 synchronized 配合使用，而现实条件与显式锁配合使用。*

*在 Lock 接口中定义了显式条件的创建方法：*

```java
interface Lock{
	...
	Condition newCondition();
	...
}
```

*Condition 用于表示条件变量，是一个接口：*

```java
public interface Condition { 
	void await() throws InterruptedException; 
	void awaitUninterruptibly(); 
	long awaitNanos(long nanosTimeout) throws InterruptedException; 
	boolean await(long time, TimeUnit unit) throws InterruptedException; 
	boolean awaitUntil(Date deadline) throws InterruptedException; 
	void signal(); 
	void signalAll(); 
}
```

*await 对应于 Object 的 wait，signal 对应于 notify，signalAll 对应于 notifyAll，语义也是一样的。*

*使用方法和 Object 中的 wait 和 notify 是相同的，使用的前提是必须获得锁，这里不详细介绍。*

> [!note] *Condition 的实现类中也会有 wait 和 notify，所以不要用错了，显式条件必须与显式锁配合使用。*

## 使用显式条件解决生产者消费者模式

> [!note] *注意，显式锁中是 await() 和 signal。*

```java
static class MyBlockingQueue { 
	private Queue queue = null; 
	private int limit; 
	private Lock lock = new ReentrantLock();  // 获取锁
	private Condition notFull = lock.newCondition(); // 显式条件
	private Condition notEmpty = lock.newCondition();
	public MyBlockingQueue(int limit) { 
		this.limit = limit; 
		queue = new ArrayDeque<>(limit); 
	} 
	public synchronized void put(E e) throws InterruptedException { 
		while(queue.size() == limit) {  // 放之前如果队列满，则等待
			notFull.await(); // 将线程加入 notFull 的条件队列
		} 
		queue.add(e); 
		notEmpty.signal(); // 唤醒一个 notEmpty 条件队列上的线程
	} 
	public synchronized E take() throws InterruptedException { 
		while(queue.isEmpty()) {  // 取之前如果为空，则等待
			notEmpty.await();  
		} 
		E e = queue.poll(); 
		notFull.signal();  // 唤醒一个线程
	return e;  
	} 
}
```

*上述代码定义了两个等待条件: 不满 (notFull)、不空 (notEmpty)。*
*在 put 方法中，如果队列满，则在 notFull 上等待，含义为等待队列不满;* 
*在 take 方法中，如果队列空，则在 notEmpty 上等待，含义为等待队列不空。*
*put 操作后通知 notEmpty，take 操作后通知 notFull。*

> [!note] *这里使用了两个条件队列，如果只适用一个条件队列需要使用 signalAll() 唤醒。*
---
aliases: 
tags: 
---

> [!note] _这里需要说明一下，类型通配符是作为类型参数使用的，不要把通配符作为类型变量。_

## 一、无边界通配符 `<?>`

_可以接受未知类型的参数_

> [!note]
>
> _需要注意的是，`<?>` 中 ? 是通配符（wildcard），`<T>` 中 T 是类型变量。通配符？不能用在声明处（泛型在使用之前都需要声明）。_

## 二、固定上边界的通配符 `<? extends E>`

_**代表 E 的一个子类，但不确定是哪一个子类。**_
![[Pasted image 20230110152409.png|400]]
_看下面代码：_

```java
List<Apple> apples = new ArrayList<Apple>();
List<? extends Fruit> fruits = apples;
```

_正常情况下，apple 只能赋值给 `List<Apple>` 类型的变量：_

```java
List<Apple> apples1 = apples;
```

_因为泛型中是不存在继承关系的，所以泛型类是不允许向上转型的：_

```java
List<Fruit> fruits1 = apples;
```

_但是，使用泛型通配符之后，`<? extends Fruit>` 是不确定的，所以就可能是 `<Apple>` 类型，所以能赋值。_
_因为 `<? extends Fruit>` 是不确定的，所以我们不能往里添加元素，所以下面 add() 方法不能使用：_

```java
fruit.add(new Fruit());
```

_对于 `<? extends Fruit>`，我们并不确定是什么类型，所以对于涉及到具体的类型的操作我们是不能使用，同样，我们知道的是，它一定是 Fruit 类的子类，所以我们一定能通过 Fruit 类进行接收。_

```java
Fruit fruit = fruits.get(0);
```

## 三、固定下边界的通配符 `<? super E>`

_**代表 E 的一个父类，但不确定是哪一个父类。**_
![[Pasted image 20230110153620.png|400]]
_看下面代码：_

```java
List<Fruit> fruits = new ArrayList<>();
List<? super Apple> apple = fruits;
```

_与固定上边界的通配符类似，`<? super Apple>` 是 Apple 的一个父类，虽然不知道哪一个父类，可能是 Fruit。_

_与固定上界通配符不同的是，固定下届的通配符可以往里添加元素：_

_因为类型是向下兼容的，既然是 Apple 的父类，那么就可以兼容 Apple 及其子类。_

```java
apple.add(new Apple());
```

_但是不能取元素：_

```java
Fruit fruit = apple.get(0);
```

## 四、存取原则和 PECS 法则

_PECS 法则：生产者（Producer）使用 extends，消费者（Consumer）使用 super。_

+ _**生产者使用 extends**_
  _如果你需要一个列表对外提供元素，则需要将列表声明为 `<? extends T>`_
+ _**消费者使用 super**_
  _如果你需要一个列表存储元素，则需要将列表声明为 `<? super T>`_
+ _**既是生产者，又是消费者**_
  _如果该列表，既要对外提供元素，又要存储元素，比如 List，就不能使用泛型通配符。_

_Java 中可以进行向上转型和向下转型，向下转型必须强制转换，并且会存在风险，所以在类型通配符中只能进行向上转型。_

_我们将每一种类型通配符的操作分为存 (add) 和取 (get) 两种操作。_
_其中存操作可以理解为将其他类型转换为类型通配符确定的类型。也就是为类型通配符确定的类型找一个子类。_
_取操作可以理解为将类型通配符确定的类型转换为其他类型。也就是为类型通配符类型找一个父类。_

_在固定上边界的通配符中，我们可以确定父类，也就说可以为其找到一个父类。即可以将类型通配符确定的类型转换为其他类型，此为取（get）。
但是却不能确定子类，因此不能存 (add)。_

_在固定下边界的通配符中，我们可以确定最小子类，因此我们可以为其找到子类，这个子类可以转化为类型通配符确定的类型，此为存（add）。
但是不能为其找到一个父类，因此不能取（get）。_

*存：将其他类转换为类型通配符确定的类      找子类          固定下边界*
*取：将类型通配符确定的类转换为其他类      找父类          固定上边界*    
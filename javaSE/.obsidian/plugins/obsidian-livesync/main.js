/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD AND TERSER
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";

var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __defNormalProp = (s, r, o) => r in s ? __defProp(s, r, {
  enumerable: true,
  configurable: true,
  writable: true,
  value: o
}) : s[r] = o, __commonJS = (s, r) => function __require() {
  return r || (0, s[__getOwnPropNames(s)[0]])((r = {
    exports: {}
  }).exports, r), r.exports;
}, __export = (s, r) => {
  for (var o in r) __defProp(s, o, {
    get: r[o],
    enumerable: true
  });
}, __copyProps = (s, r, o, u) => {
  if (r && "object" == typeof r || "function" == typeof r) for (let g of __getOwnPropNames(r)) if (!__hasOwnProp.call(s, g) && g !== o) __defProp(s, g, {
    get: () => r[g],
    enumerable: !(u = __getOwnPropDesc(r, g)) || u.enumerable
  });
  return s;
}, __toESM = (s, r, o) => (o = null != s ? __create(__getProtoOf(s)) : {}, __copyProps(r || !s || !s.__esModule ? __defProp(o, "default", {
  value: s,
  enumerable: true
}) : o, s)), __toCommonJS = s => __copyProps(__defProp({}, "__esModule", {
  value: true
}), s), __publicField = (s, r, o) => {
  __defNormalProp(s, "symbol" != typeof r ? r + "" : r, o);
  return o;
}, __accessCheck = (s, r, o) => {
  if (!r.has(s)) throw TypeError("Cannot " + o);
}, __privateGet = (s, r, o) => {
  __accessCheck(s, r, "read from private field");
  return o ? o.call(s) : r.get(s);
}, __privateAdd = (s, r, o) => {
  if (r.has(s)) throw TypeError("Cannot add the same private member more than once");
  r instanceof WeakSet ? r.add(s) : r.set(s, o);
}, __privateSet = (s, r, o, u) => {
  __accessCheck(s, r, "write to private field");
  u ? u.call(s, o) : r.set(s, o);
  return o;
}, __privateMethod = (s, r, o) => {
  __accessCheck(s, r, "access private method");
  return o;
}, require_diff_match_patch = __commonJS({
  "node_modules/diff-match-patch/index.js"(s, r) {
    var diff_match_patch2 = function() {
      this.Diff_Timeout = 1;
      this.Diff_EditCost = 4;
      this.Match_Threshold = .5;
      this.Match_Distance = 1e3;
      this.Patch_DeleteThreshold = .5;
      this.Patch_Margin = 4;
      this.Match_MaxBits = 32;
    }, o = -1, u = 1, g = 0;
    diff_match_patch2.Diff = function(s, r) {
      return [ s, r ];
    };
    diff_match_patch2.prototype.diff_main = function(s, r, o, u) {
      if ("undefined" == typeof u) if (this.Diff_Timeout <= 0) u = Number.MAX_VALUE; else u = (new Date).getTime() + 1e3 * this.Diff_Timeout;
      var g = u;
      if (null == s || null == r) throw new Error("Null input. (diff_main)");
      if (s == r) {
        if (s) return [ new diff_match_patch2.Diff(0, s) ];
        return [];
      }
      if ("undefined" == typeof o) o = true;
      var _ = o, b = this.diff_commonPrefix(s, r), w = s.substring(0, b);
      s = s.substring(b);
      r = r.substring(b);
      b = this.diff_commonSuffix(s, r);
      var E = s.substring(s.length - b);
      s = s.substring(0, s.length - b);
      r = r.substring(0, r.length - b);
      var S = this.diff_compute_(s, r, _, g);
      if (w) S.unshift(new diff_match_patch2.Diff(0, w));
      if (E) S.push(new diff_match_patch2.Diff(0, E));
      this.diff_cleanupMerge(S);
      return S;
    };
    diff_match_patch2.prototype.diff_compute_ = function(s, r, u, g) {
      var _;
      if (!s) return [ new diff_match_patch2.Diff(1, r) ];
      if (!r) return [ new diff_match_patch2.Diff(o, s) ];
      var b = s.length > r.length ? s : r, w = s.length > r.length ? r : s, E = b.indexOf(w);
      if (-1 != E) {
        _ = [ new diff_match_patch2.Diff(1, b.substring(0, E)), new diff_match_patch2.Diff(0, w), new diff_match_patch2.Diff(1, b.substring(E + w.length)) ];
        if (s.length > r.length) _[0][0] = _[2][0] = o;
        return _;
      }
      if (1 == w.length) return [ new diff_match_patch2.Diff(o, s), new diff_match_patch2.Diff(1, r) ];
      var S = this.diff_halfMatch_(s, r);
      if (S) {
        var L = S[0], O = S[1], D = S[2], k = S[3], C = S[4], T = this.diff_main(L, D, u, g), I = this.diff_main(O, k, u, g);
        return T.concat([ new diff_match_patch2.Diff(0, C) ], I);
      }
      if (u && s.length > 100 && r.length > 100) return this.diff_lineMode_(s, r, g);
      return this.diff_bisect_(s, r, g);
    };
    diff_match_patch2.prototype.diff_lineMode_ = function(s, r, u) {
      var g = this.diff_linesToChars_(s, r);
      s = g.chars1;
      r = g.chars2;
      var _ = g.lineArray, b = this.diff_main(s, r, false, u);
      this.diff_charsToLines_(b, _);
      this.diff_cleanupSemantic(b);
      b.push(new diff_match_patch2.Diff(0, ""));
      for (var w = 0, E = 0, S = 0, L = "", O = ""; w < b.length; ) {
        switch (b[w][0]) {
         case 1:
          S++;
          O += b[w][1];
          break;

         case o:
          E++;
          L += b[w][1];
          break;

         case 0:
          if (E >= 1 && S >= 1) {
            b.splice(w - E - S, E + S);
            w = w - E - S;
            for (var D = this.diff_main(L, O, false, u), k = D.length - 1; k >= 0; k--) b.splice(w, 0, D[k]);
            w += D.length;
          }
          S = 0;
          E = 0;
          L = "";
          O = "";
          break;
        }
        w++;
      }
      b.pop();
      return b;
    };
    diff_match_patch2.prototype.diff_bisect_ = function(s, r, u) {
      for (var g = s.length, _ = r.length, b = Math.ceil((g + _) / 2), w = b, E = 2 * b, S = new Array(E), L = new Array(E), O = 0; O < E; O++) {
        S[O] = -1;
        L[O] = -1;
      }
      S[w + 1] = 0;
      L[w + 1] = 0;
      for (var D = g - _, k = D % 2 != 0, C = 0, T = 0, I = 0, A = 0, x = 0; x < b && !((new Date).getTime() > u); x++) {
        for (var R = -x + C; R <= x - T; R += 2) {
          var P = w + R, N;
          if (R == -x || R != x && S[P - 1] < S[P + 1]) N = S[P + 1]; else N = S[P - 1] + 1;
          for (var B = N - R; N < g && B < _ && s.charAt(N) == r.charAt(B); ) {
            N++;
            B++;
          }
          S[P] = N;
          if (N > g) T += 2; else if (B > _) C += 2; else if (k) {
            var F;
            if ((F = w + D - R) >= 0 && F < E && -1 != L[F]) {
              var M;
              if (N >= (M = g - L[F])) return this.diff_bisectSplit_(s, r, N, B, u);
            }
          }
        }
        for (var V = -x + I; V <= x - A; V += 2) {
          var F = w + V, M;
          if (V == -x || V != x && L[F - 1] < L[F + 1]) M = L[F + 1]; else M = L[F - 1] + 1;
          for (var G = M - V; M < g && G < _ && s.charAt(g - M - 1) == r.charAt(_ - G - 1); ) {
            M++;
            G++;
          }
          L[F] = M;
          if (M > g) A += 2; else if (G > _) I += 2; else if (!k) {
            var P;
            if ((P = w + D - V) >= 0 && P < E && -1 != S[P]) {
              var N, B = w + (N = S[P]) - P;
              if (N >= (M = g - M)) return this.diff_bisectSplit_(s, r, N, B, u);
            }
          }
        }
      }
      return [ new diff_match_patch2.Diff(o, s), new diff_match_patch2.Diff(1, r) ];
    };
    diff_match_patch2.prototype.diff_bisectSplit_ = function(s, r, o, u, g) {
      var _ = s.substring(0, o), b = r.substring(0, u), w = s.substring(o), E = r.substring(u), S = this.diff_main(_, b, false, g), L = this.diff_main(w, E, false, g);
      return S.concat(L);
    };
    diff_match_patch2.prototype.diff_linesToChars_ = function(s, r) {
      var o = [], u = {};
      o[0] = "";
      function diff_linesToCharsMunge_(s) {
        for (var r = "", _ = 0, b = -1, w = o.length; b < s.length - 1; ) {
          if (-1 == (b = s.indexOf("\n", _))) b = s.length - 1;
          var E = s.substring(_, b + 1);
          if (u.hasOwnProperty ? u.hasOwnProperty(E) : void 0 !== u[E]) r += String.fromCharCode(u[E]); else {
            if (w == g) {
              E = s.substring(_);
              b = s.length;
            }
            r += String.fromCharCode(w);
            u[E] = w;
            o[w++] = E;
          }
          _ = b + 1;
        }
        return r;
      }
      var g = 4e4, _ = diff_linesToCharsMunge_(s), b;
      g = 65535;
      return {
        chars1: _,
        chars2: diff_linesToCharsMunge_(r),
        lineArray: o
      };
    };
    diff_match_patch2.prototype.diff_charsToLines_ = function(s, r) {
      for (var o = 0; o < s.length; o++) {
        for (var u = s[o][1], g = [], _ = 0; _ < u.length; _++) g[_] = r[u.charCodeAt(_)];
        s[o][1] = g.join("");
      }
    };
    diff_match_patch2.prototype.diff_commonPrefix = function(s, r) {
      if (!s || !r || s.charAt(0) != r.charAt(0)) return 0;
      for (var o = 0, u = Math.min(s.length, r.length), g = u, _ = 0; o < g; ) {
        if (s.substring(_, g) == r.substring(_, g)) _ = o = g; else u = g;
        g = Math.floor((u - o) / 2 + o);
      }
      return g;
    };
    diff_match_patch2.prototype.diff_commonSuffix = function(s, r) {
      if (!s || !r || s.charAt(s.length - 1) != r.charAt(r.length - 1)) return 0;
      for (var o = 0, u = Math.min(s.length, r.length), g = u, _ = 0; o < g; ) {
        if (s.substring(s.length - g, s.length - _) == r.substring(r.length - g, r.length - _)) _ = o = g; else u = g;
        g = Math.floor((u - o) / 2 + o);
      }
      return g;
    };
    diff_match_patch2.prototype.diff_commonOverlap_ = function(s, r) {
      var o = s.length, u = r.length;
      if (0 == o || 0 == u) return 0;
      if (o > u) s = s.substring(o - u); else if (o < u) r = r.substring(0, o);
      var g = Math.min(o, u);
      if (s == r) return g;
      for (var _ = 0, b = 1; ;) {
        var w = s.substring(g - b), E = r.indexOf(w);
        if (-1 == E) return _;
        b += E;
        if (0 == E || s.substring(g - b) == r.substring(0, b)) {
          _ = b;
          b++;
        }
      }
    };
    diff_match_patch2.prototype.diff_halfMatch_ = function(s, r) {
      if (this.Diff_Timeout <= 0) return null;
      var o = s.length > r.length ? s : r, u = s.length > r.length ? r : s;
      if (o.length < 4 || 2 * u.length < o.length) return null;
      var g = this;
      function diff_halfMatchI_(s, r, o) {
        for (var u = s.substring(o, o + Math.floor(s.length / 4)), _ = -1, b = "", w, E, S, L; -1 != (_ = r.indexOf(u, _ + 1)); ) {
          var O = g.diff_commonPrefix(s.substring(o), r.substring(_)), D = g.diff_commonSuffix(s.substring(0, o), r.substring(0, _));
          if (b.length < D + O) {
            b = r.substring(_ - D, _) + r.substring(_, _ + O);
            w = s.substring(0, o - D);
            E = s.substring(o + O);
            S = r.substring(0, _ - D);
            L = r.substring(_ + O);
          }
        }
        if (2 * b.length >= s.length) return [ w, E, S, L, b ]; else return null;
      }
      var _ = diff_halfMatchI_(o, u, Math.ceil(o.length / 4)), b = diff_halfMatchI_(o, u, Math.ceil(o.length / 2)), w, E, S, L, O, D;
      if (!_ && !b) return null; else if (!b) w = _; else if (!_) w = b; else w = _[4].length > b[4].length ? _ : b;
      if (s.length > r.length) {
        E = w[0];
        S = w[1];
        L = w[2];
        O = w[3];
      } else {
        L = w[0];
        O = w[1];
        E = w[2];
        S = w[3];
      }
      return [ E, S, L, O, w[4] ];
    };
    diff_match_patch2.prototype.diff_cleanupSemantic = function(s) {
      for (var r = false, u = [], g = 0, _ = null, b = 0, w = 0, E = 0, S = 0, L = 0; b < s.length; ) {
        if (0 == s[b][0]) {
          u[g++] = b;
          w = S;
          E = L;
          S = 0;
          L = 0;
          _ = s[b][1];
        } else {
          if (1 == s[b][0]) S += s[b][1].length; else L += s[b][1].length;
          if (_ && _.length <= Math.max(w, E) && _.length <= Math.max(S, L)) {
            s.splice(u[g - 1], 0, new diff_match_patch2.Diff(o, _));
            s[u[g - 1] + 1][0] = 1;
            g--;
            b = --g > 0 ? u[g - 1] : -1;
            w = 0;
            E = 0;
            S = 0;
            L = 0;
            _ = null;
            r = true;
          }
        }
        b++;
      }
      if (r) this.diff_cleanupMerge(s);
      this.diff_cleanupSemanticLossless(s);
      b = 1;
      for (;b < s.length; ) {
        if (s[b - 1][0] == o && 1 == s[b][0]) {
          var O = s[b - 1][1], D = s[b][1], k = this.diff_commonOverlap_(O, D), C = this.diff_commonOverlap_(D, O);
          if (k >= C) {
            if (k >= O.length / 2 || k >= D.length / 2) {
              s.splice(b, 0, new diff_match_patch2.Diff(0, D.substring(0, k)));
              s[b - 1][1] = O.substring(0, O.length - k);
              s[b + 1][1] = D.substring(k);
              b++;
            }
          } else if (C >= O.length / 2 || C >= D.length / 2) {
            s.splice(b, 0, new diff_match_patch2.Diff(0, O.substring(0, C)));
            s[b - 1][0] = 1;
            s[b - 1][1] = D.substring(0, D.length - C);
            s[b + 1][0] = o;
            s[b + 1][1] = O.substring(C);
            b++;
          }
          b++;
        }
        b++;
      }
    };
    diff_match_patch2.prototype.diff_cleanupSemanticLossless = function(s) {
      function diff_cleanupSemanticScore_(s, r) {
        if (!s || !r) return 6;
        var o = s.charAt(s.length - 1), u = r.charAt(0), g = o.match(diff_match_patch2.nonAlphaNumericRegex_), _ = u.match(diff_match_patch2.nonAlphaNumericRegex_), b = g && o.match(diff_match_patch2.whitespaceRegex_), w = _ && u.match(diff_match_patch2.whitespaceRegex_), E = b && o.match(diff_match_patch2.linebreakRegex_), S = w && u.match(diff_match_patch2.linebreakRegex_), L = E && s.match(diff_match_patch2.blanklineEndRegex_), O = S && r.match(diff_match_patch2.blanklineStartRegex_);
        if (L || O) return 5; else if (E || S) return 4; else if (g && !b && w) return 3; else if (b || w) return 2; else if (g || _) return 1;
        return 0;
      }
      for (var r = 1; r < s.length - 1; ) {
        if (0 == s[r - 1][0] && 0 == s[r + 1][0]) {
          var o = s[r - 1][1], u = s[r][1], g = s[r + 1][1], _ = this.diff_commonSuffix(o, u);
          if (_) {
            var b = u.substring(u.length - _);
            o = o.substring(0, o.length - _);
            u = b + u.substring(0, u.length - _);
            g = b + g;
          }
          for (var w = o, E = u, S = g, L = diff_cleanupSemanticScore_(o, u) + diff_cleanupSemanticScore_(u, g); u.charAt(0) === g.charAt(0); ) {
            o += u.charAt(0);
            u = u.substring(1) + g.charAt(0);
            g = g.substring(1);
            var O = diff_cleanupSemanticScore_(o, u) + diff_cleanupSemanticScore_(u, g);
            if (O >= L) {
              L = O;
              w = o;
              E = u;
              S = g;
            }
          }
          if (s[r - 1][1] != w) {
            if (w) s[r - 1][1] = w; else {
              s.splice(r - 1, 1);
              r--;
            }
            s[r][1] = E;
            if (S) s[r + 1][1] = S; else {
              s.splice(r + 1, 1);
              r--;
            }
          }
        }
        r++;
      }
    };
    diff_match_patch2.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    diff_match_patch2.whitespaceRegex_ = /\s/;
    diff_match_patch2.linebreakRegex_ = /[\r\n]/;
    diff_match_patch2.blanklineEndRegex_ = /\n\r?\n$/;
    diff_match_patch2.blanklineStartRegex_ = /^\r?\n\r?\n/;
    diff_match_patch2.prototype.diff_cleanupEfficiency = function(s) {
      for (var r = false, u = [], g = 0, _ = null, b = 0, w = false, E = false, S = false, L = false; b < s.length; ) {
        if (0 == s[b][0]) {
          if (s[b][1].length < this.Diff_EditCost && (S || L)) {
            u[g++] = b;
            w = S;
            E = L;
            _ = s[b][1];
          } else {
            g = 0;
            _ = null;
          }
          S = L = false;
        } else {
          if (s[b][0] == o) L = true; else S = true;
          if (_ && (w && E && S && L || _.length < this.Diff_EditCost / 2 && w + E + S + L == 3)) {
            s.splice(u[g - 1], 0, new diff_match_patch2.Diff(o, _));
            s[u[g - 1] + 1][0] = 1;
            g--;
            _ = null;
            if (w && E) {
              S = L = true;
              g = 0;
            } else {
              b = --g > 0 ? u[g - 1] : -1;
              S = L = false;
            }
            r = true;
          }
        }
        b++;
      }
      if (r) this.diff_cleanupMerge(s);
    };
    diff_match_patch2.prototype.diff_cleanupMerge = function(s) {
      s.push(new diff_match_patch2.Diff(0, ""));
      for (var r = 0, u = 0, g = 0, _ = "", b = "", w; r < s.length; ) switch (s[r][0]) {
       case 1:
        g++;
        b += s[r][1];
        r++;
        break;

       case o:
        u++;
        _ += s[r][1];
        r++;
        break;

       case 0:
        if (u + g > 1) {
          if (0 !== u && 0 !== g) {
            if (0 !== (w = this.diff_commonPrefix(b, _))) {
              if (r - u - g > 0 && 0 == s[r - u - g - 1][0]) s[r - u - g - 1][1] += b.substring(0, w); else {
                s.splice(0, 0, new diff_match_patch2.Diff(0, b.substring(0, w)));
                r++;
              }
              b = b.substring(w);
              _ = _.substring(w);
            }
            if (0 !== (w = this.diff_commonSuffix(b, _))) {
              s[r][1] = b.substring(b.length - w) + s[r][1];
              b = b.substring(0, b.length - w);
              _ = _.substring(0, _.length - w);
            }
          }
          r -= u + g;
          s.splice(r, u + g);
          if (_.length) {
            s.splice(r, 0, new diff_match_patch2.Diff(o, _));
            r++;
          }
          if (b.length) {
            s.splice(r, 0, new diff_match_patch2.Diff(1, b));
            r++;
          }
          r++;
        } else if (0 !== r && 0 == s[r - 1][0]) {
          s[r - 1][1] += s[r][1];
          s.splice(r, 1);
        } else r++;
        g = 0;
        u = 0;
        _ = "";
        b = "";
        break;
      }
      if ("" === s[s.length - 1][1]) s.pop();
      var E = false;
      r = 1;
      for (;r < s.length - 1; ) {
        if (0 == s[r - 1][0] && 0 == s[r + 1][0]) if (s[r][1].substring(s[r][1].length - s[r - 1][1].length) == s[r - 1][1]) {
          s[r][1] = s[r - 1][1] + s[r][1].substring(0, s[r][1].length - s[r - 1][1].length);
          s[r + 1][1] = s[r - 1][1] + s[r + 1][1];
          s.splice(r - 1, 1);
          E = true;
        } else if (s[r][1].substring(0, s[r + 1][1].length) == s[r + 1][1]) {
          s[r - 1][1] += s[r + 1][1];
          s[r][1] = s[r][1].substring(s[r + 1][1].length) + s[r + 1][1];
          s.splice(r + 1, 1);
          E = true;
        }
        r++;
      }
      if (E) this.diff_cleanupMerge(s);
    };
    diff_match_patch2.prototype.diff_xIndex = function(s, r) {
      var u = 0, g = 0, _ = 0, b = 0, w;
      for (w = 0; w < s.length; w++) {
        if (1 !== s[w][0]) u += s[w][1].length;
        if (s[w][0] !== o) g += s[w][1].length;
        if (u > r) break;
        _ = u;
        b = g;
      }
      if (s.length != w && s[w][0] === o) return b;
      return b + (r - _);
    };
    diff_match_patch2.prototype.diff_prettyHtml = function(s) {
      for (var r = [], u = /&/g, g = /</g, _ = />/g, b = /\n/g, w = 0; w < s.length; w++) {
        var E = s[w][0], S, L = s[w][1].replace(u, "&amp;").replace(g, "&lt;").replace(_, "&gt;").replace(b, "&para;<br>");
        switch (E) {
         case 1:
          r[w] = '<ins style="background:#e6ffe6;">' + L + "</ins>";
          break;

         case o:
          r[w] = '<del style="background:#ffe6e6;">' + L + "</del>";
          break;

         case 0:
          r[w] = "<span>" + L + "</span>";
          break;
        }
      }
      return r.join("");
    };
    diff_match_patch2.prototype.diff_text1 = function(s) {
      for (var r = [], o = 0; o < s.length; o++) if (1 !== s[o][0]) r[o] = s[o][1];
      return r.join("");
    };
    diff_match_patch2.prototype.diff_text2 = function(s) {
      for (var r = [], u = 0; u < s.length; u++) if (s[u][0] !== o) r[u] = s[u][1];
      return r.join("");
    };
    diff_match_patch2.prototype.diff_levenshtein = function(s) {
      for (var r = 0, u = 0, g = 0, _ = 0; _ < s.length; _++) {
        var b = s[_][0], w = s[_][1];
        switch (b) {
         case 1:
          u += w.length;
          break;

         case o:
          g += w.length;
          break;

         case 0:
          r += Math.max(u, g);
          u = 0;
          g = 0;
          break;
        }
      }
      return r += Math.max(u, g);
    };
    diff_match_patch2.prototype.diff_toDelta = function(s) {
      for (var r = [], u = 0; u < s.length; u++) switch (s[u][0]) {
       case 1:
        r[u] = "+" + encodeURI(s[u][1]);
        break;

       case o:
        r[u] = "-" + s[u][1].length;
        break;

       case 0:
        r[u] = "=" + s[u][1].length;
        break;
      }
      return r.join("\t").replace(/%20/g, " ");
    };
    diff_match_patch2.prototype.diff_fromDelta = function(s, r) {
      for (var u = [], g = 0, _ = 0, b = r.split(/\t/g), w = 0; w < b.length; w++) {
        var E = b[w].substring(1);
        switch (b[w].charAt(0)) {
         case "+":
          try {
            u[g++] = new diff_match_patch2.Diff(1, decodeURI(E));
          } catch (s) {
            throw new Error("Illegal escape in diff_fromDelta: " + E);
          }
          break;

         case "-":
         case "=":
          var S = parseInt(E, 10);
          if (isNaN(S) || S < 0) throw new Error("Invalid number in diff_fromDelta: " + E);
          var L = s.substring(_, _ += S);
          if ("=" == b[w].charAt(0)) u[g++] = new diff_match_patch2.Diff(0, L); else u[g++] = new diff_match_patch2.Diff(o, L);
          break;

         default:
          if (b[w]) throw new Error("Invalid diff operation in diff_fromDelta: " + b[w]);
        }
      }
      if (_ != s.length) throw new Error("Delta length (" + _ + ") does not equal source text length (" + s.length + ").");
      return u;
    };
    diff_match_patch2.prototype.match_main = function(s, r, o) {
      if (null == s || null == r || null == o) throw new Error("Null input. (match_main)");
      o = Math.max(0, Math.min(o, s.length));
      if (s == r) return 0; else if (!s.length) return -1; else if (s.substring(o, o + r.length) == r) return o; else return this.match_bitap_(s, r, o);
    };
    diff_match_patch2.prototype.match_bitap_ = function(s, r, o) {
      if (r.length > this.Match_MaxBits) throw new Error("Pattern too long for this browser.");
      var u = this.match_alphabet_(r), g = this;
      function match_bitapScore_(s, u) {
        var _ = s / r.length, b = Math.abs(o - u);
        if (!g.Match_Distance) return b ? 1 : _;
        return _ + b / g.Match_Distance;
      }
      var _ = this.Match_Threshold, b = s.indexOf(r, o);
      if (-1 != b) {
        _ = Math.min(match_bitapScore_(0, b), _);
        if (-1 != (b = s.lastIndexOf(r, o + r.length))) _ = Math.min(match_bitapScore_(0, b), _);
      }
      var w = 1 << r.length - 1, E, S;
      b = -1;
      for (var L = r.length + s.length, O, D = 0; D < r.length; D++) {
        E = 0;
        S = L;
        for (;E < S; ) {
          if (match_bitapScore_(D, o + S) <= _) E = S; else L = S;
          S = Math.floor((L - E) / 2 + E);
        }
        L = S;
        var k = Math.max(1, o - S + 1), C = Math.min(o + S, s.length) + r.length, T = Array(C + 2);
        T[C + 1] = (1 << D) - 1;
        for (var I = C; I >= k; I--) {
          var A = u[s.charAt(I - 1)];
          if (0 === D) T[I] = (T[I + 1] << 1 | 1) & A; else T[I] = (T[I + 1] << 1 | 1) & A | (O[I + 1] | O[I]) << 1 | 1 | O[I + 1];
          if (T[I] & w) {
            var x = match_bitapScore_(D, I - 1);
            if (x <= _) {
              _ = x;
              if ((b = I - 1) > o) k = Math.max(1, 2 * o - b); else break;
            }
          }
        }
        if (match_bitapScore_(D + 1, o) > _) break;
        O = T;
      }
      return b;
    };
    diff_match_patch2.prototype.match_alphabet_ = function(s) {
      for (var r = {}, o = 0; o < s.length; o++) r[s.charAt(o)] = 0;
      for (var o = 0; o < s.length; o++) r[s.charAt(o)] |= 1 << s.length - o - 1;
      return r;
    };
    diff_match_patch2.prototype.patch_addContext_ = function(s, r) {
      if (0 == r.length) return;
      if (null === s.start2) throw Error("patch not initialized");
      for (var o = r.substring(s.start2, s.start2 + s.length1), u = 0; r.indexOf(o) != r.lastIndexOf(o) && o.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin; ) {
        u += this.Patch_Margin;
        o = r.substring(s.start2 - u, s.start2 + s.length1 + u);
      }
      u += this.Patch_Margin;
      var g = r.substring(s.start2 - u, s.start2);
      if (g) s.diffs.unshift(new diff_match_patch2.Diff(0, g));
      var _ = r.substring(s.start2 + s.length1, s.start2 + s.length1 + u);
      if (_) s.diffs.push(new diff_match_patch2.Diff(0, _));
      s.start1 -= g.length;
      s.start2 -= g.length;
      s.length1 += g.length + _.length;
      s.length2 += g.length + _.length;
    };
    diff_match_patch2.prototype.patch_make = function(s, r, u) {
      var g, _;
      if ("string" == typeof s && "string" == typeof r && "undefined" == typeof u) {
        g = s;
        if ((_ = this.diff_main(g, r, true)).length > 2) {
          this.diff_cleanupSemantic(_);
          this.diff_cleanupEfficiency(_);
        }
      } else if (s && "object" == typeof s && "undefined" == typeof r && "undefined" == typeof u) {
        _ = s;
        g = this.diff_text1(_);
      } else if ("string" == typeof s && r && "object" == typeof r && "undefined" == typeof u) {
        g = s;
        _ = r;
      } else if ("string" == typeof s && "string" == typeof r && u && "object" == typeof u) {
        g = s;
        _ = u;
      } else throw new Error("Unknown call format to patch_make.");
      if (0 === _.length) return [];
      for (var b = [], w = new diff_match_patch2.patch_obj, E = 0, S = 0, L = 0, O = g, D = g, k = 0; k < _.length; k++) {
        var C = _[k][0], T = _[k][1];
        if (!E && 0 !== C) {
          w.start1 = S;
          w.start2 = L;
        }
        switch (C) {
         case 1:
          w.diffs[E++] = _[k];
          w.length2 += T.length;
          D = D.substring(0, L) + T + D.substring(L);
          break;

         case o:
          w.length1 += T.length;
          w.diffs[E++] = _[k];
          D = D.substring(0, L) + D.substring(L + T.length);
          break;

         case 0:
          if (T.length <= 2 * this.Patch_Margin && E && _.length != k + 1) {
            w.diffs[E++] = _[k];
            w.length1 += T.length;
            w.length2 += T.length;
          } else if (T.length >= 2 * this.Patch_Margin) if (E) {
            this.patch_addContext_(w, O);
            b.push(w);
            w = new diff_match_patch2.patch_obj;
            E = 0;
            O = D;
            S = L;
          }
          break;
        }
        if (1 !== C) S += T.length;
        if (C !== o) L += T.length;
      }
      if (E) {
        this.patch_addContext_(w, O);
        b.push(w);
      }
      return b;
    };
    diff_match_patch2.prototype.patch_deepCopy = function(s) {
      for (var r = [], o = 0; o < s.length; o++) {
        var u = s[o], g = new diff_match_patch2.patch_obj;
        g.diffs = [];
        for (var _ = 0; _ < u.diffs.length; _++) g.diffs[_] = new diff_match_patch2.Diff(u.diffs[_][0], u.diffs[_][1]);
        g.start1 = u.start1;
        g.start2 = u.start2;
        g.length1 = u.length1;
        g.length2 = u.length2;
        r[o] = g;
      }
      return r;
    };
    diff_match_patch2.prototype.patch_apply = function(s, r) {
      if (0 == s.length) return [ r, [] ];
      s = this.patch_deepCopy(s);
      var u = this.patch_addPadding(s);
      r = u + r + u;
      this.patch_splitMax(s);
      for (var g = 0, _ = [], b = 0; b < s.length; b++) {
        var w = s[b].start2 + g, E = this.diff_text1(s[b].diffs), S, L = -1;
        if (E.length > this.Match_MaxBits) {
          if (-1 != (S = this.match_main(r, E.substring(0, this.Match_MaxBits), w))) if (-1 == (L = this.match_main(r, E.substring(E.length - this.Match_MaxBits), w + E.length - this.Match_MaxBits)) || S >= L) S = -1;
        } else S = this.match_main(r, E, w);
        if (-1 == S) {
          _[b] = false;
          g -= s[b].length2 - s[b].length1;
        } else {
          _[b] = true;
          g = S - w;
          var O;
          if (-1 == L) O = r.substring(S, S + E.length); else O = r.substring(S, L + this.Match_MaxBits);
          if (E == O) r = r.substring(0, S) + this.diff_text2(s[b].diffs) + r.substring(S + E.length); else {
            var D = this.diff_main(E, O, false);
            if (E.length > this.Match_MaxBits && this.diff_levenshtein(D) / E.length > this.Patch_DeleteThreshold) _[b] = false; else {
              this.diff_cleanupSemanticLossless(D);
              for (var k = 0, C, T = 0; T < s[b].diffs.length; T++) {
                var I = s[b].diffs[T];
                if (0 !== I[0]) C = this.diff_xIndex(D, k);
                if (1 === I[0]) r = r.substring(0, S + C) + I[1] + r.substring(S + C); else if (I[0] === o) r = r.substring(0, S + C) + r.substring(S + this.diff_xIndex(D, k + I[1].length));
                if (I[0] !== o) k += I[1].length;
              }
            }
          }
        }
      }
      return [ r = r.substring(u.length, r.length - u.length), _ ];
    };
    diff_match_patch2.prototype.patch_addPadding = function(s) {
      for (var r = this.Patch_Margin, o = "", u = 1; u <= r; u++) o += String.fromCharCode(u);
      for (var u = 0; u < s.length; u++) {
        s[u].start1 += r;
        s[u].start2 += r;
      }
      var g = s[0], _ = g.diffs;
      if (0 == _.length || 0 != _[0][0]) {
        _.unshift(new diff_match_patch2.Diff(0, o));
        g.start1 -= r;
        g.start2 -= r;
        g.length1 += r;
        g.length2 += r;
      } else if (r > _[0][1].length) {
        var b = r - _[0][1].length;
        _[0][1] = o.substring(_[0][1].length) + _[0][1];
        g.start1 -= b;
        g.start2 -= b;
        g.length1 += b;
        g.length2 += b;
      }
      if (0 == (_ = (g = s[s.length - 1]).diffs).length || 0 != _[_.length - 1][0]) {
        _.push(new diff_match_patch2.Diff(0, o));
        g.length1 += r;
        g.length2 += r;
      } else if (r > _[_.length - 1][1].length) {
        var b = r - _[_.length - 1][1].length;
        _[_.length - 1][1] += o.substring(0, b);
        g.length1 += b;
        g.length2 += b;
      }
      return o;
    };
    diff_match_patch2.prototype.patch_splitMax = function(s) {
      for (var r = this.Match_MaxBits, u = 0; u < s.length; u++) {
        if (s[u].length1 <= r) continue;
        var g = s[u];
        s.splice(u--, 1);
        for (var _ = g.start1, b = g.start2, w = ""; 0 !== g.diffs.length; ) {
          var E = new diff_match_patch2.patch_obj, S = true;
          E.start1 = _ - w.length;
          E.start2 = b - w.length;
          if ("" !== w) {
            E.length1 = E.length2 = w.length;
            E.diffs.push(new diff_match_patch2.Diff(0, w));
          }
          for (;0 !== g.diffs.length && E.length1 < r - this.Patch_Margin; ) {
            var L = g.diffs[0][0], O = g.diffs[0][1];
            if (1 === L) {
              E.length2 += O.length;
              b += O.length;
              E.diffs.push(g.diffs.shift());
              S = false;
            } else if (L === o && 1 == E.diffs.length && 0 == E.diffs[0][0] && O.length > 2 * r) {
              E.length1 += O.length;
              _ += O.length;
              S = false;
              E.diffs.push(new diff_match_patch2.Diff(L, O));
              g.diffs.shift();
            } else {
              O = O.substring(0, r - E.length1 - this.Patch_Margin);
              E.length1 += O.length;
              _ += O.length;
              if (0 === L) {
                E.length2 += O.length;
                b += O.length;
              } else S = false;
              E.diffs.push(new diff_match_patch2.Diff(L, O));
              if (O == g.diffs[0][1]) g.diffs.shift(); else g.diffs[0][1] = g.diffs[0][1].substring(O.length);
            }
          }
          w = (w = this.diff_text2(E.diffs)).substring(w.length - this.Patch_Margin);
          var D = this.diff_text1(g.diffs).substring(0, this.Patch_Margin);
          if ("" !== D) {
            E.length1 += D.length;
            E.length2 += D.length;
            if (0 !== E.diffs.length && 0 === E.diffs[E.diffs.length - 1][0]) E.diffs[E.diffs.length - 1][1] += D; else E.diffs.push(new diff_match_patch2.Diff(0, D));
          }
          if (!S) s.splice(++u, 0, E);
        }
      }
    };
    diff_match_patch2.prototype.patch_toText = function(s) {
      for (var r = [], o = 0; o < s.length; o++) r[o] = s[o];
      return r.join("");
    };
    diff_match_patch2.prototype.patch_fromText = function(s) {
      var r = [];
      if (!s) return r;
      for (var u = s.split("\n"), g = 0, _ = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; g < u.length; ) {
        var b = u[g].match(_);
        if (!b) throw new Error("Invalid patch string: " + u[g]);
        var w = new diff_match_patch2.patch_obj;
        r.push(w);
        w.start1 = parseInt(b[1], 10);
        if ("" === b[2]) {
          w.start1--;
          w.length1 = 1;
        } else if ("0" == b[2]) w.length1 = 0; else {
          w.start1--;
          w.length1 = parseInt(b[2], 10);
        }
        w.start2 = parseInt(b[3], 10);
        if ("" === b[4]) {
          w.start2--;
          w.length2 = 1;
        } else if ("0" == b[4]) w.length2 = 0; else {
          w.start2--;
          w.length2 = parseInt(b[4], 10);
        }
        g++;
        for (;g < u.length; ) {
          var E = u[g].charAt(0);
          try {
            var S = decodeURI(u[g].substring(1));
          } catch (s) {
            throw new Error("Illegal escape in patch_fromText: " + S);
          }
          if ("-" == E) w.diffs.push(new diff_match_patch2.Diff(o, S)); else if ("+" == E) w.diffs.push(new diff_match_patch2.Diff(1, S)); else if (" " == E) w.diffs.push(new diff_match_patch2.Diff(0, S)); else if ("@" == E) break; else if ("" === E) ; else throw new Error('Invalid patch mode "' + E + '" in: ' + S);
          g++;
        }
      }
      return r;
    };
    diff_match_patch2.patch_obj = function() {
      this.diffs = [];
      this.start1 = null;
      this.start2 = null;
      this.length1 = 0;
      this.length2 = 0;
    };
    diff_match_patch2.patch_obj.prototype.toString = function() {
      var s, r;
      if (0 === this.length1) s = this.start1 + ",0"; else if (1 == this.length1) s = this.start1 + 1; else s = this.start1 + 1 + "," + this.length1;
      if (0 === this.length2) r = this.start2 + ",0"; else if (1 == this.length2) r = this.start2 + 1; else r = this.start2 + 1 + "," + this.length2;
      for (var u = [ "@@ -" + s + " +" + r + " @@\n" ], g, _ = 0; _ < this.diffs.length; _++) {
        switch (this.diffs[_][0]) {
         case 1:
          g = "+";
          break;

         case o:
          g = "-";
          break;

         case 0:
          g = " ";
          break;
        }
        u[_ + 1] = g + encodeURI(this.diffs[_][1]) + "\n";
      }
      return u.join("").replace(/%20/g, " ");
    };
    r.exports = diff_match_patch2;
    r.exports["diff_match_patch"] = diff_match_patch2;
    r.exports["DIFF_DELETE"] = o;
    r.exports["DIFF_INSERT"] = 1;
    r.exports["DIFF_EQUAL"] = 0;
  }
}), require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(s, r) {
    "use strict";
    r.exports = balanced;
    function balanced(s, r, o) {
      if (s instanceof RegExp) s = maybeMatch(s, o);
      if (r instanceof RegExp) r = maybeMatch(r, o);
      var u = range(s, r, o);
      return u && {
        start: u[0],
        end: u[1],
        pre: o.slice(0, u[0]),
        body: o.slice(u[0] + s.length, u[1]),
        post: o.slice(u[1] + r.length)
      };
    }
    function maybeMatch(s, r) {
      var o = r.match(s);
      return o ? o[0] : null;
    }
    balanced.range = range;
    function range(s, r, o) {
      var u, g, _, b, w, E = o.indexOf(s), S = o.indexOf(r, E + 1), L = E;
      if (E >= 0 && S > 0) {
        if (s === r) return [ E, S ];
        u = [];
        _ = o.length;
        for (;L >= 0 && !w; ) {
          if (L == E) {
            u.push(L);
            E = o.indexOf(s, L + 1);
          } else if (1 == u.length) w = [ u.pop(), S ]; else {
            if ((g = u.pop()) < _) {
              _ = g;
              b = S;
            }
            S = o.indexOf(r, L + 1);
          }
          L = E < S && E >= 0 ? E : S;
        }
        if (u.length) w = [ _, b ];
      }
      return w;
    }
  }
}), require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(s, r) {
    var o = require_balanced_match();
    r.exports = expandTop;
    var u = "\0SLASH" + Math.random() + "\0", g = "\0OPEN" + Math.random() + "\0", _ = "\0CLOSE" + Math.random() + "\0", b = "\0COMMA" + Math.random() + "\0", w = "\0PERIOD" + Math.random() + "\0";
    function numeric(s) {
      return parseInt(s, 10) == s ? parseInt(s, 10) : s.charCodeAt(0);
    }
    function escapeBraces(s) {
      return s.split("\\\\").join(u).split("\\{").join(g).split("\\}").join(_).split("\\,").join(b).split("\\.").join(w);
    }
    function unescapeBraces(s) {
      return s.split(u).join("\\").split(g).join("{").split(_).join("}").split(b).join(",").split(w).join(".");
    }
    function parseCommaParts(s) {
      if (!s) return [ "" ];
      var r = [], u = o("{", "}", s);
      if (!u) return s.split(",");
      var g = u.pre, _ = u.body, b = u.post, w = g.split(",");
      w[w.length - 1] += "{" + _ + "}";
      var E = parseCommaParts(b);
      if (b.length) {
        w[w.length - 1] += E.shift();
        w.push.apply(w, E);
      }
      r.push.apply(r, w);
      return r;
    }
    function expandTop(s) {
      if (!s) return [];
      if ("{}" === s.substr(0, 2)) s = "\\{\\}" + s.substr(2);
      return expand2(escapeBraces(s), true).map(unescapeBraces);
    }
    function embrace(s) {
      return "{" + s + "}";
    }
    function isPadded(s) {
      return /^-?0\d/.test(s);
    }
    function lte(s, r) {
      return s <= r;
    }
    function gte(s, r) {
      return s >= r;
    }
    function expand2(s, r) {
      var u = [], g = o("{", "}", s);
      if (!g) return [ s ];
      var b = g.pre, w = g.post.length ? expand2(g.post, false) : [ "" ];
      if (/\$$/.test(g.pre)) for (var E = 0; E < w.length; E++) {
        var S = b + "{" + g.body + "}" + w[E];
        u.push(S);
      } else {
        var L = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(g.body), O = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(g.body), D = L || O, k = g.body.indexOf(",") >= 0, C, T;
        if (!D && !k) {
          if (g.post.match(/,.*\}/)) return expand2(s = g.pre + "{" + g.body + _ + g.post);
          return [ s ];
        }
        if (D) C = g.body.split(/\.\./); else if (1 === (C = parseCommaParts(g.body)).length) if (1 === (C = expand2(C[0], false).map(embrace)).length) return w.map((function(s) {
          return g.pre + C[0] + s;
        }));
        if (D) {
          var I = numeric(C[0]), A = numeric(C[1]), x = Math.max(C[0].length, C[1].length), R = 3 == C.length ? Math.abs(numeric(C[2])) : 1, P = lte, N;
          if (A < I) {
            R *= -1;
            P = gte;
          }
          var B = C.some(isPadded);
          T = [];
          for (var F = I; P(F, A); F += R) {
            var M;
            if (O) {
              if ("\\" === (M = String.fromCharCode(F))) M = "";
            } else {
              M = String(F);
              if (B) {
                var V = x - M.length;
                if (V > 0) {
                  var G = new Array(V + 1).join("0");
                  if (F < 0) M = "-" + G + M.slice(1); else M = G + M;
                }
              }
            }
            T.push(M);
          }
        } else {
          T = [];
          for (var j = 0; j < C.length; j++) T.push.apply(T, expand2(C[j], false));
        }
        for (var j = 0; j < T.length; j++) for (var E = 0; E < w.length; E++) {
          var S = b + T[j] + w[E];
          if (!r || D || S) u.push(S);
        }
      }
      return u;
    }
  }
}), require_nextTick = __commonJS({
  "(disabled):node_modules/immediate/lib/nextTick"() {}
}), require_queueMicrotask = __commonJS({
  "node_modules/immediate/lib/queueMicrotask.js"(s) {
    "use strict";
    s.test = function() {
      return "function" == typeof window.queueMicrotask;
    };
    s.install = function(s) {
      return function() {
        window.queueMicrotask(s);
      };
    };
  }
}), require_mutation = __commonJS({
  "node_modules/immediate/lib/mutation.js"(s) {
    "use strict";
    var r = window.MutationObserver || window.WebKitMutationObserver;
    s.test = function() {
      return r;
    };
    s.install = function(s) {
      var o = 0, u = new r(s), g = window.document.createTextNode("");
      u.observe(g, {
        characterData: true
      });
      return function() {
        g.data = o = ++o % 2;
      };
    };
  }
}), require_messageChannel = __commonJS({
  "node_modules/immediate/lib/messageChannel.js"(s) {
    "use strict";
    s.test = function() {
      if (window.setImmediate) return false;
      return "undefined" != typeof window.MessageChannel;
    };
    s.install = function(s) {
      var r = new window.MessageChannel;
      r.port1.onmessage = s;
      return function() {
        r.port2.postMessage(0);
      };
    };
  }
}), require_stateChange = __commonJS({
  "node_modules/immediate/lib/stateChange.js"(s) {
    "use strict";
    s.test = function() {
      return "document" in window && "onreadystatechange" in window.document.createElement("script");
    };
    s.install = function(s) {
      return function() {
        var r = window.document.createElement("script");
        r.onreadystatechange = function() {
          s();
          r.onreadystatechange = null;
          r.parentNode.removeChild(r);
          r = null;
        };
        window.document.documentElement.appendChild(r);
        return s;
      };
    };
  }
}), require_timeout = __commonJS({
  "node_modules/immediate/lib/timeout.js"(s) {
    "use strict";
    s.test = function() {
      return true;
    };
    s.install = function(s) {
      return function() {
        setTimeout(s, 0);
      };
    };
  }
}), require_lib = __commonJS({
  "node_modules/immediate/lib/index.js"(s, r) {
    "use strict";
    var o = [ require_nextTick(), require_queueMicrotask(), require_mutation(), require_messageChannel(), require_stateChange(), require_timeout() ], u, g, _ = -1, b = [], w = false, E;
    function cleanUpNextTick() {
      if (!u || !g) return;
      u = false;
      if (g.length) b = g.concat(b); else _ = -1;
      if (b.length) nextTick();
    }
    function nextTick() {
      if (u) return;
      w = false;
      u = true;
      for (var s = b.length, r = setTimeout(cleanUpNextTick); s; ) {
        g = b;
        b = [];
        for (;g && ++_ < s; ) g[_].run();
        _ = -1;
        s = b.length;
      }
      g = null;
      _ = -1;
      u = false;
      clearTimeout(r);
    }
    for (var S = -1, L = o.length; ++S < L; ) if (o[S] && o[S].test && o[S].test()) {
      E = o[S].install(nextTick);
      break;
    }
    function Item(s, r) {
      this.fun = s;
      this.array = r;
    }
    Item.prototype.run = function() {
      var s = this.fun, r = this.array;
      switch (r.length) {
       case 0:
        return s();

       case 1:
        return s(r[0]);

       case 2:
        return s(r[0], r[1]);

       case 3:
        return s(r[0], r[1], r[2]);

       default:
        return s.apply(null, r);
      }
    };
    r.exports = immediate2;
    function immediate2(s) {
      var r = new Array(arguments.length - 1);
      if (arguments.length > 1) for (var o = 1; o < arguments.length; o++) r[o - 1] = arguments[o];
      b.push(new Item(s, r));
      if (!w && !u) {
        w = true;
        E();
      }
    }
  }
}), require_events = __commonJS({
  "node_modules/events/events.js"(s, r) {
    "use strict";
    var o = "object" == typeof Reflect ? Reflect : null, u = o && "function" == typeof o.apply ? o.apply : function ReflectApply2(s, r, o) {
      return Function.prototype.apply.call(s, r, o);
    }, g;
    if (o && "function" == typeof o.ownKeys) g = o.ownKeys; else if (Object.getOwnPropertySymbols) g = function ReflectOwnKeys2(s) {
      return Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s));
    }; else g = function ReflectOwnKeys2(s) {
      return Object.getOwnPropertyNames(s);
    };
    function ProcessEmitWarning(s) {
      if (console && console.warn) console.warn(s);
    }
    var _ = Number.isNaN || function NumberIsNaN2(s) {
      return s != s;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    r.exports = EventEmitter2;
    r.exports.once = once2;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var b = 10;
    function checkListener(s) {
      if ("function" != typeof s) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return b;
      },
      set: function(s) {
        if ("number" != typeof s || s < 0 || _(s)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
        b = s;
      }
    });
    EventEmitter2.init = function() {
      if (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(s) {
      if ("number" != typeof s || s < 0 || _(s)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + s + ".");
      this._maxListeners = s;
      return this;
    };
    function _getMaxListeners(s) {
      if (void 0 === s._maxListeners) return EventEmitter2.defaultMaxListeners;
      return s._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit2(s) {
      for (var r = [], o = 1; o < arguments.length; o++) r.push(arguments[o]);
      var g = "error" === s, _ = this._events;
      if (void 0 !== _) g = g && void 0 === _.error; else if (!g) return false;
      if (g) {
        var b;
        if (r.length > 0) b = r[0];
        if (b instanceof Error) throw b;
        var w = new Error("Unhandled error." + (b ? " (" + b.message + ")" : ""));
        w.context = b;
        throw w;
      }
      var E = _[s];
      if (void 0 === E) return false;
      if ("function" == typeof E) u(E, this, r); else for (var S = E.length, L = arrayClone(E, S), o = 0; o < S; ++o) u(L[o], this, r);
      return true;
    };
    function _addListener(s, r, o, u) {
      var g, _, b;
      checkListener(o);
      if (void 0 === (_ = s._events)) {
        _ = s._events = Object.create(null);
        s._eventsCount = 0;
      } else {
        if (void 0 !== _.newListener) {
          s.emit("newListener", r, o.listener ? o.listener : o);
          _ = s._events;
        }
        b = _[r];
      }
      if (void 0 === b) {
        b = _[r] = o;
        ++s._eventsCount;
      } else {
        if ("function" == typeof b) b = _[r] = u ? [ o, b ] : [ b, o ]; else if (u) b.unshift(o); else b.push(o);
        if ((g = _getMaxListeners(s)) > 0 && b.length > g && !b.warned) {
          b.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + b.length + " " + String(r) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = s;
          w.type = r;
          w.count = b.length;
          ProcessEmitWarning(w);
        }
      }
      return s;
    }
    EventEmitter2.prototype.addListener = function addListener(s, r) {
      return _addListener(this, s, r, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(s, r) {
      return _addListener(this, s, r, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (0 === arguments.length) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(s, r, o) {
      var u = {
        fired: false,
        wrapFn: void 0,
        target: s,
        type: r,
        listener: o
      }, g = onceWrapper.bind(u);
      g.listener = o;
      u.wrapFn = g;
      return g;
    }
    EventEmitter2.prototype.once = function once3(s, r) {
      checkListener(r);
      this.on(s, _onceWrap(this, s, r));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(s, r) {
      checkListener(r);
      this.prependListener(s, _onceWrap(this, s, r));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(s, r) {
      var o, u, g, _, b;
      checkListener(r);
      if (void 0 === (u = this._events)) return this;
      if (void 0 === (o = u[s])) return this;
      if (o === r || o.listener === r) if (0 == --this._eventsCount) this._events = Object.create(null); else {
        delete u[s];
        if (u.removeListener) this.emit("removeListener", s, o.listener || r);
      } else if ("function" != typeof o) {
        g = -1;
        for (_ = o.length - 1; _ >= 0; _--) if (o[_] === r || o[_].listener === r) {
          b = o[_].listener;
          g = _;
          break;
        }
        if (g < 0) return this;
        if (0 === g) o.shift(); else spliceOne(o, g);
        if (1 === o.length) u[s] = o[0];
        if (void 0 !== u.removeListener) this.emit("removeListener", s, b || r);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(s) {
      var r, o, u;
      if (void 0 === (o = this._events)) return this;
      if (void 0 === o.removeListener) {
        if (0 === arguments.length) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (void 0 !== o[s]) if (0 == --this._eventsCount) this._events = Object.create(null); else delete o[s];
        return this;
      }
      if (0 === arguments.length) {
        var g = Object.keys(o), _;
        for (u = 0; u < g.length; ++u) {
          if ("removeListener" === (_ = g[u])) continue;
          this.removeAllListeners(_);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      if ("function" == typeof (r = o[s])) this.removeListener(s, r); else if (void 0 !== r) for (u = r.length - 1; u >= 0; u--) this.removeListener(s, r[u]);
      return this;
    };
    function _listeners(s, r, o) {
      var u = s._events;
      if (void 0 === u) return [];
      var g = u[r];
      if (void 0 === g) return [];
      if ("function" == typeof g) return o ? [ g.listener || g ] : [ g ];
      return o ? unwrapListeners(g) : arrayClone(g, g.length);
    }
    EventEmitter2.prototype.listeners = function listeners(s) {
      return _listeners(this, s, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(s) {
      return _listeners(this, s, false);
    };
    EventEmitter2.listenerCount = function(s, r) {
      if ("function" == typeof s.listenerCount) return s.listenerCount(r); else return listenerCount2.call(s, r);
    };
    EventEmitter2.prototype.listenerCount = listenerCount2;
    function listenerCount2(s) {
      var r = this._events;
      if (void 0 !== r) {
        var o = r[s];
        if ("function" == typeof o) return 1; else if (void 0 !== o) return o.length;
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? g(this._events) : [];
    };
    function arrayClone(s, r) {
      for (var o = new Array(r), u = 0; u < r; ++u) o[u] = s[u];
      return o;
    }
    function spliceOne(s, r) {
      for (;r + 1 < s.length; r++) s[r] = s[r + 1];
      s.pop();
    }
    function unwrapListeners(s) {
      for (var r = new Array(s.length), o = 0; o < r.length; ++o) r[o] = s[o].listener || s[o];
      return r;
    }
    function once2(s, r) {
      return new Promise((function(o, u) {
        function errorListener(o) {
          s.removeListener(r, resolver);
          u(o);
        }
        function resolver() {
          if ("function" == typeof s.removeListener) s.removeListener("error", errorListener);
          o([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(s, r, resolver, {
          once: true
        });
        if ("error" !== r) addErrorHandlerIfEventEmitter(s, errorListener, {
          once: true
        });
      }));
    }
    function addErrorHandlerIfEventEmitter(s, r, o) {
      if ("function" == typeof s.on) eventTargetAgnosticAddListener(s, "error", r, o);
    }
    function eventTargetAgnosticAddListener(s, r, o, u) {
      if ("function" == typeof s.on) if (u.once) s.once(r, o); else s.on(r, o); else if ("function" == typeof s.addEventListener) s.addEventListener(r, (function wrapListener(g) {
        if (u.once) s.removeEventListener(r, wrapListener);
        o(g);
      })); else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
    }
  }
}), require_spark_md5 = __commonJS({
  "node_modules/spark-md5/spark-md5.js"(s, r) {
    (function(o) {
      if ("object" == typeof s) r.exports = o(); else if ("function" == typeof define && define.amd) define(o); else {
        var u;
        try {
          u = window;
        } catch (s) {
          u = self;
        }
        u.SparkMD5 = o();
      }
    })((function(s) {
      "use strict";
      var add32 = function(s, r) {
        return s + r & 4294967295;
      }, r = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" ];
      function cmn(s, r, o, u, g, _) {
        r = add32(add32(r, s), add32(u, _));
        return add32(r << g | r >>> 32 - g, o);
      }
      function md5cycle(s, r) {
        var o = s[0], u = s[1], g = s[2], _ = s[3];
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u & g | ~u & _) + r[0] - 680876936 | 0) << 7 | o >>> 25) + u | 0) & u | ~o & g) + r[1] - 389564586 | 0) << 12 | _ >>> 20) + o | 0) & o | ~_ & u) + r[2] + 606105819 | 0) << 17 | g >>> 15) + _ | 0) & _ | ~g & o) + r[3] - 1044525330 | 0) << 22 | u >>> 10) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u & g | ~u & _) + r[4] - 176418897 | 0) << 7 | o >>> 25) + u | 0) & u | ~o & g) + r[5] + 1200080426 | 0) << 12 | _ >>> 20) + o | 0) & o | ~_ & u) + r[6] - 1473231341 | 0) << 17 | g >>> 15) + _ | 0) & _ | ~g & o) + r[7] - 45705983 | 0) << 22 | u >>> 10) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u & g | ~u & _) + r[8] + 1770035416 | 0) << 7 | o >>> 25) + u | 0) & u | ~o & g) + r[9] - 1958414417 | 0) << 12 | _ >>> 20) + o | 0) & o | ~_ & u) + r[10] - 42063 | 0) << 17 | g >>> 15) + _ | 0) & _ | ~g & o) + r[11] - 1990404162 | 0) << 22 | u >>> 10) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u & g | ~u & _) + r[12] + 1804603682 | 0) << 7 | o >>> 25) + u | 0) & u | ~o & g) + r[13] - 40341101 | 0) << 12 | _ >>> 20) + o | 0) & o | ~_ & u) + r[14] - 1502002290 | 0) << 17 | g >>> 15) + _ | 0) & _ | ~g & o) + r[15] + 1236535329 | 0) << 22 | u >>> 10) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u & _ | g & ~_) + r[1] - 165796510 | 0) << 5 | o >>> 27) + u | 0) & g | u & ~g) + r[6] - 1069501632 | 0) << 9 | _ >>> 23) + o | 0) & u | o & ~u) + r[11] + 643717713 | 0) << 14 | g >>> 18) + _ | 0) & o | _ & ~o) + r[0] - 373897302 | 0) << 20 | u >>> 12) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u & _ | g & ~_) + r[5] - 701558691 | 0) << 5 | o >>> 27) + u | 0) & g | u & ~g) + r[10] + 38016083 | 0) << 9 | _ >>> 23) + o | 0) & u | o & ~u) + r[15] - 660478335 | 0) << 14 | g >>> 18) + _ | 0) & o | _ & ~o) + r[4] - 405537848 | 0) << 20 | u >>> 12) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u & _ | g & ~_) + r[9] + 568446438 | 0) << 5 | o >>> 27) + u | 0) & g | u & ~g) + r[14] - 1019803690 | 0) << 9 | _ >>> 23) + o | 0) & u | o & ~u) + r[3] - 187363961 | 0) << 14 | g >>> 18) + _ | 0) & o | _ & ~o) + r[8] + 1163531501 | 0) << 20 | u >>> 12) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u & _ | g & ~_) + r[13] - 1444681467 | 0) << 5 | o >>> 27) + u | 0) & g | u & ~g) + r[2] - 51403784 | 0) << 9 | _ >>> 23) + o | 0) & u | o & ~u) + r[7] + 1735328473 | 0) << 14 | g >>> 18) + _ | 0) & o | _ & ~o) + r[12] - 1926607734 | 0) << 20 | u >>> 12) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u ^ g ^ _) + r[5] - 378558 | 0) << 4 | o >>> 28) + u | 0) ^ u ^ g) + r[8] - 2022574463 | 0) << 11 | _ >>> 21) + o | 0) ^ o ^ u) + r[11] + 1839030562 | 0) << 16 | g >>> 16) + _ | 0) ^ _ ^ o) + r[14] - 35309556 | 0) << 23 | u >>> 9) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u ^ g ^ _) + r[1] - 1530992060 | 0) << 4 | o >>> 28) + u | 0) ^ u ^ g) + r[4] + 1272893353 | 0) << 11 | _ >>> 21) + o | 0) ^ o ^ u) + r[7] - 155497632 | 0) << 16 | g >>> 16) + _ | 0) ^ _ ^ o) + r[10] - 1094730640 | 0) << 23 | u >>> 9) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u ^ g ^ _) + r[13] + 681279174 | 0) << 4 | o >>> 28) + u | 0) ^ u ^ g) + r[0] - 358537222 | 0) << 11 | _ >>> 21) + o | 0) ^ o ^ u) + r[3] - 722521979 | 0) << 16 | g >>> 16) + _ | 0) ^ _ ^ o) + r[6] + 76029189 | 0) << 23 | u >>> 9) + g | 0;
        u = ((u += ((g = ((g += ((_ = ((_ += ((o = ((o += (u ^ g ^ _) + r[9] - 640364487 | 0) << 4 | o >>> 28) + u | 0) ^ u ^ g) + r[12] - 421815835 | 0) << 11 | _ >>> 21) + o | 0) ^ o ^ u) + r[15] + 530742520 | 0) << 16 | g >>> 16) + _ | 0) ^ _ ^ o) + r[2] - 995338651 | 0) << 23 | u >>> 9) + g | 0;
        u = ((u += ((_ = ((_ += (u ^ ((o = ((o += (g ^ (u | ~_)) + r[0] - 198630844 | 0) << 6 | o >>> 26) + u | 0) | ~g)) + r[7] + 1126891415 | 0) << 10 | _ >>> 22) + o | 0) ^ ((g = ((g += (o ^ (_ | ~u)) + r[14] - 1416354905 | 0) << 15 | g >>> 17) + _ | 0) | ~o)) + r[5] - 57434055 | 0) << 21 | u >>> 11) + g | 0;
        u = ((u += ((_ = ((_ += (u ^ ((o = ((o += (g ^ (u | ~_)) + r[12] + 1700485571 | 0) << 6 | o >>> 26) + u | 0) | ~g)) + r[3] - 1894986606 | 0) << 10 | _ >>> 22) + o | 0) ^ ((g = ((g += (o ^ (_ | ~u)) + r[10] - 1051523 | 0) << 15 | g >>> 17) + _ | 0) | ~o)) + r[1] - 2054922799 | 0) << 21 | u >>> 11) + g | 0;
        u = ((u += ((_ = ((_ += (u ^ ((o = ((o += (g ^ (u | ~_)) + r[8] + 1873313359 | 0) << 6 | o >>> 26) + u | 0) | ~g)) + r[15] - 30611744 | 0) << 10 | _ >>> 22) + o | 0) ^ ((g = ((g += (o ^ (_ | ~u)) + r[6] - 1560198380 | 0) << 15 | g >>> 17) + _ | 0) | ~o)) + r[13] + 1309151649 | 0) << 21 | u >>> 11) + g | 0;
        u = ((u += ((_ = ((_ += (u ^ ((o = ((o += (g ^ (u | ~_)) + r[4] - 145523070 | 0) << 6 | o >>> 26) + u | 0) | ~g)) + r[11] - 1120210379 | 0) << 10 | _ >>> 22) + o | 0) ^ ((g = ((g += (o ^ (_ | ~u)) + r[2] + 718787259 | 0) << 15 | g >>> 17) + _ | 0) | ~o)) + r[9] - 343485551 | 0) << 21 | u >>> 11) + g | 0;
        s[0] = o + s[0] | 0;
        s[1] = u + s[1] | 0;
        s[2] = g + s[2] | 0;
        s[3] = _ + s[3] | 0;
      }
      function md5blk(s) {
        var r = [], o;
        for (o = 0; o < 64; o += 4) r[o >> 2] = s.charCodeAt(o) + (s.charCodeAt(o + 1) << 8) + (s.charCodeAt(o + 2) << 16) + (s.charCodeAt(o + 3) << 24);
        return r;
      }
      function md5blk_array(s) {
        var r = [], o;
        for (o = 0; o < 64; o += 4) r[o >> 2] = s[o] + (s[o + 1] << 8) + (s[o + 2] << 16) + (s[o + 3] << 24);
        return r;
      }
      function md51(s) {
        var r = s.length, o = [ 1732584193, -271733879, -1732584194, 271733878 ], u, g, _, b, w, E;
        for (u = 64; u <= r; u += 64) md5cycle(o, md5blk(s.substring(u - 64, u)));
        g = (s = s.substring(u - 64)).length;
        _ = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
        for (u = 0; u < g; u += 1) _[u >> 2] |= s.charCodeAt(u) << (u % 4 << 3);
        _[u >> 2] |= 128 << (u % 4 << 3);
        if (u > 55) {
          md5cycle(o, _);
          for (u = 0; u < 16; u += 1) _[u] = 0;
        }
        b = (b = 8 * r).toString(16).match(/(.*?)(.{0,8})$/);
        w = parseInt(b[2], 16);
        E = parseInt(b[1], 16) || 0;
        _[14] = w;
        _[15] = E;
        md5cycle(o, _);
        return o;
      }
      function md51_array(s) {
        var r = s.length, o = [ 1732584193, -271733879, -1732584194, 271733878 ], u, g, _, b, w, E;
        for (u = 64; u <= r; u += 64) md5cycle(o, md5blk_array(s.subarray(u - 64, u)));
        g = (s = u - 64 < r ? s.subarray(u - 64) : new Uint8Array(0)).length;
        _ = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
        for (u = 0; u < g; u += 1) _[u >> 2] |= s[u] << (u % 4 << 3);
        _[u >> 2] |= 128 << (u % 4 << 3);
        if (u > 55) {
          md5cycle(o, _);
          for (u = 0; u < 16; u += 1) _[u] = 0;
        }
        b = (b = 8 * r).toString(16).match(/(.*?)(.{0,8})$/);
        w = parseInt(b[2], 16);
        E = parseInt(b[1], 16) || 0;
        _[14] = w;
        _[15] = E;
        md5cycle(o, _);
        return o;
      }
      function rhex(s) {
        var o = "", u;
        for (u = 0; u < 4; u += 1) o += r[s >> 8 * u + 4 & 15] + r[s >> 8 * u & 15];
        return o;
      }
      function hex(s) {
        var r;
        for (r = 0; r < s.length; r += 1) s[r] = rhex(s[r]);
        return s.join("");
      }
      if ("5d41402abc4b2a76b9719d911017c592" !== hex(md51("hello"))) add32 = function(s, r) {
        var o = (65535 & s) + (65535 & r), u;
        return (s >> 16) + (r >> 16) + (o >> 16) << 16 | 65535 & o;
      };
      if ("undefined" != typeof ArrayBuffer && !ArrayBuffer.prototype.slice) (function() {
        function clamp(s, r) {
          if ((s = 0 | s || 0) < 0) return Math.max(s + r, 0);
          return Math.min(s, r);
        }
        ArrayBuffer.prototype.slice = function(r, o) {
          var u = this.byteLength, g = clamp(r, u), _ = u, b, w, E, S;
          if (o !== s) _ = clamp(o, u);
          if (g > _) return new ArrayBuffer(0);
          b = _ - g;
          w = new ArrayBuffer(b);
          E = new Uint8Array(w);
          S = new Uint8Array(this, g, b);
          E.set(S);
          return w;
        };
      })();
      function toUtf8(s) {
        if (/[\u0080-\uFFFF]/.test(s)) s = unescape(encodeURIComponent(s));
        return s;
      }
      function utf8Str2ArrayBuffer(s, r) {
        var o = s.length, u = new ArrayBuffer(o), g = new Uint8Array(u), _;
        for (_ = 0; _ < o; _ += 1) g[_] = s.charCodeAt(_);
        return r ? g : u;
      }
      function arrayBuffer2Utf8Str(s) {
        return String.fromCharCode.apply(null, new Uint8Array(s));
      }
      function concatenateArrayBuffers(s, r, o) {
        var u = new Uint8Array(s.byteLength + r.byteLength);
        u.set(new Uint8Array(s));
        u.set(new Uint8Array(r), s.byteLength);
        return o ? u : u.buffer;
      }
      function hexToBinaryString(s) {
        var r = [], o = s.length, u;
        for (u = 0; u < o - 1; u += 2) r.push(parseInt(s.substr(u, 2), 16));
        return String.fromCharCode.apply(String, r);
      }
      function SparkMD5() {
        this.reset();
      }
      SparkMD5.prototype.append = function(s) {
        this.appendBinary(toUtf8(s));
        return this;
      };
      SparkMD5.prototype.appendBinary = function(s) {
        this._buff += s;
        this._length += s.length;
        var r = this._buff.length, o;
        for (o = 64; o <= r; o += 64) md5cycle(this._hash, md5blk(this._buff.substring(o - 64, o)));
        this._buff = this._buff.substring(o - 64);
        return this;
      };
      SparkMD5.prototype.end = function(s) {
        var r = this._buff, o = r.length, u, g = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], _;
        for (u = 0; u < o; u += 1) g[u >> 2] |= r.charCodeAt(u) << (u % 4 << 3);
        this._finish(g, o);
        _ = hex(this._hash);
        if (s) _ = hexToBinaryString(_);
        this.reset();
        return _;
      };
      SparkMD5.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [ 1732584193, -271733879, -1732584194, 271733878 ];
        return this;
      };
      SparkMD5.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD5.prototype.setState = function(s) {
        this._buff = s.buff;
        this._length = s.length;
        this._hash = s.hash;
        return this;
      };
      SparkMD5.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD5.prototype._finish = function(s, r) {
        var o = r, u, g, _;
        s[o >> 2] |= 128 << (o % 4 << 3);
        if (o > 55) {
          md5cycle(this._hash, s);
          for (o = 0; o < 16; o += 1) s[o] = 0;
        }
        u = (u = 8 * this._length).toString(16).match(/(.*?)(.{0,8})$/);
        g = parseInt(u[2], 16);
        _ = parseInt(u[1], 16) || 0;
        s[14] = g;
        s[15] = _;
        md5cycle(this._hash, s);
      };
      SparkMD5.hash = function(s, r) {
        return SparkMD5.hashBinary(toUtf8(s), r);
      };
      SparkMD5.hashBinary = function(s, r) {
        var o, u = hex(md51(s));
        return r ? hexToBinaryString(u) : u;
      };
      SparkMD5.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD5.ArrayBuffer.prototype.append = function(s) {
        var r = concatenateArrayBuffers(this._buff.buffer, s, true), o = r.length, u;
        this._length += s.byteLength;
        for (u = 64; u <= o; u += 64) md5cycle(this._hash, md5blk_array(r.subarray(u - 64, u)));
        this._buff = u - 64 < o ? new Uint8Array(r.buffer.slice(u - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.end = function(s) {
        var r = this._buff, o = r.length, u = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], g, _;
        for (g = 0; g < o; g += 1) u[g >> 2] |= r[g] << (g % 4 << 3);
        this._finish(u, o);
        _ = hex(this._hash);
        if (s) _ = hexToBinaryString(_);
        this.reset();
        return _;
      };
      SparkMD5.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [ 1732584193, -271733879, -1732584194, 271733878 ];
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.getState = function() {
        var s = SparkMD5.prototype.getState.call(this);
        s.buff = arrayBuffer2Utf8Str(s.buff);
        return s;
      };
      SparkMD5.ArrayBuffer.prototype.setState = function(s) {
        s.buff = utf8Str2ArrayBuffer(s.buff, true);
        return SparkMD5.prototype.setState.call(this, s);
      };
      SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
      SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
      SparkMD5.ArrayBuffer.hash = function(s, r) {
        var o, u = hex(md51_array(new Uint8Array(s)));
        return r ? hexToBinaryString(u) : u;
      };
      return SparkMD5;
    }));
  }
}), require_vuvuzela = __commonJS({
  "node_modules/vuvuzela/index.js"(s) {
    "use strict";
    s.stringify = function stringify3(s) {
      var r = [];
      r.push({
        obj: s
      });
      for (var o = "", u, g, _, b, w, E, S, L, O, D, k; u = r.pop(); ) {
        g = u.obj;
        o += _ = u.prefix || "";
        if (b = u.val || "") o += b; else if ("object" != typeof g) o += "undefined" == typeof g ? null : JSON.stringify(g); else if (null === g) o += "null"; else if (Array.isArray(g)) {
          r.push({
            val: "]"
          });
          for (w = g.length - 1; w >= 0; w--) {
            E = 0 === w ? "" : ",";
            r.push({
              obj: g[w],
              prefix: E
            });
          }
          r.push({
            val: "["
          });
        } else {
          S = [];
          for (L in g) if (g.hasOwnProperty(L)) S.push(L);
          r.push({
            val: "}"
          });
          for (w = S.length - 1; w >= 0; w--) {
            D = g[O = S[w]];
            k = w > 0 ? "," : "";
            k += JSON.stringify(O) + ":";
            r.push({
              obj: D,
              prefix: k
            });
          }
          r.push({
            val: "{"
          });
        }
      }
      return o;
    };
    function pop2(s, r, o) {
      var u = o[o.length - 1];
      if (s === u.element) {
        o.pop();
        u = o[o.length - 1];
      }
      var g = u.element, _ = u.index;
      if (Array.isArray(g)) g.push(s); else if (_ === r.length - 2) {
        var b;
        g[r.pop()] = s;
      } else r.push(s);
    }
    s.parse = function(s) {
      for (var r = [], o = [], u = 0, g, _, b, w, E, S, L, O, D; ;) {
        if ("}" === (g = s[u++]) || "]" === g || "undefined" == typeof g) if (1 === r.length) return r.pop(); else {
          pop2(r.pop(), r, o);
          continue;
        }
        switch (g) {
         case " ":
         case "\t":
         case "\n":
         case ":":
         case ",":
          break;

         case "n":
          u += 3;
          pop2(null, r, o);
          break;

         case "t":
          u += 3;
          pop2(true, r, o);
          break;

         case "f":
          u += 4;
          pop2(false, r, o);
          break;

         case "0":
         case "1":
         case "2":
         case "3":
         case "4":
         case "5":
         case "6":
         case "7":
         case "8":
         case "9":
         case "-":
          _ = "";
          u--;
          for (;;) {
            b = s[u++];
            if (/[\d\.\-e\+]/.test(b)) _ += b; else {
              u--;
              break;
            }
          }
          pop2(parseFloat(_), r, o);
          break;

         case '"':
          w = "";
          E = void 0;
          S = 0;
          for (;'"' !== (L = s[u++]) || "\\" === E && S % 2 == 1; ) {
            w += L;
            if ("\\" === (E = L)) S++; else S = 0;
          }
          pop2(JSON.parse('"' + w + '"'), r, o);
          break;

         case "[":
          O = {
            element: [],
            index: r.length
          };
          r.push(O.element);
          o.push(O);
          break;

         case "{":
          D = {
            element: {},
            index: r.length
          };
          r.push(D.element);
          o.push(D);
          break;

         default:
          throw new Error("unexpectedly reached end of input: " + g);
        }
      }
    };
  }
}), require_pouchdb_wrappers = __commonJS({
  "node_modules/pouchdb-wrappers/index.js"(s, r) {
    "use strict";
    function nodify(s, r) {
      s.then(((...s) => {
        r(null, ...s);
      })).catch((s => {
        r(s);
      }));
    }
    function installWrappers(s, r = {}) {
      if (!s._originals || !s._handlers) {
        s._originals = {};
        s._handlers = {};
      }
      for (const [o, u] of Object.entries(r)) {
        if (!(o in s)) throw new Error(`Method '${o}' does not exist on given base, so it cannot be wrapped.`);
        if (!(o in s._originals)) s._originals[o] = s[o];
        if (o in s._handlers) s._handlers[o].unshift(u); else {
          s._handlers[o] = [ u ];
          s[o] = replacementMethod(s, o);
        }
      }
    }
    function replacementMethod(s, r) {
      return function(...o) {
        function doMethod() {
          let u = null;
          const g = "query" === r ? 1 : 0;
          if (o.length > g && "function" == typeof o[o.length - 1]) u = o.pop();
          let _ = s._originals[r].bind(s);
          for (const o of s._handlers[r]) _ = o.bind(s, _);
          const b = _(...o);
          if (b.then && u) nodify(b, u);
          return b;
        }
        if ("changes" !== r && s.taskqueue && !s.taskqueue.isReady) {
          const r = void 0;
          return new Promise(((r, o) => {
            s.taskqueue.addTask((s => {
              if (s) o(s); else r();
            }));
          })).then(doMethod);
        } else return doMethod();
      };
    }
    function uninstallWrappers(s, r) {
      if (!s._originals || !s._handlers) throw new Error("No wrapper methods installed, so no methods can be uninstalled.");
      for (const [o, u] of Object.entries(r)) {
        const r = `Wrapper method for '${o}' not installed: ${u.toString()}`;
        if (!(o in s._handlers)) throw new Error(r);
        const g = s._handlers[o].indexOf(u);
        if (-1 === g) throw new Error(r); else s._handlers[o].splice(g, 1);
      }
    }
    var o = {
      install: installWrappers,
      uninstall: uninstallWrappers
    };
    try {
      r.exports = o;
    } catch (s) {}
    try {
      window.PouchDBWrappers = o;
    } catch (s) {}
  }
}), require_transform_pouch = __commonJS({
  "node_modules/transform-pouch/index.js"(s, r) {
    "use strict";
    var o = require_pouchdb_wrappers();
    function isntInternalKey(s) {
      return "_" !== s[0];
    }
    function isUntransformable(s) {
      if ("string" == typeof s._id && /^_local/.test(s._id)) return true;
      if (s._deleted) return 0 === Object.keys(s).filter(isntInternalKey).length;
      return false;
    }
    r.exports = {
      transform: transform2,
      filter: transform2
    };
    function transform2(s) {
      const r = this, incoming = function(r) {
        if (!isUntransformable(r) && s.incoming) return s.incoming(r);
        return r;
      }, outgoing = function(r) {
        if (!isUntransformable(r) && s.outgoing) return s.outgoing(r);
        return r;
      }, u = {
        async get(s, ...r) {
          const o = await s(...r);
          if (Array.isArray(o)) {
            await Promise.all(o.map((async s => {
              if (s.ok) s.ok = await outgoing(s.ok);
            })));
            return o;
          } else return outgoing(o);
        },
        async bulkDocs(s, r, ...o) {
          if (r.docs) r.docs = await Promise.all(r.docs.map(incoming)); else r = await Promise.all(r.map(incoming));
          return s(r, ...o);
        },
        async allDocs(s, ...r) {
          const o = await s(...r);
          await Promise.all(o.rows.map((async s => {
            if (s.doc) s.doc = await outgoing(s.doc);
          })));
          return o;
        },
        async bulkGet(s, ...r) {
          const mapDoc = async s => {
            if (s.ok) return {
              ok: await outgoing(s.ok)
            }; else return s;
          }, mapResult = async s => {
            const {id: r, docs: o} = s;
            if (r && o && Array.isArray(o)) return {
              id: r,
              docs: await Promise.all(o.map(mapDoc))
            }; else return s;
          };
          let {results: o, ...u} = await s(...r);
          o = await Promise.all(o.map(mapResult));
          return {
            results: o,
            ...u
          };
        },
        changes(s, ...r) {
          async function modifyChange(s) {
            if (s.doc) {
              s.doc = await outgoing(s.doc);
              return s;
            }
            return s;
          }
          async function modifyChanges(s) {
            if (s.results) {
              s.results = await Promise.all(s.results.map(modifyChange));
              return s;
            }
            return s;
          }
          const o = s(...r), {on: u, then: g} = o;
          return Object.assign(o, {
            on(s, r) {
              const g = r;
              if ("change" === s) r = async s => {
                g(await modifyChange(s));
              }; else if ("complete" === s) r = async s => {
                g(await modifyChanges(s));
              };
              return u.call(o, s, r);
            },
            then: (s, r) => g.call(o, modifyChanges).then(s, r)
          });
        }
      };
      if ("http" === r.type()) {
        u.put = async function(s, r, ...o) {
          return s(r = await incoming(r), ...o);
        };
        u.query = async function(s, ...r) {
          const o = await s(...r);
          await Promise.all(o.rows.map((async s => {
            if (s.doc) s.doc = await outgoing(s.doc);
          })));
          return o;
        };
      }
      o.install(r, u);
    }
    if ("undefined" != typeof window && window.PouchDB) window.PouchDB.plugin(s);
  }
}), main_exports = {};

__export(main_exports, {
  default: () => ObsidianLiveSyncPlugin
});

module.exports = __toCommonJS(main_exports);

var symbolFilePath = Symbol(), symbolFilePathWithPrefix = Symbol(), symbolId = Symbol(), MAX_DOC_SIZE_BIN = 102400, VER = 10, LEAF_WAIT_TIMEOUT = 9e4, REPLICATION_BUSY_TIMEOUT = 3e6, LOG_LEVEL_DEBUG = -1, LOG_LEVEL_VERBOSE = 1, LOG_LEVEL_INFO = 10, LOG_LEVEL_NOTICE = 100, LOG_LEVEL_URGENT = 1e3, VERSIONINFO_DOCID = "obsydian_livesync_version", MILSTONE_DOCID = "_local/obsydian_livesync_milestone", NODEINFO_DOCID = "_local/obsydian_livesync_nodeinfo", DEFAULT_SETTINGS = {
  couchDB_URI: "",
  couchDB_USER: "",
  couchDB_PASSWORD: "",
  couchDB_DBNAME: "",
  liveSync: false,
  syncOnSave: false,
  syncOnStart: false,
  savingDelay: 200,
  lessInformationInLog: false,
  gcDelay: 300,
  versionUpFlash: "",
  minimumChunkSize: 20,
  longLineThreshold: 250,
  showVerboseLog: false,
  suspendFileWatching: false,
  trashInsteadDelete: true,
  periodicReplication: false,
  periodicReplicationInterval: 60,
  syncOnFileOpen: false,
  encrypt: false,
  passphrase: "",
  usePathObfuscation: false,
  doNotDeleteFolder: false,
  resolveConflictsByNewerFile: false,
  batchSave: false,
  deviceAndVaultName: "",
  usePluginSettings: false,
  showOwnPlugins: false,
  showStatusOnEditor: true,
  usePluginSync: false,
  autoSweepPlugins: false,
  autoSweepPluginsPeriodic: false,
  notifyPluginOrSettingUpdated: false,
  checkIntegrityOnSave: false,
  batch_size: 50,
  batches_limit: 40,
  useHistory: false,
  disableRequestURI: false,
  skipOlderFilesOnSync: true,
  checkConflictOnlyOnOpen: false,
  syncInternalFiles: false,
  syncInternalFilesBeforeReplication: false,
  syncInternalFilesIgnorePatterns: "\\/node_modules\\/, \\/\\.git\\/, \\/obsidian-livesync\\/",
  syncInternalFilesInterval: 60,
  additionalSuffixOfDatabaseName: "",
  ignoreVersionCheck: false,
  lastReadUpdates: 0,
  deleteMetadataOfDeletedFiles: false,
  syncIgnoreRegEx: "",
  syncOnlyRegEx: "",
  customChunkSize: 0,
  readChunksOnline: true,
  watchInternalFileChanges: true,
  automaticallyDeleteMetadataOfDeletedFiles: 0,
  disableMarkdownAutoMerge: false,
  writeDocumentsIfConflicted: false,
  useDynamicIterationCount: false,
  syncAfterMerge: false,
  configPassphraseStore: "",
  encryptedPassphrase: "",
  encryptedCouchDBConnection: "",
  permitEmptyPassphrase: false,
  useIndexedDBAdapter: true,
  useTimeouts: false,
  writeLogToTheFile: false,
  doNotPaceReplication: false,
  hashCacheMaxCount: 300,
  hashCacheMaxAmount: 50,
  concurrencyOfReadChunksOnline: 100,
  minimumIntervalOfReadChunksOnline: 333,
  hashAlg: "xxhash64",
  suspendParseReplicationResult: false,
  doNotSuspendOnFetching: false,
  useIgnoreFiles: false,
  ignoreFiles: ".gitignore"
}, PREFIXMD_LOGFILE = "LIVESYNC_LOG_", FLAGMD_REDFLAG = "redflag.md", FLAGMD_REDFLAG2 = "redflag2.md", FLAGMD_REDFLAG3 = "redflag3.md", SYNCINFO_ID = "syncinfo", SALT_OF_PASSPHRASE = "rHGMPtr6oWw7VSa3W3wpa8fT8U", PREFIX_OBFUSCATED = "f:", PREFIX_ENCRYPTED_CHUNK = "h:+", import_obsidian = require("obsidian"), import_obsidian2 = require("obsidian"), import_diff_match_patch = __toESM(require_diff_match_patch(), 1), normalizePath = import_obsidian2.normalizePath, PERIODIC_PLUGIN_SWEEP = 60, CHeader = "h:", PSCHeader = "ps:", ICHeader = "i:", ICHeaderEnd = "i;", ICHeaderLength = ICHeader.length, ICXHeader = "ix:", FileWatchEventQueueMax = 10, configURIBase = "obsidian://setuplivesync?settings=", LEVEL_INFO = LOG_LEVEL_INFO, defaultLoggerEnv = {
  minLogLevel: LOG_LEVEL_INFO
}, defaultLogger = function defaultLogger2(s, r = LEVEL_INFO, o) {
  if (r < defaultLoggerEnv.minLogLevel) return;
  const u = void 0, g = (new Date).toLocaleString(), _ = "string" == typeof s ? s : s instanceof Error ? `${s.name}:${s.message}` : JSON.stringify(s, null, 2);
  if (s instanceof Error) console.dir(s.stack);
  const b = `${g}\t${r}\t${_}`;
  console.log(b);
}, _logger = defaultLogger;

function setGlobalLogFunction(s) {
  _logger = s;
}

function Logger(s, r, o) {
  _logger(s, r, o);
}

var LRUCache = class {
  constructor(s, r, o = false) {
    this.cache = new Map([]);
    this.revCache = new Map([]);
    this.maxCache = 200;
    this.maxCachedLength = 5e7;
    this.cachedLength = 0;
    this.enableReversed = true;
    this.maxCache = s || 200;
    this.maxCachedLength = 1e6 * (r || 1);
    this.enableReversed = !o;
    Logger(`Cache initialized ${this.maxCache} / ${this.maxCachedLength}`, LOG_LEVEL_VERBOSE);
  }
  clear() {
    this.cache.clear();
    this.revCache.clear();
  }
  has(s) {
    return this.cache.has(s);
  }
  get(s) {
    const r = this.cache.get(s);
    if (r) {
      this.cache.delete(s);
      this.cache.set(s, r);
      if (this.enableReversed) {
        this.revCache.delete(r);
        this.revCache.set(r, s);
      }
    }
    return r;
  }
  revGet(s) {
    const r = this.revCache.get(s);
    if (s) {
      this.cache.delete(r);
      this.revCache.delete(s);
      this.cache.set(r, s);
      this.revCache.set(s, r);
    }
    return r;
  }
  set(s, r) {
    this.cache.set(s, r);
    if (this.enableReversed) this.revCache.set(r, s);
    this.cachedLength += `${r}`.length;
    if (this.cache.size > this.maxCache || this.cachedLength > this.maxCachedLength) for (const [s, r] of this.cache) {
      this.cache.delete(s);
      if (this.enableReversed) this.revCache.delete(r);
      this.cachedLength -= `${r}`.length;
      if (this.cache.size <= this.maxCache && this.cachedLength <= this.maxCachedLength) break;
    }
  }
};

function makeUniqueString() {
  const s = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", r = [ ...Array(30) ].map((() => Math.floor(52 * Math.random()))).map((r => s[r])).join("");
  return `${Date.now()}-${r}`;
}

function Semaphore(s, r) {
  const o = s;
  let u = 0, g = [];
  function execProcess() {
    g = g.filter((s => "DONE" != s.state));
    for (const s of g) {
      if ("NONE" != s.state) continue;
      if (s.quantity + u > o) break;
      s.state = "RUNNING";
      u += s.quantity;
      if (null == s ? void 0 : s.timer) clearTimeout(s.timer);
      s.notify(true);
    }
  }
  function release(s) {
    const o = g.find((r => r.key == s));
    if (!o) throw new Error("Missing locked semaphore!");
    if ("RUNNING" == o.state) u -= o.quantity;
    o.state = "DONE";
    if (r) r(g.filter((s => "DONE" != s.state)));
    execProcess();
  }
  return {
    _acquire(s, r, u) {
      const _ = makeUniqueString();
      if (o < s) throw Error("Too big quantity");
      let notify = s => {};
      const b = new Promise((s => {
        notify = r => {
          if (r) s((() => {
            release(_);
          })); else s(false);
        };
      })), w = {
        key: _,
        notify,
        semaphoreStopper: b,
        quantity: s,
        memo: r,
        state: "NONE"
      };
      if (u) w.timer = setTimeout((() => {
        release(_);
        notify(false);
      }), u);
      g.push(w);
      execProcess();
      return b;
    },
    acquire(s = 1, r) {
      return this._acquire(s, null != r ? r : "", 0);
    },
    tryAcquire(s = 1, r, o) {
      return this._acquire(s, null != o ? o : "", r);
    },
    peekQueues: () => g
  };
}

var revMap = {}, numMap = {};

for (let s = 0; s < 256; s++) {
  revMap[`00${s.toString(16)}`.slice(-2)] = s;
  numMap[s] = `00${s.toString(16)}`.slice(-2);
}

function hexStringToUint8Array(s) {
  const r = s.length / 2, o = new Uint8Array(r);
  for (let u = 0; u < r; u++) o[u] = revMap[s[2 * u] + s[2 * u + 1]];
  return o;
}

function uint8ArrayToHexString(s) {
  return [ ...s ].map((s => numMap[s])).join("");
}

function btoa_node(s) {
  return Buffer.from(s, "binary").toString("base64");
}

function atob_node(s) {
  return Buffer.from(s, "base64").toString("binary");
}

var btoa2 = "undefined" != typeof window ? window.btoa : btoa_node, atob2 = "undefined" != typeof window ? window.atob : atob_node, QUANTUM = 32768, writeString = s => {
  const r = new Uint8Array(4 * s.length), o = s.length;
  let u = 0, g = 0, _ = 0;
  for (;_ < o; ) {
    g = s.charCodeAt(_++);
    if (g < 128) r[u++] = g; else if (g < 2048) {
      r[u++] = 192 | g >>> 6;
      r[u++] = 128 | 63 & g;
    } else if (g < 55296 || g > 57343) {
      r[u++] = 224 | g >>> 12;
      r[u++] = 128 | g >>> 6 & 63;
      r[u++] = 128 | 63 & g;
    } else {
      g = 65536 + (g - 55296 << 10 | s.charCodeAt(_++) - 56320);
      r[u++] = 240 | g >>> 18;
      r[u++] = 128 | g >>> 12 & 63;
      r[u++] = 128 | g >>> 6 & 63;
      r[u++] = 128 | 63 & g;
    }
  }
  return r.slice(0, u);
}, readString = s => {
  const r = void 0;
  let o = 0;
  const u = s.length;
  let g = "";
  for (;o < u; ) {
    const r = [], _ = Math.min(o + QUANTUM, u);
    for (;o < _; ) {
      const u = s[o++];
      if (u < 128) r.push(u); else if (192 == (224 & u)) r.push((31 & u) << 6 | 63 & s[o++]); else if (224 == (240 & u)) r.push((15 & u) << 12 | (63 & s[o++]) << 6 | 63 & s[o++]); else if (240 == (248 & u)) {
        let g = (7 & u) << 18 | (63 & s[o++]) << 12 | (63 & s[o++]) << 6 | 63 & s[o++];
        if (g < 65536) r.push(g); else {
          g -= 65536;
          r.push(55296 + (g >>> 10), 56320 + (1023 & g));
        }
      }
    }
    g += String.fromCharCode(...r);
  }
  return g;
}, encodeChunkSize = 15e7;

function arrayBufferToBase64internalBrowser(s) {
  return new Promise(((r, o) => {
    const u = new Blob([ s ], {
      type: "application/octet-binary"
    }), g = new FileReader;
    g.onload = function(u) {
      var g, _;
      const b = (null == (_ = null == (g = u.target) ? void 0 : g.result) ? void 0 : _.toString()) || "";
      if (0 != s.byteLength && ("" == b || "data:" == b)) return o(new TypeError("Could not parse the encoded string"));
      const w = b.substring(b.indexOf(",") + 1);
      r(w);
    };
    g.readAsDataURL(u);
  }));
}

function arrayBufferToBase64internalNode(s) {
  const r = void 0;
  return Buffer.from(s.buffer).toString("base64");
}

var arrayBufferToBase64internal = "undefined" != typeof window ? arrayBufferToBase64internalBrowser : arrayBufferToBase64internalNode;

async function arrayBufferToBase64Single(s) {
  const r = s instanceof Uint8Array ? s : new Uint8Array(s);
  if (r.byteLength < QUANTUM) return btoa2(String.fromCharCode.apply(null, [ ...r ]));
  if ("undefined" != typeof window) return await arrayBufferToBase64internalBrowser(r);
  return Buffer.from(r).toString("base64");
}

async function arrayBufferToBase64(s) {
  const r = s instanceof Uint8Array ? s : new Uint8Array(s);
  if (r.byteLength < QUANTUM) return [ btoa2(String.fromCharCode.apply(null, [ ...r ])) ];
  const o = r.byteLength, u = [];
  let g = 0;
  do {
    const s = g * encodeChunkSize, o = new DataView(r.buffer, s, Math.min(encodeChunkSize, r.byteLength - s));
    u.push(await arrayBufferToBase64internal(o));
    g++;
  } while (g * encodeChunkSize < o);
  return u;
}

function base64ToString(s) {
  try {
    if ("string" != typeof s) return s.map((s => base64ToString(s))).join("");
    const r = atob2(s), o = r.length, u = new Uint8Array(o);
    for (let s = 0; s < o; s++) u[s] = r.charCodeAt(s);
    return readString(u);
  } catch (r) {
    if ("string" != typeof s) return s.join("");
    return s;
  }
}

function base64ToArrayBuffer(s) {
  if ("string" == typeof s) return base64ToArrayBufferInternal(s);
  const r = s.map((s => base64ToArrayBufferInternal(s))), o = r.reduce(((s, r) => s + r.byteLength), 0), u = new Uint8Array(o);
  let g = 0;
  r.forEach((s => {
    u.set(new Uint8Array(s), g);
    g += s.byteLength;
  }));
  return u;
}

var base64ToArrayBufferInternal = "undefined" != typeof window ? base64ToArrayBufferInternalBrowser : base64ToArrayBufferInternalNode;

function base64ToArrayBufferInternalNode(s) {
  try {
    return Buffer.from(s, "base64").buffer;
  } catch (r) {
    return writeString(s).buffer;
  }
}

function base64ToArrayBufferInternalBrowser(s) {
  try {
    const r = atob2(s), o = r.length, u = new Uint8Array(o);
    for (let s = 0; s < o; s++) u[s] = r.charCodeAt(s);
    return u.buffer;
  } catch (r) {
    const o = s.length, u = new Uint8Array(o);
    for (let r = 0; r < o; r++) u[r] = s.charCodeAt(r);
    return u.buffer;
  }
}

function* pickPiece(s, r) {
  let o = "";
  e: do {
    const u = s.shift();
    if ("undefined" == typeof u) {
      yield o;
      break e;
    }
    if (u.startsWith("```") || u.startsWith(" ```") || u.startsWith("  ```") || u.startsWith("   ```")) {
      yield o;
      o = u + (0 != s.length ? "\n" : "");
      t: do {
        const r = s.shift();
        if ("undefined" == typeof r) break t;
        o += r + (0 != s.length ? "\n" : "");
      } while (s.length > 0 && !(s[0].startsWith("```") || s[0].startsWith(" ```") || s[0].startsWith("  ```") || s[0].startsWith("   ```")));
      const r = o.endsWith("="), g = o.length > 2048, _ = s.shift();
      if ("undefined" != typeof _) {
        o += _;
        o += 0 != s.length ? "\n" : "";
      }
      if (!r && !g) {
        const s = /(.*?[;,:<])/g, r = o.split(s).filter((s => "" != s));
        for (const s of r) yield s;
      } else yield o;
      o = "";
    } else {
      o += u + (0 != s.length ? "\n" : "");
      if (o.length >= r || 0 == s.length || "#" == s[0] || "#" == o[0]) {
        yield o;
        o = "";
      }
    }
  } while (s.length > 0);
}

function splitPieces2(s, r, o, u, g) {
  return function* pieces() {
    const g = "string" == typeof s ? [ s ] : s;
    for (const s of g) if (o) {
      const o = void 0, g = pickPiece(s.split("\n"), u);
      for (const s of g) {
        let o = s;
        do {
          let s = r;
          if (o.charCodeAt(s - 1) != o.codePointAt(s - 1)) s++;
          yield o.substring(0, s);
          o = o.substring(s);
        } while ("" != o);
      }
    } else {
      let o = s;
      do {
        const s = o.substring(0, r);
        o = o.substring(r);
        yield s;
      } while ("" != o);
    }
  };
}

function versionNumberString2Number(s) {
  return s.split(".").reverse().map(((s, r) => s / 1 * 1e3 ** r)).reduce(((s, r) => s + r), 0);
}

var escapeStringToHTML = s => {
  if (!s) return "";
  return s.replace(/[<>&"'`]/g, (s => {
    const r = void 0;
    return {
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      '"': "&quot;",
      "'": "&#39;",
      "`": "&#x60;"
    }[s];
  }));
}, crc32kTable = new Uint32Array(256), crc32cTable = new Uint32Array(256);

function generateCRC32KTable() {
  const s = 3988292384;
  for (let r = 0; r < 256; r++) {
    let o = r;
    for (let r = 0; r < 8; r++) if (1 & o) o = o >>> 1 ^ s; else o >>>= 1;
    crc32kTable[r] = o;
  }
}

function generateCRC32CTable() {
  const s = 517762881;
  for (let r = 0; r < 256; r++) {
    let o = r;
    for (let r = 0; r < 8; r++) if (1 & o) o = o >>> 1 ^ s; else o >>>= 1;
    crc32cTable[r] = o;
  }
}

generateCRC32CTable();

generateCRC32KTable();

function crc32CKHash(s) {
  let r = 4294967295, o = 4294967295;
  const u = "s0" + s + "\t" + s.length;
  let g = u.length;
  for (;--g; ) {
    const s = u.charCodeAt(g), _ = 255 & s, b = s >> 8;
    r = r >>> 8 ^ crc32cTable[255 & (r ^ _)];
    r = r >>> 8 ^ crc32cTable[255 & (r ^ b)];
    o = o >>> 8 ^ crc32kTable[255 & (o ^ _)];
    o = o >>> 8 ^ crc32kTable[255 & (o ^ b)];
  }
  r ^= 4294967295;
  o ^= 4294967295;
  return r.toString(32) + "-" + o.toString(32);
}

var import_crypto = require("crypto"), webcrypto;

if ("undefined" != typeof window && window.crypto) webcrypto = window.crypto; else {
  const s = import_crypto.webcrypto;
  webcrypto = s;
}

var KeyBuffs = new Map, decKeyBuffs = new Map, KEY_RECYCLE_COUNT = 100, semiStaticFieldBuffer, nonceBuffer = new Uint32Array(1);

async function getKeyForEncrypt(s, r) {
  const o = `${s}-${r}`, u = KeyBuffs.get(o);
  if (u) {
    u.count--;
    if (u.count > 0) return [ u.key, u.salt ];
    u.count--;
  }
  const g = 15 - s.length, _ = r ? 1e3 * (g > 0 ? g : 0) + 121 - g : 1e5, b = (new TextEncoder).encode(s), w = await webcrypto.subtle.digest({
    name: "SHA-256"
  }, b), E = await webcrypto.subtle.importKey("raw", w, {
    name: "PBKDF2"
  }, false, [ "deriveKey" ]), S = webcrypto.getRandomValues(new Uint8Array(16)), L = await webcrypto.subtle.deriveKey({
    name: "PBKDF2",
    salt: S,
    iterations: _,
    hash: "SHA-256"
  }, E, {
    name: "AES-GCM",
    length: 256
  }, false, [ "encrypt" ]);
  KeyBuffs.set(o, {
    key: L,
    salt: S,
    count: KEY_RECYCLE_COUNT
  });
  return [ L, S ];
}

var keyGCCount = 5 * KEY_RECYCLE_COUNT, decKeyIdx = 0, decKeyMin = 0;

async function getKeyForDecryption(s, r, o) {
  if (--keyGCCount < 0) {
    keyGCCount = KEY_RECYCLE_COUNT;
    const s = (decKeyIdx - decKeyMin) / 2;
    for (const [r, o] of decKeyBuffs) {
      if (o.count < s) decKeyBuffs.delete(r);
      decKeyMin = decKeyIdx;
    }
  }
  decKeyIdx++;
  const u = s + uint8ArrayToHexString(r) + o, g = decKeyBuffs.get(u);
  if (g) {
    g.count = decKeyIdx;
    return [ g.key, g.salt ];
  }
  const _ = 15 - s.length, b = o ? 1e3 * (_ > 0 ? _ : 0) + 121 - _ : 1e5, w = (new TextEncoder).encode(s), E = await webcrypto.subtle.digest({
    name: "SHA-256"
  }, w), S = await webcrypto.subtle.importKey("raw", E, {
    name: "PBKDF2"
  }, false, [ "deriveKey" ]), L = await webcrypto.subtle.deriveKey({
    name: "PBKDF2",
    salt: r,
    iterations: b,
    hash: "SHA-256"
  }, S, {
    name: "AES-GCM",
    length: 256
  }, false, [ "decrypt" ]);
  decKeyBuffs.set(u, {
    key: L,
    salt: r,
    count: 0
  });
  return [ L, r ];
}

function getSemiStaticField(s) {
  if (null != semiStaticFieldBuffer && !s) return semiStaticFieldBuffer;
  return semiStaticFieldBuffer = webcrypto.getRandomValues(new Uint8Array(12));
}

function getNonce() {
  nonceBuffer[0]++;
  if (nonceBuffer[0] > 1e4) getSemiStaticField(true);
  return nonceBuffer;
}

async function encrypt(s, r, o) {
  const [u, g] = await getKeyForEncrypt(r, o), _ = getSemiStaticField(), b = getNonce(), w = new Uint8Array([ ..._, ...new Uint8Array(b.buffer) ]), E = JSON.stringify(s), S = writeString(E), L = await webcrypto.subtle.encrypt({
    name: "AES-GCM",
    iv: w
  }, u, S), O = void 0, D = void 0;
  return `["${await arrayBufferToBase64Single(L)}","${uint8ArrayToHexString(w)}","${uint8ArrayToHexString(g)}"]`;
}

async function decrypt(s, r, o) {
  try {
    if (!s.startsWith("[") || !s.endsWith("]")) throw new Error("Encrypted data corrupted!");
    const u = s.substring(1, s.length - 1).split(",").map((s => '"' == s[0] ? s.substring(1, s.length - 1) : s)), [g, _, b] = u, [w] = await getKeyForDecryption(r, hexStringToUint8Array(b), o), E = hexStringToUint8Array(_), S = atob2(g), L = S.length, O = new Uint8Array(L);
    for (let s = L; s >= 0; --s) O[s] = S.charCodeAt(s);
    const D = await webcrypto.subtle.decrypt({
      name: "AES-GCM",
      iv: E
    }, w, O), k = readString(new Uint8Array(D)), C = void 0;
    return JSON.parse(k);
  } catch (s) {
    Logger("Couldn't decode! You should wrong the passphrases", LOG_LEVEL_VERBOSE);
    Logger(s, LOG_LEVEL_VERBOSE);
    throw s;
  }
}

async function tryDecrypt(s, r, o) {
  if (!r) return false;
  try {
    return await decrypt(s, r, o);
  } catch (s) {
    return false;
  }
}

async function testCrypt() {
  const s = "supercalifragilisticexpialidocious", r = await encrypt(s, "passwordTest", false), o = void 0;
  if (s != await decrypt(r, "passwordTest", false)) {
    Logger("WARNING! Your device would not support encryption.", LOG_LEVEL_VERBOSE);
    return false;
  } else {
    Logger("CRYPT LOGIC OK", LOG_LEVEL_VERBOSE);
    return true;
  }
}

var ReadOnlyObservableStore = class {}, ObservableStore = class extends ReadOnlyObservableStore {
  constructor(s) {
    super();
    this.observers = [];
    this.interceptors = [];
    this.value = s;
  }
  set(s) {
    if (this.value != s) {
      let r = s;
      if (this.interceptors.length > 0) for (const s of this.interceptors) r = s(r);
      this.value = r;
      this.invalidate();
    }
  }
  apply(s) {
    this.value = s(this.value);
    this.invalidate();
  }
  peek() {
    return this.value;
  }
  invalidate() {
    const s = this.value;
    if (void 0 === s) return;
    const r = this.observers;
    for (const o of r) o(s);
  }
  intercept(s) {
    this.interceptors.push(s);
    return () => this.removeInterceptor(s);
  }
  removeInterceptor(s) {
    this.interceptors = this.interceptors.filter((r => r != s));
  }
  observe(s) {
    this.observers.push(s);
    return () => this.unobserve(s);
  }
  unobserve(s) {
    this.observers = this.observers.filter((r => r != s));
  }
}, StreamStore = class extends ObservableStore {
  constructor(s) {
    super(null != s ? s : []);
    this.itemInterceptors = [];
    this.subscribers = [];
  }
  push(s) {
    var r;
    let o = s;
    for (const s of this.itemInterceptors) o = s(o);
    for (const s of this.subscribers) s(o);
    this.set([ ...null != (r = this.value) ? r : [], o ]);
  }
  pop() {
    var s;
    const r = [ ...null != (s = this.value) ? s : [] ], o = r.pop();
    this.set(r);
    return o;
  }
  unshift(s) {
    var r;
    let o = s;
    for (const s of this.itemInterceptors) o = s(o);
    for (const s of this.subscribers) s(o);
    this.set([ o, ...null != (r = this.value) ? r : [] ]);
  }
  shift() {
    var s;
    const [r, ...o] = [ ...null != (s = this.value) ? s : [] ];
    this.set(o);
    return r;
  }
  subscribe(s) {
    this.subscribers.push(s);
    return () => this.unsubscribe(s);
  }
  unsubscribe(s) {
    this.subscribers = this.subscribers.filter((r => r != s));
  }
  interceptEach(s) {
    this.itemInterceptors.push(s);
    return () => this.removeEachInterceptor(s);
  }
  removeEachInterceptor(s) {
    this.itemInterceptors = this.itemInterceptors.filter((r => r != s));
  }
}, globalStore = new Map, globalStream = new Map;

function getGlobalStore(s, r) {
  if (!globalStore.has(s)) globalStore.set(s, new ObservableStore(r));
  return globalStore.get(s);
}

function getGlobalStreamStore(s, r) {
  if (!globalStream.has(s)) globalStream.set(s, new StreamStore(r));
  return globalStream.get(s);
}

function observeStores(s, r) {
  const o = {
    ...s.peek(),
    ...r.peek()
  }, u = new ObservableStore(o);
  s.observe((s => u.apply((r => ({
    ...r,
    ...s
  })))));
  r.observe((s => u.apply((r => ({
    ...r,
    ...s
  })))));
  return u;
}

var lockStore = getGlobalStore("locks", {
  pending: [],
  running: [],
  count: 0
}), waitingData = getGlobalStore("processingLast", 0), logStore = getGlobalStreamStore("logs", []), logMessageStore = getGlobalStore("logMessage", []), externalNotifier = () => {}, notifyTimer = null;

function notifyLock() {
  if (null != notifyTimer) clearTimeout(notifyTimer);
  notifyTimer = setTimeout((() => {
    externalNotifier();
  }), 100);
}

var Mutexes = {};

function updateStore() {
  const s = [ ...Object.values(Mutexes).map((s => s.peekQueues())) ].flat();
  lockStore.apply((r => ({
    ...r,
    count: s.length,
    pending: s.filter((s => "NONE" == s.state)).map((s => {
      var r;
      return null != (r = s.memo) ? r : "";
    })),
    running: s.filter((s => "RUNNING" == s.state)).map((s => {
      var r;
      return null != (r = s.memo) ? r : "";
    }))
  })));
}

var semaphoreReleasedCount = 0;

async function runWithLock(s, r, o) {
  if (semaphoreReleasedCount > 200) {
    const s = [];
    for (const r in Mutexes) if (0 == Mutexes[r].peekQueues().length) s.push(r);
    for (const r of s) delete Mutexes[r];
    semaphoreReleasedCount = 0;
  }
  if (!(s in Mutexes)) Mutexes[s] = Semaphore(1, (s => {
    if (0 == s.length) semaphoreReleasedCount++;
  }));
  const u = r ? 1 : 0, g = await Mutexes[s].tryAcquire(1, u, s);
  updateStore();
  if (!g) return null;
  try {
    return await o();
  } finally {
    g();
    notifyLock();
    updateStore();
  }
}

function isLockAcquired(s) {
  return s in Mutexes && 0 != Mutexes[s].peekQueues().length;
}

var import_brace_expansion = __toESM(require_brace_expansion(), 1), MAX_PATTERN_LENGTH = 65536, assertValidPattern = s => {
  if ("string" != typeof s) throw new TypeError("invalid pattern");
  if (s.length > MAX_PATTERN_LENGTH) throw new TypeError("pattern is too long");
}, posixClasses = {
  "[:alnum:]": [ "\\p{L}\\p{Nl}\\p{Nd}", true ],
  "[:alpha:]": [ "\\p{L}\\p{Nl}", true ],
  "[:ascii:]": [ "\\x00-\\x7f", false ],
  "[:blank:]": [ "\\p{Zs}\\t", true ],
  "[:cntrl:]": [ "\\p{Cc}", true ],
  "[:digit:]": [ "\\p{Nd}", true ],
  "[:graph:]": [ "\\p{Z}\\p{C}", true, true ],
  "[:lower:]": [ "\\p{Ll}", true ],
  "[:print:]": [ "\\p{C}", true ],
  "[:punct:]": [ "\\p{P}", true ],
  "[:space:]": [ "\\p{Z}\\t\\r\\n\\v\\f", true ],
  "[:upper:]": [ "\\p{Lu}", true ],
  "[:word:]": [ "\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true ],
  "[:xdigit:]": [ "A-Fa-f0-9", false ]
}, braceEscape = s => s.replace(/[[\]\\-]/g, "\\$&"), regexpEscape = s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), rangesToString = s => s.join(""), parseClass = (s, r) => {
  const o = r;
  if ("[" !== s.charAt(o)) throw new Error("not in a brace expression");
  const u = [], g = [];
  let _ = o + 1, b = false, w = false, E = false, S = false, L = o, O = "";
  e: for (;_ < s.length; ) {
    const r = s.charAt(_);
    if (("!" === r || "^" === r) && _ === o + 1) {
      S = true;
      _++;
      continue;
    }
    if ("]" === r && b && !E) {
      L = _ + 1;
      break;
    }
    b = true;
    if ("\\" === r) if (!E) {
      E = true;
      _++;
      continue;
    }
    if ("[" === r && !E) for (const [r, [b, E, S]] of Object.entries(posixClasses)) if (s.startsWith(r, _)) {
      if (O) return [ "$.", false, s.length - o, true ];
      _ += r.length;
      if (S) g.push(b); else u.push(b);
      w = w || E;
      continue e;
    }
    E = false;
    if (O) {
      if (r > O) u.push(braceEscape(O) + "-" + braceEscape(r)); else if (r === O) u.push(braceEscape(r));
      O = "";
      _++;
      continue;
    }
    if (s.startsWith("-]", _ + 1)) {
      u.push(braceEscape(r + "-"));
      _ += 2;
      continue;
    }
    if (s.startsWith("-", _ + 1)) {
      O = r;
      _ += 2;
      continue;
    }
    u.push(braceEscape(r));
    _++;
  }
  if (L < _) return [ "", false, 0, false ];
  if (!u.length && !g.length) return [ "$.", false, s.length - o, true ];
  if (0 === g.length && 1 === u.length && /^\\?.$/.test(u[0]) && !S) {
    const s = 2 === u[0].length ? u[0].slice(-1) : u[0];
    return [ regexpEscape(s), false, L - o, false ];
  }
  const D = "[" + (S ? "^" : "") + rangesToString(u) + "]", k = "[" + (S ? "" : "^") + rangesToString(g) + "]", C = void 0;
  return [ u.length && g.length ? "(" + D + "|" + k + ")" : u.length ? D : k, w, L - o, true ];
}, unescape2 = (s, {windowsPathsNoEscape: r = false} = {}) => r ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1"), types = new Set([ "!", "?", "+", "*", "@" ]), isExtglobType = s => types.has(s), startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))", startNoDot = "(?!\\.)", addPatternStart = new Set([ "[", "." ]), justDots = new Set([ "..", "." ]), reSpecials = new Set("().*{}+?[]^$\\!"), regExpEscape = s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), qmark = "[^/]", star = qmark + "*?", starNoEmpty = qmark + "+?", _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn, _AST = class _AST {
  constructor(s, r, o = {}) {
    __privateAdd(this, _fillNegs);
    __privateAdd(this, _partsToRegExp);
    __publicField(this, "type");
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _hasMagic, void 0);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent, void 0);
    __privateAdd(this, _parentIndex, void 0);
    __privateAdd(this, _negs, void 0);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _toString, void 0);
    __privateAdd(this, _emptyExt, false);
    this.type = s;
    if (s) __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, r);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options, __privateGet(this, _root) === this ? o : __privateGet(__privateGet(this, _root), _options));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if ("!" === s && !__privateGet(__privateGet(this, _root), _filledNegs)) __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (void 0 !== __privateGet(this, _hasMagic)) return __privateGet(this, _hasMagic);
    for (const s of __privateGet(this, _parts)) {
      if ("string" == typeof s) continue;
      if (s.type || s.hasMagic) return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  toString() {
    if (void 0 !== __privateGet(this, _toString)) return __privateGet(this, _toString);
    if (!this.type) return __privateSet(this, _toString, __privateGet(this, _parts).map((s => String(s))).join("")); else return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((s => String(s))).join("|") + ")");
  }
  push(...s) {
    for (const r of s) {
      if ("" === r) continue;
      if ("string" != typeof r && !(r instanceof _AST && __privateGet(r, _parent) === this)) throw new Error("invalid part: " + r);
      __privateGet(this, _parts).push(r);
    }
  }
  toJSON() {
    var s;
    const r = null === this.type ? __privateGet(this, _parts).slice().map((s => "string" == typeof s ? s : s.toJSON())) : [ this.type, ...__privateGet(this, _parts).map((s => s.toJSON())) ];
    if (this.isStart() && !this.type) r.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && "!" === (null == (s = __privateGet(this, _parent)) ? void 0 : s.type))) r.push({});
    return r;
  }
  isStart() {
    var s;
    if (__privateGet(this, _root) === this) return true;
    if (!(null == (s = __privateGet(this, _parent)) ? void 0 : s.isStart())) return false;
    if (0 === __privateGet(this, _parentIndex)) return true;
    const r = __privateGet(this, _parent);
    for (let s = 0; s < __privateGet(this, _parentIndex); s++) {
      const o = __privateGet(r, _parts)[s];
      if (!(o instanceof _AST && "!" === o.type)) return false;
    }
    return true;
  }
  isEnd() {
    var s, r, o;
    if (__privateGet(this, _root) === this) return true;
    if ("!" === (null == (s = __privateGet(this, _parent)) ? void 0 : s.type)) return true;
    if (!(null == (r = __privateGet(this, _parent)) ? void 0 : r.isEnd())) return false;
    if (!this.type) return null == (o = __privateGet(this, _parent)) ? void 0 : o.isEnd();
    const u = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === u - 1;
  }
  copyIn(s) {
    if ("string" == typeof s) this.push(s); else this.push(s.clone(this));
  }
  clone(s) {
    const r = new _AST(this.type, s);
    for (const s of __privateGet(this, _parts)) r.copyIn(s);
    return r;
  }
  static fromGlob(s, r = {}) {
    var o;
    const u = new _AST(null, void 0, r);
    __privateMethod(o = _AST, _parseAST, parseAST_fn).call(o, s, u, 0, r);
    return u;
  }
  toMMPattern() {
    if (this !== __privateGet(this, _root)) return __privateGet(this, _root).toMMPattern();
    const s = this.toString(), [r, o, u, g] = this.toRegExpSource(), _ = void 0;
    if (!(u || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && s.toUpperCase() !== s.toLowerCase())) return o;
    const b = (__privateGet(this, _options).nocase ? "i" : "") + (g ? "u" : "");
    return Object.assign(new RegExp(`^${r}$`, b), {
      _src: r,
      _glob: s
    });
  }
  toRegExpSource(s) {
    var r;
    const o = null != s ? s : !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root) === this) __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
    if (!this.type) {
      const u = this.isStart() && this.isEnd(), g = __privateGet(this, _parts).map((r => {
        var o;
        const [g, _, b, w] = "string" == typeof r ? __privateMethod(o = _AST, _parseGlob, parseGlob_fn).call(o, r, __privateGet(this, _hasMagic), u) : r.toRegExpSource(s);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || b);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || w);
        return g;
      })).join("");
      let _ = "";
      if (this.isStart()) if ("string" == typeof __privateGet(this, _parts)[0]) {
        const r = void 0;
        if (!(1 === __privateGet(this, _parts).length && justDots.has(__privateGet(this, _parts)[0]))) {
          const r = addPatternStart, u = o && r.has(g.charAt(0)) || g.startsWith("\\.") && r.has(g.charAt(2)) || g.startsWith("\\.\\.") && r.has(g.charAt(4)), b = !o && !s && r.has(g.charAt(0));
          _ = u ? startNoTraversal : b ? startNoDot : "";
        }
      }
      let b = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && "!" === (null == (r = __privateGet(this, _parent)) ? void 0 : r.type)) b = "(?:$|\\/)";
      const w = void 0;
      return [ _ + g + b, unescape2(g), __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)), __privateGet(this, _uflag) ];
    }
    const u = "*" === this.type || "+" === this.type, g = "!" === this.type ? "(?:(?!(?:" : "(?:";
    let _ = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, o);
    if (this.isStart() && this.isEnd() && !_ && "!" !== this.type) {
      const s = this.toString();
      __privateSet(this, _parts, [ s ]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [ s, unescape2(this.toString()), false, false ];
    }
    let b = !u || s || o || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
    if (b === _) b = "";
    if (b) _ = `(?:${_})(?:${b})*?`;
    let w = "";
    if ("!" === this.type && __privateGet(this, _emptyExt)) w = (this.isStart() && !o ? startNoDot : "") + starNoEmpty; else {
      const r = void 0;
      w = g + _ + ("!" === this.type ? "))" + (this.isStart() && !o && !s ? startNoDot : "") + star + ")" : "@" === this.type ? ")" : "?" === this.type ? ")?" : "+" === this.type && b ? ")" : "*" === this.type && b ? ")?" : `)${this.type}`);
    }
    return [ w, unescape2(_), __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)), __privateGet(this, _uflag) ];
  }
};

_root = new WeakMap;

_hasMagic = new WeakMap;

_uflag = new WeakMap;

_parts = new WeakMap;

_parent = new WeakMap;

_parentIndex = new WeakMap;

_negs = new WeakMap;

_filledNegs = new WeakMap;

_options = new WeakMap;

_toString = new WeakMap;

_emptyExt = new WeakMap;

_fillNegs = new WeakSet;

fillNegs_fn = function() {
  if (this !== __privateGet(this, _root)) throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs)) return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let s;
  for (;s = __privateGet(this, _negs).pop(); ) {
    if ("!" !== s.type) continue;
    let r = s, o = __privateGet(r, _parent);
    for (;o; ) {
      for (let u = __privateGet(r, _parentIndex) + 1; !o.type && u < __privateGet(o, _parts).length; u++) for (const r of __privateGet(s, _parts)) {
        if ("string" == typeof r) throw new Error("string part in extglob AST??");
        r.copyIn(__privateGet(o, _parts)[u]);
      }
      r = o;
      o = __privateGet(r, _parent);
    }
  }
  return this;
};

_parseAST = new WeakSet;

parseAST_fn = function(s, r, o, u) {
  var g, _;
  let b = false, w = false, E = -1, S = false;
  if (null === r.type) {
    let _ = o, L = "";
    for (;_ < s.length; ) {
      const o = s.charAt(_++);
      if (b || "\\" === o) {
        b = !b;
        L += o;
        continue;
      }
      if (w) {
        if (_ === E + 1) {
          if ("^" === o || "!" === o) S = true;
        } else if ("]" === o && !(_ === E + 2 && S)) w = false;
        L += o;
        continue;
      } else if ("[" === o) {
        w = true;
        E = _;
        S = false;
        L += o;
        continue;
      }
      if (!u.noext && isExtglobType(o) && "(" === s.charAt(_)) {
        r.push(L);
        L = "";
        const b = new _AST(o, r);
        _ = __privateMethod(g = _AST, _parseAST, parseAST_fn).call(g, s, b, _, u);
        r.push(b);
        continue;
      }
      L += o;
    }
    r.push(L);
    return _;
  }
  let L = o + 1, O = new _AST(null, r);
  const D = [];
  let k = "";
  for (;L < s.length; ) {
    const o = s.charAt(L++);
    if (b || "\\" === o) {
      b = !b;
      k += o;
      continue;
    }
    if (w) {
      if (L === E + 1) {
        if ("^" === o || "!" === o) S = true;
      } else if ("]" === o && !(L === E + 2 && S)) w = false;
      k += o;
      continue;
    } else if ("[" === o) {
      w = true;
      E = L;
      S = false;
      k += o;
      continue;
    }
    if (isExtglobType(o) && "(" === s.charAt(L)) {
      O.push(k);
      k = "";
      const r = new _AST(o, O);
      O.push(r);
      L = __privateMethod(_ = _AST, _parseAST, parseAST_fn).call(_, s, r, L, u);
      continue;
    }
    if ("|" === o) {
      O.push(k);
      k = "";
      D.push(O);
      O = new _AST(null, r);
      continue;
    }
    if (")" === o) {
      if ("" === k && 0 === __privateGet(r, _parts).length) __privateSet(r, _emptyExt, true);
      O.push(k);
      k = "";
      r.push(...D, O);
      return L;
    }
    k += o;
  }
  r.type = null;
  __privateSet(r, _hasMagic, void 0);
  __privateSet(r, _parts, [ s.substring(o - 1) ]);
  return L;
};

_partsToRegExp = new WeakSet;

partsToRegExp_fn = function(s) {
  return __privateGet(this, _parts).map((r => {
    if ("string" == typeof r) throw new Error("string type in extglob ast??");
    const [o, u, g, _] = r.toRegExpSource(s);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || _);
    return o;
  })).filter((s => !(this.isStart() && this.isEnd() && !s))).join("|");
};

_parseGlob = new WeakSet;

parseGlob_fn = function(s, r, o = false) {
  let u = false, g = "", _ = false;
  for (let b = 0; b < s.length; b++) {
    const w = s.charAt(b);
    if (u) {
      u = false;
      g += (reSpecials.has(w) ? "\\" : "") + w;
      continue;
    }
    if ("\\" === w) {
      if (b === s.length - 1) g += "\\\\"; else u = true;
      continue;
    }
    if ("[" === w) {
      const [o, u, w, E] = parseClass(s, b);
      if (w) {
        g += o;
        _ = _ || u;
        b += w - 1;
        r = r || E;
        continue;
      }
    }
    if ("*" === w) {
      if (o && "*" === s) g += starNoEmpty; else g += star;
      r = true;
      continue;
    }
    if ("?" === w) {
      g += qmark;
      r = true;
      continue;
    }
    g += regExpEscape(w);
  }
  return [ g, unescape2(s), !!r, _ ];
};

__privateAdd(_AST, _parseAST);

__privateAdd(_AST, _parseGlob);

var AST = _AST, escape = (s, {windowsPathsNoEscape: r = false} = {}) => r ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&"), minimatch = (s, r, o = {}) => {
  assertValidPattern(r);
  if (!o.nocomment && "#" === r.charAt(0)) return false;
  return new Minimatch(r, o).match(s);
}, starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/, starDotExtTest = s => r => !r.startsWith(".") && r.endsWith(s), starDotExtTestDot = s => r => r.endsWith(s), starDotExtTestNocase = s => {
  s = s.toLowerCase();
  return r => !r.startsWith(".") && r.toLowerCase().endsWith(s);
}, starDotExtTestNocaseDot = s => {
  s = s.toLowerCase();
  return r => r.toLowerCase().endsWith(s);
}, starDotStarRE = /^\*+\.\*+$/, starDotStarTest = s => !s.startsWith(".") && s.includes("."), starDotStarTestDot = s => "." !== s && ".." !== s && s.includes("."), dotStarRE = /^\.\*+$/, dotStarTest = s => "." !== s && ".." !== s && s.startsWith("."), starRE = /^\*+$/, starTest = s => 0 !== s.length && !s.startsWith("."), starTestDot = s => 0 !== s.length && "." !== s && ".." !== s, qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/, qmarksTestNocase = ([s, r = ""]) => {
  const o = qmarksTestNoExt([ s ]);
  if (!r) return o;
  r = r.toLowerCase();
  return s => o(s) && s.toLowerCase().endsWith(r);
}, qmarksTestNocaseDot = ([s, r = ""]) => {
  const o = qmarksTestNoExtDot([ s ]);
  if (!r) return o;
  r = r.toLowerCase();
  return s => o(s) && s.toLowerCase().endsWith(r);
}, qmarksTestDot = ([s, r = ""]) => {
  const o = qmarksTestNoExtDot([ s ]);
  return !r ? o : s => o(s) && s.endsWith(r);
}, qmarksTest = ([s, r = ""]) => {
  const o = qmarksTestNoExt([ s ]);
  return !r ? o : s => o(s) && s.endsWith(r);
}, qmarksTestNoExt = ([s]) => {
  const r = s.length;
  return s => s.length === r && !s.startsWith(".");
}, qmarksTestNoExtDot = ([s]) => {
  const r = s.length;
  return s => s.length === r && "." !== s && ".." !== s;
}, defaultPlatform = "object" == typeof process && process ? "object" == typeof process.env && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", path = {
  win32: {
    sep: "\\"
  },
  posix: {
    sep: "/"
  }
}, sep = "win32" === defaultPlatform ? path.win32.sep : path.posix.sep;

minimatch.sep = sep;

var GLOBSTAR = Symbol("globstar **");

minimatch.GLOBSTAR = GLOBSTAR;

var qmark2 = "[^/]", star2 = qmark2 + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", filter = (s, r = {}) => o => minimatch(o, s, r);

minimatch.filter = filter;

var ext = (s, r = {}) => Object.assign({}, s, r), defaults = s => {
  if (!s || "object" != typeof s || !Object.keys(s).length) return minimatch;
  const r = minimatch, m = (o, u, g = {}) => r(o, u, ext(s, g));
  return Object.assign(m, {
    Minimatch: class Minimatch extends r.Minimatch {
      constructor(r, o = {}) {
        super(r, ext(s, o));
      }
      static defaults(o) {
        return r.defaults(ext(s, o)).Minimatch;
      }
    },
    AST: class AST extends r.AST {
      constructor(r, o, u = {}) {
        super(r, o, ext(s, u));
      }
      static fromGlob(o, u = {}) {
        return r.AST.fromGlob(o, ext(s, u));
      }
    },
    unescape: (o, u = {}) => r.unescape(o, ext(s, u)),
    escape: (o, u = {}) => r.escape(o, ext(s, u)),
    filter: (o, u = {}) => r.filter(o, ext(s, u)),
    defaults: o => r.defaults(ext(s, o)),
    makeRe: (o, u = {}) => r.makeRe(o, ext(s, u)),
    braceExpand: (o, u = {}) => r.braceExpand(o, ext(s, u)),
    match: (o, u, g = {}) => r.match(o, u, ext(s, g)),
    sep: r.sep,
    GLOBSTAR
  });
};

minimatch.defaults = defaults;

var braceExpand = (s, r = {}) => {
  assertValidPattern(s);
  if (r.nobrace || !/\{(?:(?!\{).)*\}/.test(s)) return [ s ];
  return (0, import_brace_expansion.default)(s);
};

minimatch.braceExpand = braceExpand;

var makeRe = (s, r = {}) => new Minimatch(s, r).makeRe();

minimatch.makeRe = makeRe;

var match = (s, r, o = {}) => {
  const u = new Minimatch(r, o);
  s = s.filter((s => u.match(s)));
  if (u.options.nonull && !s.length) s.push(r);
  return s;
};

minimatch.match = match;

var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/, regExpEscape2 = s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), Minimatch = class {
  constructor(s, r = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(s);
    r = r || {};
    this.options = r;
    this.pattern = s;
    this.platform = r.platform || defaultPlatform;
    this.isWindows = "win32" === this.platform;
    this.windowsPathsNoEscape = !!r.windowsPathsNoEscape || false === r.allowWindowsEscape;
    if (this.windowsPathsNoEscape) this.pattern = this.pattern.replace(/\\/g, "/");
    this.preserveMultipleSlashes = !!r.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!r.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!r.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = void 0 !== r.windowsNoMagicRoot ? r.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) return true;
    for (const s of this.set) for (const r of s) if ("string" != typeof r) return true;
    return false;
  }
  debug(...s) {}
  make() {
    const s = this.pattern, r = this.options;
    if (!r.nocomment && "#" === s.charAt(0)) {
      this.comment = true;
      return;
    }
    if (!s) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [ ...new Set(this.braceExpand()) ];
    if (r.debug) this.debug = (...s) => console.error(...s);
    this.debug(this.pattern, this.globSet);
    const o = this.globSet.map((s => this.slashSplit(s)));
    this.globParts = this.preprocess(o);
    this.debug(this.pattern, this.globParts);
    let u = this.globParts.map(((s, r, o) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const r = !("" !== s[0] || "" !== s[1] || "?" !== s[2] && globMagic.test(s[2]) || globMagic.test(s[3])), o = /^[a-z]:/i.test(s[0]);
        if (r) return [ ...s.slice(0, 4), ...s.slice(4).map((s => this.parse(s))) ]; else if (o) return [ s[0], ...s.slice(1).map((s => this.parse(s))) ];
      }
      return s.map((s => this.parse(s)));
    }));
    this.debug(this.pattern, u);
    this.set = u.filter((s => -1 === s.indexOf(false)));
    if (this.isWindows) for (let s = 0; s < this.set.length; s++) {
      const r = this.set[s];
      if ("" === r[0] && "" === r[1] && "?" === this.globParts[s][2] && "string" == typeof r[3] && /^[a-z]:$/i.test(r[3])) r[2] = "?";
    }
    this.debug(this.pattern, this.set);
  }
  preprocess(s) {
    if (this.options.noglobstar) for (let r = 0; r < s.length; r++) for (let o = 0; o < s[r].length; o++) if ("**" === s[r][o]) s[r][o] = "*";
    const {optimizationLevel: r = 1} = this.options;
    if (r >= 2) {
      s = this.firstPhasePreProcess(s);
      s = this.secondPhasePreProcess(s);
    } else if (r >= 1) s = this.levelOneOptimize(s); else s = this.adjascentGlobstarOptimize(s);
    return s;
  }
  adjascentGlobstarOptimize(s) {
    return s.map((s => {
      let r = -1;
      for (;-1 !== (r = s.indexOf("**", r + 1)); ) {
        let o = r;
        for (;"**" === s[o + 1]; ) o++;
        if (o !== r) s.splice(r, o - r);
      }
      return s;
    }));
  }
  levelOneOptimize(s) {
    return s.map((s => 0 === (s = s.reduce(((s, r) => {
      const o = s[s.length - 1];
      if ("**" === r && "**" === o) return s;
      if (".." === r) if (o && ".." !== o && "." !== o && "**" !== o) {
        s.pop();
        return s;
      }
      s.push(r);
      return s;
    }), [])).length ? [ "" ] : s));
  }
  levelTwoFileOptimize(s) {
    if (!Array.isArray(s)) s = this.slashSplit(s);
    let r = false;
    do {
      r = false;
      if (!this.preserveMultipleSlashes) {
        for (let o = 1; o < s.length - 1; o++) {
          const u = s[o];
          if (1 === o && "" === u && "" === s[0]) continue;
          if ("." === u || "" === u) {
            r = true;
            s.splice(o, 1);
            o--;
          }
        }
        if ("." === s[0] && 2 === s.length && ("." === s[1] || "" === s[1])) {
          r = true;
          s.pop();
        }
      }
      let o = 0;
      for (;-1 !== (o = s.indexOf("..", o + 1)); ) {
        const u = s[o - 1];
        if (u && "." !== u && ".." !== u && "**" !== u) {
          r = true;
          s.splice(o - 1, 2);
          o -= 2;
        }
      }
    } while (r);
    return 0 === s.length ? [ "" ] : s;
  }
  firstPhasePreProcess(s) {
    let r = false;
    do {
      r = false;
      for (let o of s) {
        let u = -1;
        for (;-1 !== (u = o.indexOf("**", u + 1)); ) {
          let g = u;
          for (;"**" === o[g + 1]; ) g++;
          if (g > u) o.splice(u + 1, g - u);
          let _ = o[u + 1];
          const b = o[u + 2], w = o[u + 3];
          if (".." !== _) continue;
          if (!b || "." === b || ".." === b || !w || "." === w || ".." === w) continue;
          r = true;
          o.splice(u, 1);
          const E = o.slice(0);
          E[u] = "**";
          s.push(E);
          u--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let s = 1; s < o.length - 1; s++) {
            const u = o[s];
            if (1 === s && "" === u && "" === o[0]) continue;
            if ("." === u || "" === u) {
              r = true;
              o.splice(s, 1);
              s--;
            }
          }
          if ("." === o[0] && 2 === o.length && ("." === o[1] || "" === o[1])) {
            r = true;
            o.pop();
          }
        }
        let g = 0;
        for (;-1 !== (g = o.indexOf("..", g + 1)); ) {
          const s = o[g - 1];
          if (s && "." !== s && ".." !== s && "**" !== s) {
            r = true;
            const s = void 0, u = 1 === g && "**" === o[g + 1] ? [ "." ] : [];
            o.splice(g - 1, 2, ...u);
            if (0 === o.length) o.push("");
            g -= 2;
          }
        }
      }
    } while (r);
    return s;
  }
  secondPhasePreProcess(s) {
    for (let r = 0; r < s.length - 1; r++) for (let o = r + 1; o < s.length; o++) {
      const u = this.partsMatch(s[r], s[o], !this.preserveMultipleSlashes);
      if (!u) continue;
      s[r] = u;
      s[o] = [];
    }
    return s.filter((s => s.length));
  }
  partsMatch(s, r, o = false) {
    let u = 0, g = 0, _ = [], b = "";
    for (;u < s.length && g < r.length; ) if (s[u] === r[g]) {
      _.push("b" === b ? r[g] : s[u]);
      u++;
      g++;
    } else if (o && "**" === s[u] && r[g] === s[u + 1]) {
      _.push(s[u]);
      u++;
    } else if (o && "**" === r[g] && s[u] === r[g + 1]) {
      _.push(r[g]);
      g++;
    } else if ("*" === s[u] && r[g] && (this.options.dot || !r[g].startsWith(".")) && "**" !== r[g]) {
      if ("b" === b) return false;
      b = "a";
      _.push(s[u]);
      u++;
      g++;
    } else if ("*" === r[g] && s[u] && (this.options.dot || !s[u].startsWith(".")) && "**" !== s[u]) {
      if ("a" === b) return false;
      b = "b";
      _.push(r[g]);
      u++;
      g++;
    } else return false;
    return s.length === r.length && _;
  }
  parseNegate() {
    if (this.nonegate) return;
    const s = this.pattern;
    let r = false, o = 0;
    for (let u = 0; u < s.length && "!" === s.charAt(u); u++) {
      r = !r;
      o++;
    }
    if (o) this.pattern = s.slice(o);
    this.negate = r;
  }
  matchOne(s, r, o = false) {
    const u = this.options;
    if (this.isWindows) {
      const o = "string" == typeof s[0] && /^[a-z]:$/i.test(s[0]), u = !o && "" === s[0] && "" === s[1] && "?" === s[2] && /^[a-z]:$/i.test(s[3]), g = "string" == typeof r[0] && /^[a-z]:$/i.test(r[0]), _ = void 0, b = u ? 3 : o ? 0 : void 0, w = !g && "" === r[0] && "" === r[1] && "?" === r[2] && "string" == typeof r[3] && /^[a-z]:$/i.test(r[3]) ? 3 : g ? 0 : void 0;
      if ("number" == typeof b && "number" == typeof w) {
        const [o, u] = [ s[b], r[w] ];
        if (o.toLowerCase() === u.toLowerCase()) {
          r[w] = o;
          if (w > b) r = r.slice(w); else if (b > w) s = s.slice(b);
        }
      }
    }
    const {optimizationLevel: g = 1} = this.options;
    if (g >= 2) s = this.levelTwoFileOptimize(s);
    this.debug("matchOne", this, {
      file: s,
      pattern: r
    });
    this.debug("matchOne", s.length, r.length);
    for (var _ = 0, b = 0, w = s.length, E = r.length; _ < w && b < E; _++, b++) {
      this.debug("matchOne loop");
      var S = r[b], L = s[_];
      this.debug(r, S, L);
      if (false === S) return false;
      if (S === GLOBSTAR) {
        this.debug("GLOBSTAR", [ r, S, L ]);
        var O = _, D = b + 1;
        if (D === E) {
          this.debug("** at the end");
          for (;_ < w; _++) if ("." === s[_] || ".." === s[_] || !u.dot && "." === s[_].charAt(0)) return false;
          return true;
        }
        for (;O < w; ) {
          var k = s[O];
          this.debug("\nglobstar while", s, O, r, D, k);
          if (this.matchOne(s.slice(O), r.slice(D), o)) {
            this.debug("globstar found match!", O, w, k);
            return true;
          } else {
            if ("." === k || ".." === k || !u.dot && "." === k.charAt(0)) {
              this.debug("dot detected!", s, O, r, D);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            O++;
          }
        }
        if (o) {
          this.debug("\n>>> no match, partial?", s, O, r, D);
          if (O === w) return true;
        }
        return false;
      }
      let g;
      if ("string" == typeof S) {
        g = L === S;
        this.debug("string match", S, L, g);
      } else {
        g = S.test(L);
        this.debug("pattern match", S, L, g);
      }
      if (!g) return false;
    }
    if (_ === w && b === E) return true; else if (_ === w) return o; else if (b === E) return _ === w - 1 && "" === s[_]; else throw new Error("wtf?");
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(s) {
    assertValidPattern(s);
    const r = this.options;
    if ("**" === s) return GLOBSTAR;
    if ("" === s) return "";
    let o, u = null;
    if (o = s.match(starRE)) u = r.dot ? starTestDot : starTest; else if (o = s.match(starDotExtRE)) u = (r.nocase ? r.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : r.dot ? starDotExtTestDot : starDotExtTest)(o[1]); else if (o = s.match(qmarksRE)) u = (r.nocase ? r.dot ? qmarksTestNocaseDot : qmarksTestNocase : r.dot ? qmarksTestDot : qmarksTest)(o); else if (o = s.match(starDotStarRE)) u = r.dot ? starDotStarTestDot : starDotStarTest; else if (o = s.match(dotStarRE)) u = dotStarTest;
    const g = AST.fromGlob(s, this.options).toMMPattern();
    return u ? Object.assign(g, {
      test: u
    }) : g;
  }
  makeRe() {
    if (this.regexp || false === this.regexp) return this.regexp;
    const s = this.set;
    if (!s.length) {
      this.regexp = false;
      return this.regexp;
    }
    const r = this.options, o = r.noglobstar ? star2 : r.dot ? twoStarDot : twoStarNoDot, u = new Set(r.nocase ? [ "i" ] : []);
    let g = s.map((s => {
      const r = s.map((s => {
        if (s instanceof RegExp) for (const r of s.flags.split("")) u.add(r);
        return "string" == typeof s ? regExpEscape2(s) : s === GLOBSTAR ? GLOBSTAR : s._src;
      }));
      r.forEach(((s, u) => {
        const g = r[u + 1], _ = r[u - 1];
        if (s !== GLOBSTAR || _ === GLOBSTAR) return;
        if (void 0 === _) if (void 0 !== g && g !== GLOBSTAR) r[u + 1] = "(?:\\/|" + o + "\\/)?" + g; else r[u] = o; else if (void 0 === g) r[u - 1] = _ + "(?:\\/|" + o + ")?"; else if (g !== GLOBSTAR) {
          r[u - 1] = _ + "(?:\\/|\\/" + o + "\\/)" + g;
          r[u + 1] = GLOBSTAR;
        }
      }));
      return r.filter((s => s !== GLOBSTAR)).join("/");
    })).join("|");
    const [_, b] = s.length > 1 ? [ "(?:", ")" ] : [ "", "" ];
    g = "^" + _ + g + b + "$";
    if (this.negate) g = "^(?!" + g + ").+$";
    try {
      this.regexp = new RegExp(g, [ ...u ].join(""));
    } catch (s) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(s) {
    if (this.preserveMultipleSlashes) return s.split("/"); else if (this.isWindows && /^\/\/[^\/]+/.test(s)) return [ "", ...s.split(/\/+/) ]; else return s.split(/\/+/);
  }
  match(s, r = this.partial) {
    this.debug("match", s, this.pattern);
    if (this.comment) return false;
    if (this.empty) return "" === s;
    if ("/" === s && r) return true;
    const o = this.options;
    if (this.isWindows) s = s.split("\\").join("/");
    const u = this.slashSplit(s);
    this.debug(this.pattern, "split", u);
    const g = this.set;
    this.debug(this.pattern, "set", g);
    let _ = u[u.length - 1];
    if (!_) for (let s = u.length - 2; !_ && s >= 0; s--) _ = u[s];
    for (let s = 0; s < g.length; s++) {
      const b = g[s];
      let w = u;
      if (o.matchBase && 1 === b.length) w = [ _ ];
      const E = void 0;
      if (this.matchOne(w, b, r)) {
        if (o.flipNegate) return true;
        return !this.negate;
      }
    }
    if (o.flipNegate) return false;
    return this.negate;
  }
  static defaults(s) {
    return minimatch.defaults(s).Minimatch;
  }
};

minimatch.AST = AST;

minimatch.Minimatch = Minimatch;

minimatch.escape = escape;

minimatch.unescape = unescape2;

function isValidFilenameInWidows(s) {
  const r = void 0;
  if (/[\u0000-\u001f]|[\\":?<>|*#]/g.test(s)) return false;
  const o = void 0;
  if (/(\\|\/)(COM\d|LPT\d|CON|PRN|AUX|NUL|CLOCK$)($|\.)/gi.test(s)) return false;
  return true;
}

function isValidFilenameInDarwin(s) {
  const r = void 0;
  return !/[\u0000-\u001f]|[:]/g.test(s);
}

function isValidFilenameInLinux(s) {
  const r = void 0;
  return !/[\u0000-\u001f]|[:]/g.test(s);
}

function isValidFilenameInAndroid(s) {
  const r = void 0;
  return !/[\u0000-\u001f]|[\\":?<>|*#]/g.test(s);
}

function isFilePath(s) {
  if (-1 === s.indexOf(":")) return true;
  return false;
}

function stripAllPrefixes(s) {
  if (isFilePath(s)) return s;
  const [, r] = expandFilePathPrefix(s);
  return stripAllPrefixes(r);
}

function addPrefix(s, r) {
  if (r && s.startsWith(r)) return s;
  return `${null != r ? r : ""}${s}`;
}

function expandFilePathPrefix(s) {
  let [r, o] = s.split(":", 2);
  if (!o) {
    o = r;
    r = "";
  } else r += ":";
  return [ r, o ];
}

function expandDocumentIDPrefix(s) {
  let [r, o] = s.split(":", 2);
  if (!o) {
    o = r;
    r = "";
  } else r += ":";
  return [ r, o ];
}

var hashString = memorizeFuncWithLRUCache((async s => {
  const r = writeString(s);
  let o = await webcrypto.subtle.digest("SHA-256", r);
  const u = s.length;
  for (let s = 0; s < u; s++) o = await webcrypto.subtle.digest("SHA-256", r);
  return uint8ArrayToHexString(new Uint8Array(o));
}));

async function path2id_base(s, r) {
  if (s.startsWith(PREFIX_OBFUSCATED)) return s;
  let o = s;
  if (o.startsWith("_")) o = "/" + o;
  if (!r) return o;
  const [u, g] = expandFilePathPrefix(o);
  if (g.startsWith(PREFIX_OBFUSCATED)) return o;
  const _ = await hashString(r), b = await hashString(`${_}:${s}`);
  return u + PREFIX_OBFUSCATED + b;
}

function id2path_base(s, r) {
  if (r && (null == r ? void 0 : r.path)) return id2path_base(r.path);
  if (s.startsWith(PREFIX_OBFUSCATED)) throw new Error("Entry has been obfuscated!");
  const [o, u] = expandDocumentIDPrefix(s);
  if (u.startsWith(PREFIX_OBFUSCATED)) throw new Error("Entry has been obfuscated!");
  if (u.startsWith("/")) return u.substring(1);
  return o + u;
}

function getPath(s) {
  return id2path_base(s._id, s);
}

function stripPrefix(s) {
  const [r, o] = s.split(":", 2);
  if (!o) return r;
  return o;
}

function shouldBeIgnored(s) {
  if (s == FLAGMD_REDFLAG) return true;
  if (s == FLAGMD_REDFLAG2) return true;
  if (s == FLAGMD_REDFLAG3) return true;
  if (s.startsWith(PREFIXMD_LOGFILE)) return true;
  return false;
}

function isPlainText(s) {
  if (s.endsWith(".md")) return true;
  if (s.endsWith(".txt")) return true;
  if (s.endsWith(".svg")) return true;
  if (s.endsWith(".html")) return true;
  if (s.endsWith(".csv")) return true;
  if (s.endsWith(".css")) return true;
  if (s.endsWith(".js")) return true;
  if (s.endsWith(".xml")) return true;
  if (s.endsWith(".canvas")) return true;
  return false;
}

function shouldSplitAsPlainText(s) {
  if (s.endsWith(".md")) return true;
  if (s.endsWith(".txt")) return true;
  if (s.endsWith(".canvas")) return true;
  return false;
}

var matchOpts = {
  platform: "linux",
  dot: true,
  flipNegate: true,
  nocase: true
};

function isAccepted(s, r) {
  if (-1 !== s.indexOf("./") || -1 !== s.indexOf("../")) return false;
  const o = r.map((s => s.trim())).filter((s => s.length > 0 && !s.startsWith("#")));
  let u;
  for (const r of o) {
    if (r.endsWith("/")) if (minimatch(s, `${r}**`, matchOpts)) return false;
    const o = r.startsWith("!"), g = void 0;
    if (minimatch(s, r, matchOpts) || !r.endsWith("/") && minimatch(s, r + "/**", matchOpts)) u = o;
  }
  return u;
}

async function isAcceptedAll(s, r, o) {
  const u = void 0, g = unique(s.substring(0, s.lastIndexOf("/")).split("/").reduce(((s, r) => [ ...s, s[s.length - 1] + "/" + r ]), [ "" ]).map((s => s.substring(1)))).reverse();
  for (const u of g) for (const g of r) {
    const r = u + "/" + g, _ = await o(r);
    if (false === _) continue;
    const b = isAccepted(s.substring(u.length ? u.length + 1 : 0), _);
    if (void 0 !== b) return b;
  }
  return true;
}

function unwrapTaskResult(s) {
  if ("ok" in s) return s.ok;
  if ("err" in s) return s.err;
  return;
}

function isTaskWaiting(s) {
  if (s instanceof Promise) return false;
  if (s instanceof Function) return true;
  throw new Error("Invalid state");
}

async function wrapEachProcess(s, r) {
  try {
    const o = void 0;
    return {
      key: s,
      ok: await r
    };
  } catch (r) {
    return {
      key: s,
      err: r
    };
  }
}

async function* processAllGeneratorTasksWithConcurrencyLimit(s, r) {
  const o = new Map;
  let u = 0, g = false;
  for (;o.size > 0 || !g; ) {
    e: for (;o.size < s && !g; ) {
      const s = await r.next();
      if (s.done) g = true;
      if (void 0 === s.value) break e;
      const _ = s.value;
      u++;
      const b = void 0, w = wrapEachProcess(u, isTaskWaiting(_) ? _() : _);
      o.set(u, w);
    }
    const _ = await Promise.race(o.values());
    o.delete(_.key);
    yield _;
  }
}

async function* pipeGeneratorToGenerator(s, r) {
  for await (const o of s) {
    const closure = () => r(o);
    yield closure;
  }
}

async function* processAllTasksWithConcurrencyLimit(s, r) {
  const o = new Map;
  let u = 0;
  const g = r.reverse();
  for (;g.length > 0 || o.size > 0; ) {
    e: for (;o.size < s && g.length > 0; ) {
      const s = g.pop();
      if (void 0 === s) break e;
      u++;
      const r = void 0, _ = wrapEachProcess(u, isTaskWaiting(s) ? s() : s);
      o.set(u, _);
    }
    const r = await Promise.race(o.values());
    o.delete(r.key);
    yield r;
  }
}

async function mapAllTasksWithConcurrencyLimit(s, r) {
  const o = new Map;
  for await (const u of processAllTasksWithConcurrencyLimit(s, r)) o.set(u.key, u);
  const u = void 0;
  return [ ...o.entries() ].sort(((s, r) => s[0] - r[0])).map((s => s[1]));
}

var isValidRemoteCouchDBURI = s => {
  if (s.startsWith("https://")) return true;
  if (s.startsWith("http://")) return true;
  return false;
};

function isCloudantURI(s) {
  if (-1 !== s.indexOf(".cloudantnosqldb.") || -1 !== s.indexOf(".cloudant.com")) return true;
  return false;
}

var checkRemoteVersion = async (s, r, o = VER) => {
  try {
    const u = await s.get(VERSIONINFO_DOCID);
    if ("versioninfo" != u.type) return false;
    const g = u.version;
    if (g < o) {
      const u = void 0;
      if (await r(g, o)) {
        await bumpRemoteVersion(s);
        return true;
      }
    }
    if (g == o) return true;
    return false;
  } catch (r) {
    if (isErrorOfMissingDoc(r)) {
      if (await bumpRemoteVersion(s)) return true;
      return false;
    }
    throw r;
  }
}, bumpRemoteVersion = async (s, r = VER) => {
  const o = {
    _id: VERSIONINFO_DOCID,
    version: r,
    type: "versioninfo"
  }, u = await resolveWithIgnoreKnownError(s.get(VERSIONINFO_DOCID), o);
  if ("versioninfo" != u.type) return false;
  o._rev = u._rev;
  await s.put(o);
  return true;
}, checkSyncInfo = async s => {
  try {
    const r = await s.get(SYNCINFO_ID);
    console.log(r);
    return true;
  } catch (r) {
    if (isErrorOfMissingDoc(r)) {
      const r = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", o = [ ...Array(30) ].map((s => Math.floor(Math.random() * r.length))).map((s => r[s])).join(""), u = {
        _id: SYNCINFO_ID,
        type: "syncinfo",
        data: o
      };
      if (await s.put(u)) return true;
      return false;
    } else {
      console.dir(r);
      return false;
    }
  }
};

async function putDesignDocuments(s) {
  const r = {
    _id: "_design/replicate",
    _rev: void 0,
    ver: 2,
    filters: {
      default: (function(s, r) {
        return !("remote" in s && s.remote);
      }).toString(),
      push: (function(s, r) {
        return true;
      }).toString(),
      pull: (function(s, r) {
        return !(s.type && "leaf" == s.type);
      }).toString()
    }
  };
  try {
    const o = await s.get(r._id);
    if (o.ver < r.ver) {
      r._rev = o._rev;
      await s.put(r);
      return true;
    }
  } catch (o) {
    if (isErrorOfMissingDoc(o)) {
      delete r._rev;
      await s.put(r);
      return true;
    } else Logger("Could not make design documents", LOG_LEVEL_INFO);
  }
  return false;
}

var enableEncryption = (s, r, o, u) => {
  const g = new Map;
  s.transform({
    incoming: async s => {
      const u = {
        ...s
      };
      if (isEncryptedChunkEntry(u) || isSyncInfoEntry(u)) try {
        u.data = await encrypt(u.data, r, o);
      } catch (s) {
        Logger("Encryption failed.", LOG_LEVEL_NOTICE);
        Logger(s);
        throw s;
      }
      if (isObfuscatedEntry(u)) try {
        u.path = await encrypt(getPath(u), r, o);
      } catch (s) {
        Logger("Encryption failed.", LOG_LEVEL_NOTICE);
        Logger(s);
        throw s;
      }
      return u;
    },
    outgoing: async s => {
      const _ = {
        ...s
      }, b = isEncryptedChunkEntry(_) || isSyncInfoEntry(_), w = isObfuscatedEntry(_);
      if (b || w) {
        if (u && g.has(_._id)) return _;
        try {
          if (b) _.data = await decrypt(_.data, r, o);
          if (w) _.path = await decrypt(getPath(_), r, o);
          if (u) g.set(_._id, true);
        } catch (s) {
          if (o) try {
            if (b) _.data = await decrypt(_.data, r, false);
            if (w) _.path = await decrypt(getPath(_), r, o);
            if (u) g.set(_._id, true);
          } catch (s) {
            if (u && "SyntaxError" == s.name) return _;
            Logger("Decryption failed.", LOG_LEVEL_NOTICE);
            Logger(s);
            throw s;
          } else {
            Logger("Decryption failed.", LOG_LEVEL_NOTICE);
            Logger(s);
            throw s;
          }
        }
      }
      return _;
    }
  });
};

function isErrorOfMissingDoc(s) {
  return 404 == (s && (null == s ? void 0 : s.status));
}

async function prepareChunkDesignDoc(s) {
  var r;
  const o = {
    _id: "_design/chunks",
    _rev: void 0,
    ver: 2,
    views: {
      collectDangling: {
        map: (function(s) {
          if (s._id.startsWith("h:")) emit([ s._id ], 0); else if ("children" in s) s.children.forEach((s => emit([ s ], 1)));
        }).toString(),
        reduce: "_sum"
      }
    }
  };
  let u = false;
  try {
    const g = await s.get(o._id);
    if (null != (r = null == g ? void 0 : g.ver) ? r : 0 < o.ver) {
      o._rev = g._rev;
      u = true;
    }
  } catch (s) {
    if (404 == s.status) u = true; else {
      Logger("Failed to make design document for operating chunks");
      Logger(s, LOG_LEVEL_VERBOSE);
      return false;
    }
  }
  try {
    if (u) await s.put(o);
  } catch (s) {
    Logger("Failed to make design document for operating chunks");
    Logger(s, LOG_LEVEL_VERBOSE);
    return false;
  }
  return true;
}

async function collectChunksUsage(s) {
  if (!await prepareChunkDesignDoc(s)) {
    Logger("Could not prepare design document for operating chunks");
    return [];
  }
  const r = void 0, o = void 0;
  return (await s.query("chunks/collectDangling", {
    reduce: true,
    group: true
  })).rows;
}

function collectUnreferencedChunks(s) {
  return collectChunks(s, "DANGLING");
}

async function collectChunks(s, r) {
  const o = await collectChunksUsage(s), u = void 0, g = ("ALL" == r ? o : o.filter((s => "DANGLING" == r ? 0 == s.value : 0 != s.value))).flatMap((s => s.key)), _ = void 0, b = void 0;
  return (await s.allDocs({
    keys: g
  })).rows.filter((s => !("error" in s))).map((s => ({
    id: s.id,
    rev: s.value.rev
  })));
}

async function collectUnbalancedChunkIDs(s, r) {
  const o = await collectChunks(s, "INUSE"), u = await collectChunks(r, "INUSE"), g = void 0, _ = void 0;
  return {
    onlyOnLocal: o.filter((s => !u.some((r => r.id == s.id)))),
    onlyOnRemote: u.filter((s => !o.some((r => r.id == s.id))))
  };
}

async function purgeChunksLocal(s, r) {
  await runWithLock("purge-local", false, (async () => {
    try {
      Logger(`Purging unused ${r.length} chunks `, LOG_LEVEL_NOTICE, "purge-local-backup");
      const o = arrayToChunkedArray(r, 100);
      let u = {
        ok: 0,
        exist: 0,
        error: 0
      };
      for (const r of o) {
        const o = void 0, g = (await s.allDocs({
          keys: r.map((s => s.id)),
          include_docs: true
        })).rows.filter((s => "doc" in s)).map((s => {
          const r = {
            ...s.doc
          };
          delete r._rev;
          r._id = `_local/${r._id}`;
          return r;
        })), _ = await s.bulkDocs(g);
        u = _.map((s => ({
          ok: "ok" in s ? 1 : 0,
          exist: "status" in s && 409 == s.status ? 1 : 0,
          error: "status" in s && 409 != s.status ? 1 : 0
        }))).reduce(((s, r) => ({
          ok: s.ok + r.ok,
          exist: s.exist + r.exist,
          error: s.error + r.error
        })), u);
        Logger(`Local chunk backed up: new:${u.ok} ,exist:${u.exist}, error:${u.error}`, LOG_LEVEL_NOTICE, "purge-local-backup");
        const b = _.filter((s => "error" in s && 409 != s.status));
        for (const s of b) Logger(`Failed to back up: ${s.id} / ${s.rev}`, LOG_LEVEL_VERBOSE);
      }
    } catch (s) {
      Logger("Could not back up chunks");
      Logger(s, LOG_LEVEL_VERBOSE);
    }
    Logger(`Purging unused ${r.length} chunks... `, LOG_LEVEL_NOTICE, "purge-local");
    const o = arrayToChunkedArray(r, 100);
    let u = 0;
    for (const g of o) {
      const o = await s.purgeMulti(g.map((s => [ s.id, s.rev ]))), _ = void 0;
      u += Object.values(o).filter((s => "ok" in s)).length;
      Logger(`Purging:  ${u} / ${r.length}`, LOG_LEVEL_NOTICE, "purge-local");
    }
    Logger(`Purging unused chunks done!: ${u} chunks has been deleted.`, LOG_LEVEL_NOTICE, "purge-local");
  }));
}

var _requestToCouchDBFetch = async (s, r, o, u, g, _) => {
  const b = String.fromCharCode.apply(null, (new TextEncoder).encode(`${r}:${o}`)), w = window.btoa(b), E = void 0, S = void 0, L = `${s}/${u}`, O = {
    url: L,
    method: _ || (g ? "PUT" : "GET"),
    headers: new Headers({
      authorization: "Basic " + w,
      "content-type": "application/json"
    }),
    contentType: "application/json",
    body: JSON.stringify(g)
  };
  return await fetch(L, O);
};

async function purgeChunksRemote(s, r) {
  await runWithLock("purge-remote", false, (async () => {
    const o = 100;
    function makeChunkedArrayFromArray(s) {
      const r = [];
      for (let u = 0; u < s.length; u += o) r.push(s.slice(u, u + o));
      return r;
    }
    const u = makeChunkedArrayFromArray(r);
    for (const r of u) {
      const o = await _requestToCouchDBFetch(`${s.couchDB_URI}/${s.couchDB_DBNAME}`, s.couchDB_USER, s.couchDB_PASSWORD, "_purge", r.reduce(((s, r) => ({
        ...s,
        [r.id]: [ r.rev ]
      })), {}), "POST");
      Logger(JSON.stringify(await o.json()), LOG_LEVEL_VERBOSE);
    }
    return;
  }));
}

function sizeToHumanReadable(s) {
  if (!s) return "-";
  const r = Math.floor(Math.log(s) / Math.log(1024));
  return Number.parseInt((s / Math.pow(1024, r)).toFixed(2)) + " " + [ "B", "kB", "MB", "GB", "TB" ][r];
}

async function purgeUnreferencedChunks(s, r, o, u = false) {
  const g = await s.info();
  let _ = 0;
  const getSize = function(s, r) {
    var o, u;
    return Number.parseInt(null != (u = null == (o = null == s ? void 0 : s.sizes) ? void 0 : o[r]) ? u : 0);
  }, b = o ? "-remote" : "-local";
  Logger(`${r ? "Counting" : "Cleaning"} ${o ? "remote" : "local"} database`, LOG_LEVEL_NOTICE);
  if (o) Logger(`Database active-size: ${sizeToHumanReadable(getSize(g, "active"))}, external-size:${sizeToHumanReadable(getSize(g, "external"))}, file-size: ${sizeToHumanReadable(getSize(g, "file"))}`, LOG_LEVEL_NOTICE);
  Logger(`Collecting unreferenced chunks on ${g.db_name}`, LOG_LEVEL_NOTICE, "gc-countchunk" + b);
  const w = await collectUnreferencedChunks(s);
  _ = w.length;
  if (0 == w.length) Logger(`No unreferenced chunks! ${g.db_name}`, LOG_LEVEL_NOTICE, "gc-countchunk" + b); else {
    Logger(`Number of unreferenced chunks on ${g.db_name}: ${w.length}`, LOG_LEVEL_NOTICE, "gc-countchunk" + b);
    if (r) {
      Logger(`DryRun of cleaning ${o ? "remote" : "local"} database up: Done`, LOG_LEVEL_NOTICE);
      return _;
    }
    if (o) {
      Logger("Cleaning unreferenced chunks on remote", LOG_LEVEL_NOTICE, "gc-purge" + b);
      await purgeChunksRemote(o, w);
    } else {
      Logger("Cleaning unreferenced chunks on local", LOG_LEVEL_NOTICE, "gc-purge" + b);
      await purgeChunksLocal(s, w);
    }
    Logger("Cleaning unreferenced chunks done!", LOG_LEVEL_NOTICE, "gc-purge" + b);
  }
  if (u) {
    Logger("Compacting database...", LOG_LEVEL_NOTICE, "gc-compact" + b);
    await s.compact();
    Logger("Compacting database done", LOG_LEVEL_NOTICE, "gc-compact" + b);
  }
  if (o) {
    const r = await s.info();
    Logger(`Processed database active-size: ${sizeToHumanReadable(getSize(r, "active"))}, external-size:${sizeToHumanReadable(getSize(r, "external"))}, file-size: ${sizeToHumanReadable(getSize(r, "file"))}`, LOG_LEVEL_NOTICE);
    Logger(`Reduced sizes: active-size: ${sizeToHumanReadable(getSize(g, "active") - getSize(r, "active"))}, external-size:${sizeToHumanReadable(getSize(g, "external") - getSize(r, "external"))}, file-size: ${sizeToHumanReadable(getSize(g, "file") - getSize(r, "file"))}`, LOG_LEVEL_NOTICE);
  }
  Logger(`Cleaning ${o ? "remote" : "local"} database up: Done`, LOG_LEVEL_NOTICE);
  return _;
}

function transferChunks(s, r, o, u, g) {
  const _ = arrayToChunkedArray(g, 25);
  let b = 0;
  const w = g.length, E = void 0;
  return [ ..._ ].map((g => async () => {
    const _ = g.length;
    try {
      const s = void 0, r = (await o.allDocs({
        keys: g.map((s => s.id)),
        include_docs: true
      })).rows.filter((s => !("error" in s))).map((s => s.doc));
      await u.bulkDocs(r, {
        new_edits: false
      });
    } catch (s) {
      Logger(`${r}: Something went wrong on balancing`, LOG_LEVEL_NOTICE);
      Logger(s, LOG_LEVEL_VERBOSE);
    } finally {
      b += _;
      Logger(`${r}: ${b} / ${w}`, LOG_LEVEL_NOTICE, "balance-" + s);
    }
  }));
}

async function balanceChunkPurgedDBs(s, r) {
  Logger("Complement missing chunks between databases", LOG_LEVEL_NOTICE);
  try {
    const {onlyOnLocal: o, onlyOnRemote: u} = await collectUnbalancedChunkIDs(s, r), g = transferChunks("l2r", "local -> remote", s, r, o), _ = transferChunks("r2l", "remote -> local", r, s, u);
    await mapAllTasksWithConcurrencyLimit(6, [ ...g, ..._ ]);
    Logger("local -> remote: Done", LOG_LEVEL_NOTICE, "balance-l2r");
    Logger("remote -> local: Done", LOG_LEVEL_NOTICE, "balance-r2l");
  } catch (s) {
    Logger("Something went wrong on balancing!", LOG_LEVEL_NOTICE);
    Logger(s, LOG_LEVEL_VERBOSE);
  }
  Logger("Complement completed!", LOG_LEVEL_NOTICE);
}

async function fetchAllUsedChunks(s, r) {
  try {
    const o = void 0, u = transferChunks("r2l", "remote -> local", r, s, await collectChunks(r, "INUSE"));
    await mapAllTasksWithConcurrencyLimit(3, u);
    Logger("remote -> local: Done", LOG_LEVEL_NOTICE, "balance-r2l");
  } catch (s) {
    Logger("Something went wrong on balancing!", LOG_LEVEL_NOTICE);
    Logger(s, LOG_LEVEL_VERBOSE);
  }
}

function resolveWithIgnoreKnownError(s, r) {
  return new Promise(((o, u) => {
    s.then(o).catch((s => isErrorOfMissingDoc(s) ? o(r) : u(s)));
  }));
}

var delay = s => new Promise((r => {
  setTimeout((() => {
    r();
  }), s);
})), Parallels = (s = new Set) => ({
  add: r => s.add(!!r.then((() => s.delete(r))).catch((() => s.delete(r))) && r),
  wait: r => s.size >= r && Promise.race(s),
  all: () => Promise.all(s)
});

function getDocData(s) {
  return "string" == typeof s ? s : s.join("");
}

function getDocDataAsArray(s) {
  return "string" == typeof s ? [ s ] : s;
}

var chunkCheckLen = 1e6;

function stringYielder(s) {
  return function* gen() {
    let r = "";
    for (const o of s) {
      r += o;
      for (;r.length > chunkCheckLen; ) {
        const s = r.slice(0, chunkCheckLen);
        r = r.substring(chunkCheckLen);
        yield s;
      }
    }
    if ("" != r) yield r;
    return;
  }();
}

function isDocContentSame(s, r) {
  const o = getDocDataAsArray(s), u = getDocDataAsArray(r), g = stringYielder(o), _ = stringYielder(u);
  let b, w;
  do {
    b = g.next();
    w = _.next();
    if (b.value != w.value) return false;
    if (b.done != w.done) return false;
  } while (!b.done);
  if (!w.done) return false;
  return true;
}

function isObfuscatedEntry(s) {
  if (s._id.startsWith(PREFIX_OBFUSCATED)) return true;
  return false;
}

function isEncryptedChunkEntry(s) {
  if (s._id.startsWith(PREFIX_ENCRYPTED_CHUNK)) return true;
  return false;
}

function isSyncInfoEntry(s) {
  if (s._id == SYNCINFO_ID) return true;
  return false;
}

function memorizeFuncWithLRUCache(s) {
  const r = new LRUCache(100, 1e5, true);
  return o => {
    const u = void 0;
    if (r.has(o)) return r.get(o);
    const g = s(o);
    r.set(o, g);
    return g;
  };
}

var traps = {};

function waitForSignal(s, r) {
  let o, u;
  const g = setTimeout((() => {
    if (s in traps) traps[s] = traps[s].filter((s => s != u));
    if (o) o(false);
    o = null;
  }), r);
  return new Promise((r => {
    if (!(s in traps)) traps[s] = [];
    o = r;
    u = () => {
      if (g) clearTimeout(g);
      r(true);
    };
    traps[s].push(u);
  }));
}

function sendSignal(s) {
  if (!(s in traps)) return;
  const r = traps[s];
  delete traps[s];
  for (const s of r) s();
}

var globalConcurrencyController = Semaphore(50), ExportedSet, ExportedMap;

function* arrayToChunkedArray(s, r) {
  const o = [ ...s ];
  for (;o.length; ) {
    const s = o.splice(0, r);
    yield s;
  }
}

function unique(s) {
  return [ ...new Set(s) ];
}

function mangle(s) {
  return "$" + s;
}

function unmangle(s) {
  return s.substring(1);
}

function Map$1() {
  this._store = {};
}

Map$1.prototype.get = function(s) {
  var r = mangle(s);
  return this._store[r];
};

Map$1.prototype.set = function(s, r) {
  var o = mangle(s);
  this._store[o] = r;
  return true;
};

Map$1.prototype.has = function(s) {
  var r;
  return mangle(s) in this._store;
};

Map$1.prototype.keys = function() {
  return Object.keys(this._store).map((s => unmangle(s)));
};

Map$1.prototype.delete = function(s) {
  var r = mangle(s), o = r in this._store;
  delete this._store[r];
  return o;
};

Map$1.prototype.forEach = function(s) {
  for (var r = Object.keys(this._store), o = 0, u = r.length; o < u; o++) {
    var g = r[o], _;
    s(this._store[g], g = unmangle(g));
  }
};

Object.defineProperty(Map$1.prototype, "size", {
  get: function() {
    return Object.keys(this._store).length;
  }
});

function Set$1(s) {
  this._store = new Map$1;
  if (s && Array.isArray(s)) for (var r = 0, o = s.length; r < o; r++) this.add(s[r]);
}

Set$1.prototype.add = function(s) {
  return this._store.set(s, true);
};

Set$1.prototype.has = function(s) {
  return this._store.has(s);
};

Set$1.prototype.forEach = function(s) {
  this._store.forEach((function(r, o) {
    s(o);
  }));
};

Object.defineProperty(Set$1.prototype, "size", {
  get: function() {
    return this._store.size;
  }
});

function supportsMapAndSet() {
  if ("undefined" == typeof Symbol || "undefined" == typeof Map || "undefined" == typeof Set) return false;
  var s = Object.getOwnPropertyDescriptor(Map, Symbol.species);
  return s && "get" in s && Map[Symbol.species] === Map;
}

if (supportsMapAndSet()) {
  ExportedSet = Set;
  ExportedMap = Map;
} else {
  ExportedSet = Set$1;
  ExportedMap = Map$1;
}

var import_immediate = __toESM(require_lib()), PouchError = class extends Error {
  constructor(s, r, o) {
    super();
    this.status = s;
    this.name = r;
    this.message = o;
    this.error = true;
  }
  toString() {
    return JSON.stringify({
      status: this.status,
      name: this.name,
      message: this.message,
      reason: this.reason
    });
  }
}, UNAUTHORIZED = new PouchError(401, "unauthorized", "Name or password is incorrect."), MISSING_BULK_DOCS = new PouchError(400, "bad_request", "Missing JSON list of 'docs'"), MISSING_DOC = new PouchError(404, "not_found", "missing"), REV_CONFLICT = new PouchError(409, "conflict", "Document update conflict"), INVALID_ID = new PouchError(400, "bad_request", "_id field must contain a string"), MISSING_ID = new PouchError(412, "missing_id", "_id is required for puts"), RESERVED_ID = new PouchError(400, "bad_request", "Only reserved document ids may start with underscore."), NOT_OPEN = new PouchError(412, "precondition_failed", "Database not open"), UNKNOWN_ERROR = new PouchError(500, "unknown_error", "Database encountered an unknown error"), BAD_ARG = new PouchError(500, "badarg", "Some query argument is invalid"), INVALID_REQUEST = new PouchError(400, "invalid_request", "Request was invalid"), QUERY_PARSE_ERROR = new PouchError(400, "query_parse_error", "Some query parameter is invalid"), DOC_VALIDATION = new PouchError(500, "doc_validation", "Bad special document member"), BAD_REQUEST = new PouchError(400, "bad_request", "Something wrong with the request"), NOT_AN_OBJECT = new PouchError(400, "bad_request", "Document must be a JSON object"), DB_MISSING = new PouchError(404, "not_found", "Database not found"), IDB_ERROR = new PouchError(500, "indexed_db_went_bad", "unknown"), WSQ_ERROR = new PouchError(500, "web_sql_went_bad", "unknown"), LDB_ERROR = new PouchError(500, "levelDB_went_went_bad", "unknown"), FORBIDDEN = new PouchError(403, "forbidden", "Forbidden by design doc validate_doc_update function"), INVALID_REV = new PouchError(400, "bad_request", "Invalid rev format"), FILE_EXISTS = new PouchError(412, "file_exists", "The database could not be created, the file already exists."), MISSING_STUB = new PouchError(412, "missing_stub", "A pre-existing attachment stub wasn't found"), INVALID_URL = new PouchError(413, "invalid_url", "Provided URL is invalid");

function createError(s, r) {
  function CustomPouchError(r) {
    for (var o = Object.getOwnPropertyNames(s), u = 0, g = o.length; u < g; u++) if ("function" != typeof s[o[u]]) this[o[u]] = s[o[u]];
    if (void 0 === this.stack) this.stack = (new Error).stack;
    if (void 0 !== r) this.reason = r;
  }
  CustomPouchError.prototype = PouchError.prototype;
  return new CustomPouchError(r);
}

function generateErrorFromResponse(s) {
  if ("object" != typeof s) {
    var r = s;
    (s = UNKNOWN_ERROR).data = r;
  }
  if ("error" in s && "conflict" === s.error) {
    s.name = "conflict";
    s.status = 409;
  }
  if (!("name" in s)) s.name = s.error || "unknown";
  if (!("status" in s)) s.status = 500;
  if (!("message" in s)) s.message = s.message || s.reason;
  if (!("stack" in s)) s.stack = (new Error).stack;
  return s;
}

var import_events = __toESM(require_events()), getRandomValues, rnds8 = new Uint8Array(16);

function rng() {
  if (!getRandomValues) if (!(getRandomValues = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}

var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(s) {
  return "string" == typeof s && regex_default.test(s);
}

var validate_default = validate, byteToHex = [], i;

for (i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));

function stringify(s) {
  var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, o = (byteToHex[s[r + 0]] + byteToHex[s[r + 1]] + byteToHex[s[r + 2]] + byteToHex[s[r + 3]] + "-" + byteToHex[s[r + 4]] + byteToHex[s[r + 5]] + "-" + byteToHex[s[r + 6]] + byteToHex[s[r + 7]] + "-" + byteToHex[s[r + 8]] + byteToHex[s[r + 9]] + "-" + byteToHex[s[r + 10]] + byteToHex[s[r + 11]] + byteToHex[s[r + 12]] + byteToHex[s[r + 13]] + byteToHex[s[r + 14]] + byteToHex[s[r + 15]]).toLowerCase();
  if (!validate_default(o)) throw TypeError("Stringified UUID is invalid");
  return o;
}

var stringify_default = stringify;

function v4(s, r, o) {
  var u = (s = s || {}).random || (s.rng || rng)();
  u[6] = 15 & u[6] | 64;
  u[8] = 63 & u[8] | 128;
  if (r) {
    o = o || 0;
    for (var g = 0; g < 16; ++g) r[o + g] = u[g];
    return r;
  }
  return stringify_default(u);
}

var v4_default = v4, thisAtob = function(s) {
  return atob(s);
}, thisBtoa = function(s) {
  return btoa(s);
};

function createBlob(s, r) {
  s = s || [];
  r = r || {};
  try {
    return new Blob(s, r);
  } catch (_) {
    if ("TypeError" !== _.name) throw _;
    for (var o, u = new ("undefined" != typeof BlobBuilder ? BlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder ? MozBlobBuilder : WebKitBlobBuilder), g = 0; g < s.length; g += 1) u.append(s[g]);
    return u.getBlob(r.type);
  }
}

function binaryStringToArrayBuffer(s) {
  for (var r = s.length, o = new ArrayBuffer(r), u = new Uint8Array(o), g = 0; g < r; g++) u[g] = s.charCodeAt(g);
  return o;
}

function binStringToBluffer(s, r) {
  return createBlob([ binaryStringToArrayBuffer(s) ], {
    type: r
  });
}

function b64ToBluffer(s, r) {
  return binStringToBluffer(thisAtob(s), r);
}

function arrayBufferToBinaryString(s) {
  for (var r = "", o = new Uint8Array(s), u = o.byteLength, g = 0; g < u; g++) r += String.fromCharCode(o[g]);
  return r;
}

function readAsBinaryString(s, r) {
  var o = new FileReader, u = "function" == typeof o.readAsBinaryString;
  o.onloadend = function(s) {
    var o = s.target.result || "";
    if (u) return r(o);
    r(arrayBufferToBinaryString(o));
  };
  if (u) o.readAsBinaryString(s); else o.readAsArrayBuffer(s);
}

function blobToBinaryString(s, r) {
  readAsBinaryString(s, (function(s) {
    r(s);
  }));
}

function blobToBase64(s, r) {
  blobToBinaryString(s, (function(s) {
    r(thisBtoa(s));
  }));
}

function readAsArrayBuffer(s, r) {
  var o = new FileReader;
  o.onloadend = function(s) {
    var o = s.target.result || new ArrayBuffer(0);
    r(o);
  };
  o.readAsArrayBuffer(s);
}

var import_spark_md5 = __toESM(require_spark_md5()), setImmediateShim = self.setImmediate || self.setTimeout, MD5_CHUNK_SIZE = 32768;

function rawToBase64(s) {
  return thisBtoa(s);
}

function sliceBlob(s, r, o) {
  if (s.webkitSlice) return s.webkitSlice(r, o);
  return s.slice(r, o);
}

function appendBlob(s, r, o, u, g) {
  if (o > 0 || u < r.size) r = sliceBlob(r, o, u);
  readAsArrayBuffer(r, (function(r) {
    s.append(r);
    g();
  }));
}

function appendString(s, r, o, u, g) {
  if (o > 0 || u < r.length) r = r.substring(o, u);
  s.appendBinary(r);
  g();
}

function binaryMd5(s, r) {
  var o = "string" == typeof s, u = o ? s.length : s.size, g = Math.min(MD5_CHUNK_SIZE, u), _ = Math.ceil(u / g), b = 0, w = o ? new import_spark_md5.default : new import_spark_md5.default.ArrayBuffer, E = o ? appendString : appendBlob;
  function next() {
    setImmediateShim(loadNextChunk);
  }
  function done() {
    var s, o = rawToBase64(w.end(true));
    r(o);
    w.destroy();
  }
  function loadNextChunk() {
    var r = b * g, o = r + g;
    if (++b < _) E(w, s, r, o, next); else E(w, s, r, o, done);
  }
  loadNextChunk();
}

function stringMd5(s) {
  return import_spark_md5.default.hash(s);
}

function isBinaryObject(s) {
  return "undefined" != typeof ArrayBuffer && s instanceof ArrayBuffer || "undefined" != typeof Blob && s instanceof Blob;
}

function cloneArrayBuffer(s) {
  if ("function" == typeof s.slice) return s.slice(0);
  var r = new ArrayBuffer(s.byteLength), o = new Uint8Array(r), u = new Uint8Array(s);
  o.set(u);
  return r;
}

function cloneBinaryObject(s) {
  if (s instanceof ArrayBuffer) return cloneArrayBuffer(s);
  var r = s.size, o = s.type;
  if ("function" == typeof s.slice) return s.slice(0, r, o);
  return s.webkitSlice(0, r, o);
}

var funcToString = Function.prototype.toString, objectCtorString = funcToString.call(Object);

function isPlainObject(s) {
  var r = Object.getPrototypeOf(s);
  if (null === r) return true;
  var o = r.constructor;
  return "function" == typeof o && o instanceof o && funcToString.call(o) == objectCtorString;
}

function clone(s) {
  var r, o, u;
  if (!s || "object" != typeof s) return s;
  if (Array.isArray(s)) {
    r = [];
    for (o = 0, u = s.length; o < u; o++) r[o] = clone(s[o]);
    return r;
  }
  if (s instanceof Date && isFinite(s)) return s.toISOString();
  if (isBinaryObject(s)) return cloneBinaryObject(s);
  if (!isPlainObject(s)) return s;
  r = {};
  for (o in s) if (Object.prototype.hasOwnProperty.call(s, o)) {
    var g = clone(s[o]);
    if ("undefined" != typeof g) r[o] = g;
  }
  return r;
}

function once(s) {
  var r = false;
  return function(...o) {
    if (r) throw new Error("once called more than once"); else {
      r = true;
      s.apply(this, o);
    }
  };
}

function toPromise(s) {
  return function(...r) {
    r = clone(r);
    var o = this, u = "function" == typeof r[r.length - 1] ? r.pop() : false, g = new Promise((function(u, g) {
      var _;
      try {
        var b = once((function(s, r) {
          if (s) g(s); else u(r);
        }));
        r.push(b);
        if ((_ = s.apply(o, r)) && "function" == typeof _.then) u(_);
      } catch (s) {
        g(s);
      }
    }));
    if (u) g.then((function(s) {
      u(null, s);
    }), u);
    return g;
  };
}

function logApiCall(s, r, o) {
  if (s.constructor.listeners("debug").length) {
    for (var u = [ "api", s.name, r ], g = 0; g < o.length - 1; g++) u.push(o[g]);
    s.constructor.emit("debug", u);
    var _ = o[o.length - 1];
    o[o.length - 1] = function(o, u) {
      var g = [ "api", s.name, r ];
      g = g.concat(o ? [ "error", o ] : [ "success", u ]);
      s.constructor.emit("debug", g);
      _(o, u);
    };
  }
}

function adapterFun(s, r) {
  return toPromise((function(...o) {
    if (this._closed) return Promise.reject(new Error("database is closed"));
    if (this._destroyed) return Promise.reject(new Error("database is destroyed"));
    var u = this;
    logApiCall(u, s, o);
    if (!this.taskqueue.isReady) return new Promise((function(r, g) {
      u.taskqueue.addTask((function(_) {
        if (_) g(_); else r(u[s].apply(u, o));
      }));
    }));
    return r.apply(this, o);
  }));
}

function pick(s, r) {
  for (var o = {}, u = 0, g = r.length; u < g; u++) {
    var _ = r[u];
    if (_ in s) o[_] = s[_];
  }
  return o;
}

var MAX_NUM_CONCURRENT_REQUESTS = 6, hasLocal;

function identityFunction(s) {
  return s;
}

function formatResultForOpenRevsGet(s) {
  return [ {
    ok: s
  } ];
}

function bulkGet(s, r, o) {
  var u = r.docs, g = new ExportedMap;
  u.forEach((function(s) {
    if (g.has(s.id)) g.get(s.id).push(s); else g.set(s.id, [ s ]);
  }));
  var _ = g.size, b = 0, w = new Array(_);
  function collapseResultsAndFinish() {
    var s = [];
    w.forEach((function(r) {
      r.docs.forEach((function(o) {
        s.push({
          id: r.id,
          docs: [ o ]
        });
      }));
    }));
    o(null, {
      results: s
    });
  }
  function checkDone() {
    if (++b === _) collapseResultsAndFinish();
  }
  function gotResult(s, r, o) {
    w[s] = {
      id: r,
      docs: o
    };
    checkDone();
  }
  var E = [];
  g.forEach((function(s, r) {
    E.push(r);
  }));
  var S = 0;
  function nextBatch() {
    if (S >= E.length) return;
    var s = Math.min(S + MAX_NUM_CONCURRENT_REQUESTS, E.length), r = E.slice(S, s);
    processBatch(r, S);
    S += r.length;
  }
  function processBatch(o, u) {
    o.forEach((function(o, _) {
      var b = u + _, w = g.get(o), E = pick(w[0], [ "atts_since", "attachments" ]);
      E.open_revs = w.map((function(s) {
        return s.rev;
      }));
      E.open_revs = E.open_revs.filter(identityFunction);
      var S = identityFunction;
      if (0 === E.open_revs.length) {
        delete E.open_revs;
        S = formatResultForOpenRevsGet;
      }
      [ "revs", "attachments", "binary", "ajax", "latest" ].forEach((function(s) {
        if (s in r) E[s] = r[s];
      }));
      s.get(o, E, (function(s, r) {
        var u;
        if (s) u = [ {
          error: s
        } ]; else u = S(r);
        gotResult(b, o, u);
        nextBatch();
      }));
    }));
  }
  nextBatch();
}

try {
  localStorage.setItem("_pouch_check_localstorage", 1);
  hasLocal = !!localStorage.getItem("_pouch_check_localstorage");
} catch (s) {
  hasLocal = false;
}

function hasLocalStorage() {
  return hasLocal;
}

var Changes = class extends import_events.default {
  constructor() {
    super();
    this._listeners = {};
    if (hasLocalStorage()) addEventListener("storage", (s => {
      this.emit(s.key);
    }));
  }
  addListener(s, r, o, u) {
    if (this._listeners[r]) return;
    var g = false, _ = this;
    function eventFunction() {
      if (!_._listeners[r]) return;
      if (g) {
        g = "waiting";
        return;
      }
      g = true;
      var s = pick(u, [ "style", "include_docs", "attachments", "conflicts", "filter", "doc_ids", "view", "since", "query_params", "binary", "return_docs" ]);
      function onError() {
        g = false;
      }
      o.changes(s).on("change", (function(s) {
        if (s.seq > u.since && !u.cancelled) {
          u.since = s.seq;
          u.onChange(s);
        }
      })).on("complete", (function() {
        if ("waiting" === g) (0, import_immediate.default)(eventFunction);
        g = false;
      })).on("error", onError);
    }
    this._listeners[r] = eventFunction;
    this.on(s, eventFunction);
  }
  removeListener(s, r) {
    if (!(r in this._listeners)) return;
    super.removeListener(s, this._listeners[r]);
    delete this._listeners[r];
  }
  notifyLocalWindows(s) {
    if (hasLocalStorage()) localStorage[s] = "a" === localStorage[s] ? "b" : "a";
  }
  notify(s) {
    this.emit(s);
    this.notifyLocalWindows(s);
  }
}, assign$1;

function guardedConsole(s) {
  if ("undefined" != typeof console && "function" == typeof console[s]) {
    var r = Array.prototype.slice.call(arguments, 1);
    console[s].apply(console, r);
  }
}

function randomNumber(s, r) {
  var o = 6e5, u, g;
  s = parseInt(s, 10) || 0;
  if ((r = parseInt(r, 10)) != r || r <= s) r = (s || 1) << 1; else r += 1;
  if (r > o) {
    s = 3e5;
    r = o;
  }
  return ~~((r - s) * Math.random() + s);
}

function defaultBackOff(s) {
  var r = 0;
  if (!s) r = 2e3;
  return randomNumber(s, r);
}

function explainError(s, r) {
  guardedConsole("info", "The above " + s + " is totally normal. " + r);
}

if ("function" == typeof Object.assign) assign$1 = Object.assign; else assign$1 = function(s) {
  for (var r = Object(s), o = 1; o < arguments.length; o++) {
    var u = arguments[o];
    if (null != u) for (var g in u) if (Object.prototype.hasOwnProperty.call(u, g)) r[g] = u[g];
  }
  return r;
};

var assign$2 = assign$1;

function tryFilter(s, r, o) {
  try {
    return !s(r, o);
  } catch (s) {
    var u = "Filter function threw: " + s.toString();
    return createError(BAD_REQUEST, u);
  }
}

function filterChange(s) {
  var r = {}, o = s.filter && "function" == typeof s.filter;
  r.query = s.query_params;
  return function filter3(u) {
    if (!u.doc) u.doc = {};
    var g = o && tryFilter(s.filter, u.doc, r);
    if ("object" == typeof g) return g;
    if (g) return false;
    if (!s.include_docs) delete u.doc; else if (!s.attachments) for (var _ in u.doc._attachments) if (Object.prototype.hasOwnProperty.call(u.doc._attachments, _)) u.doc._attachments[_].stub = true;
    return true;
  };
}

function flatten(s) {
  for (var r = [], o = 0, u = s.length; o < u; o++) r = r.concat(s[o]);
  return r;
}

function f() {}

var hasName = f.name, res;

if (hasName) res = function(s) {
  return s.name;
}; else res = function(s) {
  var r = s.toString().match(/^\s*function\s*(?:(\S+)\s*)?\(/);
  if (r && r[1]) return r[1]; else return "";
};

function invalidIdError(s) {
  var r;
  if (!s) r = createError(MISSING_ID); else if ("string" != typeof s) r = createError(INVALID_ID); else if (/^_/.test(s) && !/^_(design|local)/.test(s)) r = createError(RESERVED_ID);
  if (r) throw r;
}

function isRemote(s) {
  if ("boolean" == typeof s._remote) return s._remote;
  if ("function" == typeof s.type) {
    guardedConsole("warn", "db.type() is deprecated and will be removed in a future version of PouchDB");
    return "http" === s.type();
  }
  return false;
}

function listenerCount(s, r) {
  return "listenerCount" in s ? s.listenerCount(r) : import_events.default.listenerCount(s, r);
}

function parseDesignDocFunctionName(s) {
  if (!s) return null;
  var r = s.split("/");
  if (2 === r.length) return r;
  if (1 === r.length) return [ s, s ];
  return null;
}

function normalizeDesignDocFunctionName(s) {
  var r = parseDesignDocFunctionName(s);
  return r ? r.join("/") : null;
}

var keys = [ "source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor" ], qName = "queryKey", qParser = /(?:^|&)([^&=]*)=?([^&]*)/g, parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

function parseUri(s) {
  for (var r = parser.exec(s), o = {}, u = 14; u--; ) {
    var g = keys[u], _ = r[u] || "", b = -1 !== [ "user", "password" ].indexOf(g);
    o[g] = b ? decodeURIComponent(_) : _;
  }
  o[qName] = {};
  o[keys[12]].replace(qParser, (function(s, r, u) {
    if (r) o[qName][r] = u;
  }));
  return o;
}

function scopeEval(s, r) {
  var o = [], u = [];
  for (var g in r) if (Object.prototype.hasOwnProperty.call(r, g)) {
    o.push(g);
    u.push(r[g]);
  }
  o.push(s);
  return Function.apply(null, o).apply(null, u);
}

function upsert(s, r, o) {
  return s.get(r).catch((function(s) {
    if (404 !== s.status) throw s;
    return {};
  })).then((function(u) {
    var g = u._rev, _ = o(u);
    if (!_) return {
      updated: false,
      rev: g
    };
    _._id = r;
    _._rev = g;
    return tryAndPut(s, _, o);
  }));
}

function tryAndPut(s, r, o) {
  return s.put(r).then((function(s) {
    return {
      updated: true,
      rev: s.rev
    };
  }), (function(u) {
    if (409 !== u.status) throw u;
    return upsert(s, r._id, o);
  }));
}

function rev(s, r) {
  if (!r) return v4_default().replace(/-/g, "").toLowerCase();
  var o = assign$2({}, s);
  delete o._rev_tree;
  return stringMd5(JSON.stringify(o));
}

var uuid = v4_default;

function winningRev(s) {
  for (var r, o, u, g = s.rev_tree.slice(), _; _ = g.pop(); ) {
    var b = _.ids, w = b[2], E = _.pos;
    if (w.length) {
      for (var S = 0, L = w.length; S < L; S++) g.push({
        pos: E + 1,
        ids: w[S]
      });
      continue;
    }
    var O = !!b[1].deleted, D = b[0];
    if (!r || (u !== O ? u : o !== E ? o < E : r < D)) {
      r = D;
      o = E;
      u = O;
    }
  }
  return o + "-" + r;
}

function traverseRevTree(s, r) {
  for (var o = s.slice(), u; u = o.pop(); ) for (var g = u.pos, _ = u.ids, b = _[2], w = r(0 === b.length, g, _[0], u.ctx, _[1]), E = 0, S = b.length; E < S; E++) o.push({
    pos: g + 1,
    ids: b[E],
    ctx: w
  });
}

function sortByPos(s, r) {
  return s.pos - r.pos;
}

function collectLeaves(s) {
  var r = [];
  traverseRevTree(s, (function(s, o, u, g, _) {
    if (s) r.push({
      rev: o + "-" + u,
      pos: o,
      opts: _
    });
  }));
  r.sort(sortByPos).reverse();
  for (var o = 0, u = r.length; o < u; o++) delete r[o].pos;
  return r;
}

function collectConflicts(s) {
  for (var r = winningRev(s), o = collectLeaves(s.rev_tree), u = [], g = 0, _ = o.length; g < _; g++) {
    var b = o[g];
    if (b.rev !== r && !b.opts.deleted) u.push(b.rev);
  }
  return u;
}

function compactTree(s) {
  var r = [];
  traverseRevTree(s.rev_tree, (function(s, o, u, g, _) {
    if ("available" === _.status && !s) {
      r.push(o + "-" + u);
      _.status = "missing";
    }
  }));
  return r;
}

function findPathToLeaf(s, r) {
  let o = [];
  const u = s.slice();
  let g;
  for (;g = u.pop(); ) {
    const {pos: s, ids: _} = g, b = `${s}-${_[0]}`, w = _[2];
    o.push(b);
    if (b === r) {
      if (0 !== w.length) throw new Error("The requested revision is not a leaf");
      return o.reverse();
    }
    if (0 === w.length || w.length > 1) o = [];
    for (let r = 0, o = w.length; r < o; r++) u.push({
      pos: s + 1,
      ids: w[r]
    });
  }
  if (0 === o.length) throw new Error("The requested revision does not exist");
  return o.reverse();
}

function rootToLeaf(s) {
  for (var r = [], o = s.slice(), u; u = o.pop(); ) {
    var g = u.pos, _ = u.ids, b = _[0], w = _[1], E = _[2], S = 0 === E.length, L = u.history ? u.history.slice() : [];
    L.push({
      id: b,
      opts: w
    });
    if (S) r.push({
      pos: g + 1 - L.length,
      ids: L
    });
    for (var O = 0, D = E.length; O < D; O++) o.push({
      pos: g + 1,
      ids: E[O],
      history: L
    });
  }
  return r.reverse();
}

function sortByPos$1(s, r) {
  return s.pos - r.pos;
}

function binarySearch(s, r, o) {
  for (var u = 0, g = s.length, _; u < g; ) if (o(s[_ = u + g >>> 1], r) < 0) u = _ + 1; else g = _;
  return u;
}

function insertSorted(s, r, o) {
  var u = binarySearch(s, r, o);
  s.splice(u, 0, r);
}

function pathToTree(s, r) {
  for (var o, u, g = r, _ = s.length; g < _; g++) {
    var b = s[g], w = [ b.id, b.opts, [] ];
    if (u) {
      u[2].push(w);
      u = w;
    } else o = u = w;
  }
  return o;
}

function compareTree(s, r) {
  return s[0] < r[0] ? -1 : 1;
}

function mergeTree(s, r) {
  for (var o = [ {
    tree1: s,
    tree2: r
  } ], u = false; o.length > 0; ) {
    var g = o.pop(), _ = g.tree1, b = g.tree2;
    if (_[1].status || b[1].status) _[1].status = "available" === _[1].status || "available" === b[1].status ? "available" : "missing";
    for (var w = 0; w < b[2].length; w++) {
      if (!_[2][0]) {
        u = "new_leaf";
        _[2][0] = b[2][w];
        continue;
      }
      for (var E = false, S = 0; S < _[2].length; S++) if (_[2][S][0] === b[2][w][0]) {
        o.push({
          tree1: _[2][S],
          tree2: b[2][w]
        });
        E = true;
      }
      if (!E) {
        u = "new_branch";
        insertSorted(_[2], b[2][w], compareTree);
      }
    }
  }
  return {
    conflicts: u,
    tree: s
  };
}

function doMerge(s, r, o) {
  var u = [], g = false, _ = false, b;
  if (!s.length) return {
    tree: [ r ],
    conflicts: "new_leaf"
  };
  for (var w = 0, E = s.length; w < E; w++) {
    var S = s[w];
    if (S.pos === r.pos && S.ids[0] === r.ids[0]) {
      b = mergeTree(S.ids, r.ids);
      u.push({
        pos: S.pos,
        ids: b.tree
      });
      g = g || b.conflicts;
      _ = true;
    } else if (true !== o) {
      var L = S.pos < r.pos ? S : r, O = S.pos < r.pos ? r : S, D = O.pos - L.pos, k = [], C = [];
      C.push({
        ids: L.ids,
        diff: D,
        parent: null,
        parentIdx: null
      });
      for (;C.length > 0; ) {
        var T = C.pop();
        if (0 === T.diff) {
          if (T.ids[0] === O.ids[0]) k.push(T);
          continue;
        }
        for (var I = T.ids[2], A = 0, x = I.length; A < x; A++) C.push({
          ids: I[A],
          diff: T.diff - 1,
          parent: T.ids,
          parentIdx: A
        });
      }
      var R = k[0];
      if (!R) u.push(S); else {
        b = mergeTree(R.ids, O.ids);
        R.parent[2][R.parentIdx] = b.tree;
        u.push({
          pos: L.pos,
          ids: L.ids
        });
        g = g || b.conflicts;
        _ = true;
      }
    } else u.push(S);
  }
  if (!_) u.push(r);
  u.sort(sortByPos$1);
  return {
    tree: u,
    conflicts: g || "internal_node"
  };
}

function stem(s, r) {
  for (var o = rootToLeaf(s), u, g, _ = 0, b = o.length; _ < b; _++) {
    var w = o[_], E = w.ids, S;
    if (E.length > r) {
      if (!u) u = {};
      var L = E.length - r;
      S = {
        pos: w.pos + L,
        ids: pathToTree(E, L)
      };
      for (var O = 0; O < L; O++) {
        var D = w.pos + O + "-" + E[O].id;
        u[D] = true;
      }
    } else S = {
      pos: w.pos,
      ids: pathToTree(E, 0)
    };
    if (g) g = doMerge(g, S, true).tree; else g = [ S ];
  }
  if (u) traverseRevTree(g, (function(s, r, o) {
    delete u[r + "-" + o];
  }));
  return {
    tree: g,
    revs: u ? Object.keys(u) : []
  };
}

function merge(s, r, o) {
  var u = doMerge(s, r), g = stem(u.tree, o);
  return {
    tree: g.tree,
    stemmedRevs: g.revs,
    conflicts: u.conflicts
  };
}

function removeLeafFromRevTree(s, r) {
  return s.flatMap((s => (s = removeLeafFromPath(s, r)) ? [ s ] : []));
}

function removeLeafFromPath(s, r) {
  const o = clone(s), u = [ o ];
  let g;
  for (;g = u.pop(); ) {
    const {pos: s, ids: [_, , b], parent: w} = g, E = void 0, S = void 0;
    if (0 === b.length && `${s}-${_}` === r) {
      if (!w) return null;
      w.ids[2] = w.ids[2].filter((function(s) {
        return s[0] !== _;
      }));
      return o;
    }
    for (let r = 0, o = b.length; r < o; r++) u.push({
      pos: s + 1,
      ids: b[r],
      parent: g
    });
  }
  return o;
}

function revExists(s, r) {
  for (var o = s.slice(), u = r.split("-"), g = parseInt(u[0], 10), _ = u[1], b; b = o.pop(); ) {
    if (b.pos === g && b.ids[0] === _) return true;
    for (var w = b.ids[2], E = 0, S = w.length; E < S; E++) o.push({
      pos: b.pos + 1,
      ids: w[E]
    });
  }
  return false;
}

function getTrees(s) {
  return s.ids;
}

function isDeleted(s, r) {
  if (!r) r = winningRev(s);
  for (var o = r.substring(r.indexOf("-") + 1), u = s.rev_tree.map(getTrees), g; g = u.pop(); ) {
    if (g[0] === o) return !!g[1].deleted;
    u = u.concat(g[2]);
  }
}

function isLocalId(s) {
  return /^_local/.test(s);
}

function latest(s, r) {
  for (var o = r.rev_tree.slice(), u; u = o.pop(); ) {
    var g = u.pos, _ = u.ids, b = _[0], w = _[1], E = _[2], S = 0 === E.length, L = u.history ? u.history.slice() : [];
    L.push({
      id: b,
      pos: g,
      opts: w
    });
    if (S) for (var O = 0, D = L.length; O < D; O++) {
      var k = L[O], C;
      if (k.pos + "-" + k.id === s) return g + "-" + b;
    }
    for (var T = 0, I = E.length; T < I; T++) o.push({
      pos: g + 1,
      ids: E[T],
      history: L
    });
  }
  throw new Error("Unable to resolve latest revision for id " + r.id + ", rev " + s);
}

var import_events2 = __toESM(require_events()), a = "undefined" != typeof AbortController ? AbortController : function() {
  return {
    abort: function() {}
  };
}, f2 = fetch, h = Headers;

function pad(s, r, o) {
  for (var u = "", g = o - s.length; u.length < g; ) u += r;
  return u;
}

function padLeft(s, r, o) {
  var u;
  return pad(s, r, o) + s;
}

var MIN_MAGNITUDE = -324, MAGNITUDE_DIGITS = 3, SEP = "";

function collate(s, r) {
  if (s === r) return 0;
  s = normalizeKey(s);
  r = normalizeKey(r);
  var o = collationIndex(s), u = collationIndex(r);
  if (o - u != 0) return o - u;
  switch (typeof s) {
   case "number":
    return s - r;

   case "boolean":
    return s < r ? -1 : 1;

   case "string":
    return stringCollate(s, r);
  }
  return Array.isArray(s) ? arrayCollate(s, r) : objectCollate(s, r);
}

function normalizeKey(s) {
  switch (typeof s) {
   case "undefined":
    return null;

   case "number":
    if (s === 1 / 0 || s === -1 / 0 || isNaN(s)) return null;
    return s;

   case "object":
    var r = s;
    if (Array.isArray(s)) {
      var o = s.length;
      s = new Array(o);
      for (var u = 0; u < o; u++) s[u] = normalizeKey(r[u]);
    } else if (s instanceof Date) return s.toJSON(); else if (null !== s) {
      s = {};
      for (var g in r) if (Object.prototype.hasOwnProperty.call(r, g)) {
        var _ = r[g];
        if ("undefined" != typeof _) s[g] = normalizeKey(_);
      }
    }
  }
  return s;
}

function indexify(s) {
  if (null !== s) switch (typeof s) {
   case "boolean":
    return s ? 1 : 0;

   case "number":
    return numToIndexableString(s);

   case "string":
    return s.replace(/\u0002/g, "").replace(/\u0001/g, "").replace(/\u0000/g, "");

   case "object":
    var r = Array.isArray(s), o = r ? s : Object.keys(s), u = -1, g = o.length, _ = "";
    if (r) for (;++u < g; ) _ += toIndexableString(o[u]); else for (;++u < g; ) {
      var b = o[u];
      _ += toIndexableString(b) + toIndexableString(s[b]);
    }
    return _;
  }
  return "";
}

function toIndexableString(s) {
  var r = "\0";
  return collationIndex(s = normalizeKey(s)) + SEP + indexify(s) + r;
}

function parseNumber(s, r) {
  var o = r, u, g;
  if ("1" === s[r]) {
    u = 0;
    r++;
  } else {
    var _ = "0" === s[r];
    r++;
    var b = "", w = s.substring(r, r + MAGNITUDE_DIGITS), E = parseInt(w, 10) + MIN_MAGNITUDE;
    if (_) E = -E;
    r += MAGNITUDE_DIGITS;
    for (;;) {
      var S = s[r];
      if ("\0" === S) break; else b += S;
      r++;
    }
    if (1 === (b = b.split(".")).length) u = parseInt(b, 10); else u = parseFloat(b[0] + "." + b[1]);
    if (_) u -= 10;
    if (0 !== E) u = parseFloat(u + "e" + E);
  }
  return {
    num: u,
    length: r - o
  };
}

function pop(s, r) {
  var o = s.pop();
  if (r.length) {
    var u = r[r.length - 1];
    if (o === u.element) {
      r.pop();
      u = r[r.length - 1];
    }
    var g = u.element, _ = u.index;
    if (Array.isArray(g)) g.push(o); else if (_ === s.length - 2) {
      var b;
      g[s.pop()] = o;
    } else s.push(o);
  }
}

function parseIndexableString(s) {
  for (var r = [], o = [], u = 0; ;) {
    var g = s[u++];
    if ("\0" === g) if (1 === r.length) return r.pop(); else {
      pop(r, o);
      continue;
    }
    switch (g) {
     case "1":
      r.push(null);
      break;

     case "2":
      r.push("1" === s[u]);
      u++;
      break;

     case "3":
      var _ = parseNumber(s, u);
      r.push(_.num);
      u += _.length;
      break;

     case "4":
      for (var b = ""; ;) {
        var w = s[u];
        if ("\0" === w) break;
        b += w;
        u++;
      }
      b = b.replace(/\u0001\u0001/g, "\0").replace(/\u0001\u0002/g, "").replace(/\u0002\u0002/g, "");
      r.push(b);
      break;

     case "5":
      var E = {
        element: [],
        index: r.length
      };
      r.push(E.element);
      o.push(E);
      break;

     case "6":
      var S = {
        element: {},
        index: r.length
      };
      r.push(S.element);
      o.push(S);
      break;

     default:
      throw new Error("bad collationIndex or unexpectedly reached end of input: " + g);
    }
  }
}

function arrayCollate(s, r) {
  for (var o = Math.min(s.length, r.length), u = 0; u < o; u++) {
    var g = collate(s[u], r[u]);
    if (0 !== g) return g;
  }
  return s.length === r.length ? 0 : s.length > r.length ? 1 : -1;
}

function stringCollate(s, r) {
  return s === r ? 0 : s > r ? 1 : -1;
}

function objectCollate(s, r) {
  for (var o = Object.keys(s), u = Object.keys(r), g = Math.min(o.length, u.length), _ = 0; _ < g; _++) {
    var b = collate(o[_], u[_]);
    if (0 !== b) return b;
    if (0 !== (b = collate(s[o[_]], r[u[_]]))) return b;
  }
  return o.length === u.length ? 0 : o.length > u.length ? 1 : -1;
}

function collationIndex(s) {
  var r, o = [ "boolean", "number", "string", "object" ].indexOf(typeof s);
  if (~o) {
    if (null === s) return 1;
    if (Array.isArray(s)) return 5;
    return o < 3 ? o + 2 : o + 3;
  }
  if (Array.isArray(s)) return 5;
}

function numToIndexableString(s) {
  if (0 === s) return "1";
  var r = s.toExponential().split(/e\+?/), o = parseInt(r[1], 10), u = s < 0, g = u ? "0" : "2", _, b = padLeft(((u ? -o : o) - MIN_MAGNITUDE).toString(), "0", MAGNITUDE_DIGITS);
  g += SEP + b;
  var w = Math.abs(parseFloat(r[0]));
  if (u) w = 10 - w;
  var E = w.toFixed(20);
  E = E.replace(/\.?0+$/, "");
  return g += SEP + E;
}

function getFieldFromDoc(s, r) {
  for (var o = s, u = 0, g = r.length; u < g; u++) {
    var _;
    if (!(o = o[r[u]])) break;
  }
  return o;
}

function setFieldInDoc(s, r, o) {
  for (var u = 0, g = r.length; u < g - 1; u++) {
    var _ = r[u];
    s = s[_] = s[_] || {};
  }
  s[r[g - 1]] = o;
}

function compare(s, r) {
  return s < r ? -1 : s > r ? 1 : 0;
}

function parseField(s) {
  for (var r = [], o = "", u = 0, g = s.length; u < g; u++) {
    var _ = s[u];
    if (u > 0 && "\\" === s[u - 1] && ("$" === _ || "." === _)) o = o.substring(0, o.length - 1) + _; else if ("." === _) {
      r.push(o);
      o = "";
    } else o += _;
  }
  r.push(o);
  return r;
}

var combinationFields = [ "$or", "$nor", "$not" ];

function isCombinationalField(s) {
  return combinationFields.indexOf(s) > -1;
}

function getKey(s) {
  return Object.keys(s)[0];
}

function getValue(s) {
  return s[getKey(s)];
}

function mergeAndedSelectors(s) {
  var r = {}, o = {
    $or: true,
    $nor: true
  };
  s.forEach((function(s) {
    Object.keys(s).forEach((function(u) {
      var g = s[u];
      if ("object" != typeof g) g = {
        $eq: g
      };
      if (isCombinationalField(u)) if (g instanceof Array) {
        if (o[u]) {
          o[u] = false;
          r[u] = g;
          return;
        }
        var _ = [];
        r[u].forEach((function(s) {
          Object.keys(g).forEach((function(r) {
            var o = g[r], u = Math.max(Object.keys(s).length, Object.keys(o).length), b = mergeAndedSelectors([ s, o ]);
            if (Object.keys(b).length <= u) return;
            _.push(b);
          }));
        }));
        r[u] = _;
      } else r[u] = mergeAndedSelectors([ g ]); else {
        var b = r[u] = r[u] || {};
        Object.keys(g).forEach((function(s) {
          var r = g[s];
          if ("$gt" === s || "$gte" === s) return mergeGtGte(s, r, b); else if ("$lt" === s || "$lte" === s) return mergeLtLte(s, r, b); else if ("$ne" === s) return mergeNe(r, b); else if ("$eq" === s) return mergeEq(r, b); else if ("$regex" === s) return mergeRegex(r, b);
          b[s] = r;
        }));
      }
    }));
  }));
  return r;
}

function mergeGtGte(s, r, o) {
  if ("undefined" != typeof o.$eq) return;
  if ("undefined" != typeof o.$gte) {
    if ("$gte" === s) {
      if (r > o.$gte) o.$gte = r;
    } else if (r >= o.$gte) {
      delete o.$gte;
      o.$gt = r;
    }
  } else if ("undefined" != typeof o.$gt) {
    if ("$gte" === s) {
      if (r > o.$gt) {
        delete o.$gt;
        o.$gte = r;
      }
    } else if (r > o.$gt) o.$gt = r;
  } else o[s] = r;
}

function mergeLtLte(s, r, o) {
  if ("undefined" != typeof o.$eq) return;
  if ("undefined" != typeof o.$lte) {
    if ("$lte" === s) {
      if (r < o.$lte) o.$lte = r;
    } else if (r <= o.$lte) {
      delete o.$lte;
      o.$lt = r;
    }
  } else if ("undefined" != typeof o.$lt) {
    if ("$lte" === s) {
      if (r < o.$lt) {
        delete o.$lt;
        o.$lte = r;
      }
    } else if (r < o.$lt) o.$lt = r;
  } else o[s] = r;
}

function mergeNe(s, r) {
  if ("$ne" in r) r.$ne.push(s); else r.$ne = [ s ];
}

function mergeEq(s, r) {
  delete r.$gt;
  delete r.$gte;
  delete r.$lt;
  delete r.$lte;
  delete r.$ne;
  r.$eq = s;
}

function mergeRegex(s, r) {
  if ("$regex" in r) r.$regex.push(s); else r.$regex = [ s ];
}

function mergeAndedSelectorsNested(s) {
  for (var r in s) {
    if (Array.isArray(s)) for (var o in s) if (s[o]["$and"]) s[o] = mergeAndedSelectors(s[o]["$and"]);
    var u = s[r];
    if ("object" == typeof u) mergeAndedSelectorsNested(u);
  }
  return s;
}

function isAndInSelector(s, r) {
  for (var o in s) {
    if ("$and" === o) r = true;
    var u = s[o];
    if ("object" == typeof u) r = isAndInSelector(u, r);
  }
  return r;
}

function massageSelector(s) {
  var r = clone(s);
  if (isAndInSelector(r, false)) if ("$and" in (r = mergeAndedSelectorsNested(r))) r = mergeAndedSelectors(r["$and"]);
  [ "$or", "$nor" ].forEach((function(s) {
    if (s in r) r[s].forEach((function(s) {
      for (var r = Object.keys(s), o = 0; o < r.length; o++) {
        var u = r[o], g = s[u];
        if ("object" != typeof g || null === g) s[u] = {
          $eq: g
        };
      }
    }));
  }));
  if ("$not" in r) r["$not"] = mergeAndedSelectors([ r["$not"] ]);
  for (var o = Object.keys(r), u = 0; u < o.length; u++) {
    var g = o[u], _ = r[g];
    if ("object" != typeof _ || null === _) _ = {
      $eq: _
    };
    r[g] = _;
  }
  normalizeArrayOperators(r);
  return r;
}

function normalizeArrayOperators(s) {
  Object.keys(s).forEach((function(r) {
    var o = s[r];
    if (Array.isArray(o)) o.forEach((function(s) {
      if (s && "object" == typeof s) normalizeArrayOperators(s);
    })); else if ("$ne" === r) s.$ne = [ o ]; else if ("$regex" === r) s.$regex = [ o ]; else if (o && "object" == typeof o) normalizeArrayOperators(o);
  }));
}

function createFieldSorter(s) {
  function getFieldValuesAsArray(r) {
    return s.map((function(s) {
      var o, u = parseField(getKey(s)), g;
      return getFieldFromDoc(r, u);
    }));
  }
  return function(s, r) {
    var o, u, g = collate(getFieldValuesAsArray(s.doc), getFieldValuesAsArray(r.doc));
    if (0 !== g) return g;
    return compare(s.doc._id, r.doc._id);
  };
}

function filterInMemoryFields(s, r, o) {
  s = s.filter((function(s) {
    return rowFilter(s.doc, r.selector, o);
  }));
  if (r.sort) {
    var u = createFieldSorter(r.sort);
    s = s.sort(u);
    if ("string" != typeof r.sort[0] && "desc" === getValue(r.sort[0])) s = s.reverse();
  }
  if ("limit" in r || "skip" in r) {
    var g = r.skip || 0, _ = ("limit" in r ? r.limit : s.length) + g;
    s = s.slice(g, _);
  }
  return s;
}

function rowFilter(s, r, o) {
  return o.every((function(o) {
    var u = r[o], g = parseField(o), _ = getFieldFromDoc(s, g);
    if (isCombinationalField(o)) return matchCominationalSelector(o, u, s);
    return matchSelector(u, s, g, _);
  }));
}

function matchSelector(s, r, o, u) {
  if (!s) return true;
  if ("object" == typeof s) return Object.keys(s).every((function(g) {
    var _ = s[g];
    if (0 === g.indexOf("$")) return match2(g, r, _, o, u); else {
      var b = parseField(g);
      if (void 0 === u && "object" != typeof _ && b.length > 0) return false;
      var w = getFieldFromDoc(u, b);
      if ("object" == typeof _) return matchSelector(_, r, o, w);
      return match2("$eq", r, _, b, w);
    }
  }));
  return s === u;
}

function matchCominationalSelector(s, r, o) {
  if ("$or" === s) return r.some((function(s) {
    return rowFilter(o, s, Object.keys(s));
  }));
  if ("$not" === s) return !rowFilter(o, r, Object.keys(r));
  return !r.find((function(s) {
    return rowFilter(o, s, Object.keys(s));
  }));
}

function match2(s, r, o, u, g) {
  if (!matchers[s]) throw new Error('unknown operator "' + s + '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, $nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
  return matchers[s](r, o, u, g);
}

function fieldExists(s) {
  return "undefined" != typeof s && null !== s;
}

function fieldIsNotUndefined(s) {
  return "undefined" != typeof s;
}

function modField(s, r) {
  if ("number" != typeof s || parseInt(s, 10) !== s) return false;
  var o, u;
  return s % r[0] === r[1];
}

function arrayContainsValue(s, r) {
  return r.some((function(r) {
    if (s instanceof Array) return s.some((function(s) {
      return 0 === collate(r, s);
    }));
    return 0 === collate(r, s);
  }));
}

function arrayContainsAllValues(s, r) {
  return r.every((function(r) {
    return s.some((function(s) {
      return 0 === collate(r, s);
    }));
  }));
}

function arraySize(s, r) {
  return s.length === r;
}

function regexMatch(s, r) {
  var o;
  return new RegExp(r).test(s);
}

function typeMatch(s, r) {
  switch (r) {
   case "null":
    return null === s;

   case "boolean":
    return "boolean" == typeof s;

   case "number":
    return "number" == typeof s;

   case "string":
    return "string" == typeof s;

   case "array":
    return s instanceof Array;

   case "object":
    return "[object Object]" === {}.toString.call(s);
  }
}

var matchers = {
  $elemMatch: function(s, r, o, u) {
    if (!Array.isArray(u)) return false;
    if (0 === u.length) return false;
    if ("object" == typeof u[0] && null !== u[0]) return u.some((function(s) {
      return rowFilter(s, r, Object.keys(r));
    }));
    return u.some((function(u) {
      return matchSelector(r, s, o, u);
    }));
  },
  $allMatch: function(s, r, o, u) {
    if (!Array.isArray(u)) return false;
    if (0 === u.length) return false;
    if ("object" == typeof u[0] && null !== u[0]) return u.every((function(s) {
      return rowFilter(s, r, Object.keys(r));
    }));
    return u.every((function(u) {
      return matchSelector(r, s, o, u);
    }));
  },
  $eq: function(s, r, o, u) {
    return fieldIsNotUndefined(u) && 0 === collate(u, r);
  },
  $gte: function(s, r, o, u) {
    return fieldIsNotUndefined(u) && collate(u, r) >= 0;
  },
  $gt: function(s, r, o, u) {
    return fieldIsNotUndefined(u) && collate(u, r) > 0;
  },
  $lte: function(s, r, o, u) {
    return fieldIsNotUndefined(u) && collate(u, r) <= 0;
  },
  $lt: function(s, r, o, u) {
    return fieldIsNotUndefined(u) && collate(u, r) < 0;
  },
  $exists: function(s, r, o, u) {
    if (r) return fieldIsNotUndefined(u);
    return !fieldIsNotUndefined(u);
  },
  $mod: function(s, r, o, u) {
    return fieldExists(u) && modField(u, r);
  },
  $ne: function(s, r, o, u) {
    return r.every((function(s) {
      return 0 !== collate(u, s);
    }));
  },
  $in: function(s, r, o, u) {
    return fieldExists(u) && arrayContainsValue(u, r);
  },
  $nin: function(s, r, o, u) {
    return fieldExists(u) && !arrayContainsValue(u, r);
  },
  $size: function(s, r, o, u) {
    return fieldExists(u) && Array.isArray(u) && arraySize(u, r);
  },
  $all: function(s, r, o, u) {
    return Array.isArray(u) && arrayContainsAllValues(u, r);
  },
  $regex: function(s, r, o, u) {
    return fieldExists(u) && "string" == typeof u && r.every((function(s) {
      return regexMatch(u, s);
    }));
  },
  $type: function(s, r, o, u) {
    return typeMatch(u, r);
  }
};

function matchesSelector(s, r) {
  if ("object" != typeof r) throw new Error("Selector error: expected a JSON object");
  var o, u = filterInMemoryFields([ {
    doc: s
  } ], {
    selector: r = massageSelector(r)
  }, Object.keys(r));
  return u && 1 === u.length;
}

function evalFilter(s) {
  return scopeEval('"use strict";\nreturn ' + s + ";", {});
}

function evalView(s) {
  var r;
  return scopeEval([ "return function(doc) {", '  "use strict";', "  var emitted = false;", "  var emit = function (a, b) {", "    emitted = true;", "  };", "  var view = " + s + ";", "  view(doc);", "  if (emitted) {", "    return true;", "  }", "};" ].join("\n"), {});
}

function validate2(s, r) {
  if (s.selector) if (s.filter && "_selector" !== s.filter) {
    var o = "string" == typeof s.filter ? s.filter : "function";
    return r(new Error('selector invalid for filter "' + o + '"'));
  }
  r();
}

function normalize(s) {
  if (s.view && !s.filter) s.filter = "_view";
  if (s.selector && !s.filter) s.filter = "_selector";
  if (s.filter && "string" == typeof s.filter) if ("_view" === s.filter) s.view = normalizeDesignDocFunctionName(s.view); else s.filter = normalizeDesignDocFunctionName(s.filter);
}

function shouldFilter(s, r) {
  return r.filter && "string" == typeof r.filter && !r.doc_ids && !isRemote(s.db);
}

function filter2(s, r) {
  var o = r.complete;
  if ("_view" === r.filter) {
    if (!r.view || "string" != typeof r.view) {
      var u = createError(BAD_REQUEST, "`view` filter parameter not found or invalid.");
      return o(u);
    }
    var g = parseDesignDocFunctionName(r.view);
    s.db.get("_design/" + g[0], (function(u, _) {
      if (s.isCancelled) return o(null, {
        status: "cancelled"
      });
      if (u) return o(generateErrorFromResponse(u));
      var b = _ && _.views && _.views[g[1]] && _.views[g[1]].map;
      if (!b) return o(createError(MISSING_DOC, _.views ? "missing json key: " + g[1] : "missing json key: views"));
      r.filter = evalView(b);
      s.doChanges(r);
    }));
  } else if (r.selector) {
    r.filter = function(s) {
      return matchesSelector(s, r.selector);
    };
    s.doChanges(r);
  } else {
    var _ = parseDesignDocFunctionName(r.filter);
    s.db.get("_design/" + _[0], (function(u, g) {
      if (s.isCancelled) return o(null, {
        status: "cancelled"
      });
      if (u) return o(generateErrorFromResponse(u));
      var b = g && g.filters && g.filters[_[1]];
      if (!b) return o(createError(MISSING_DOC, g && g.filters ? "missing json key: " + _[1] : "missing json key: filters"));
      r.filter = evalFilter(b);
      s.doChanges(r);
    }));
  }
}

function applyChangesFilterPlugin(s) {
  s._changesFilterPlugin = {
    validate: validate2,
    normalize,
    shouldFilter,
    filter: filter2
  };
}

var index_browser_es_default = applyChangesFilterPlugin;

function tryCatchInChangeListener(s, r, o, u) {
  try {
    s.emit("change", r, o, u);
  } catch (s) {
    guardedConsole("error", 'Error in .on("change", function):', s);
  }
}

function processChange(s, r, o) {
  var u = [ {
    rev: s._rev
  } ];
  if ("all_docs" === o.style) u = collectLeaves(r.rev_tree).map((function(s) {
    return {
      rev: s.rev
    };
  }));
  var g = {
    id: r.id,
    changes: u,
    doc: s
  };
  if (isDeleted(r, s._rev)) g.deleted = true;
  if (o.conflicts) {
    g.doc._conflicts = collectConflicts(r);
    if (!g.doc._conflicts.length) delete g.doc._conflicts;
  }
  return g;
}

var Changes2 = class extends import_events2.default {
  constructor(s, r, o) {
    super();
    this.db = s;
    var u = (r = r ? clone(r) : {}).complete = once(((r, o) => {
      if (r) {
        if (listenerCount(this, "error") > 0) this.emit("error", r);
      } else this.emit("complete", o);
      this.removeAllListeners();
      s.removeListener("destroyed", onDestroy2);
    }));
    if (o) {
      this.on("complete", (function(s) {
        o(null, s);
      }));
      this.on("error", o);
    }
    const onDestroy2 = () => {
      this.cancel();
    };
    s.once("destroyed", onDestroy2);
    r.onChange = (s, r, o) => {
      if (this.isCancelled) return;
      tryCatchInChangeListener(this, s, r, o);
    };
    var g = new Promise((function(s, o) {
      r.complete = function(r, u) {
        if (r) o(r); else s(u);
      };
    }));
    this.once("cancel", (function() {
      s.removeListener("destroyed", onDestroy2);
      r.complete(null, {
        status: "cancelled"
      });
    }));
    this.then = g.then.bind(g);
    this["catch"] = g["catch"].bind(g);
    this.then((function(s) {
      u(null, s);
    }), u);
    if (!s.taskqueue.isReady) s.taskqueue.addTask((s => {
      if (s) r.complete(s); else if (this.isCancelled) this.emit("cancel"); else this.validateChanges(r);
    })); else this.validateChanges(r);
  }
  cancel() {
    this.isCancelled = true;
    if (this.db.taskqueue.isReady) this.emit("cancel");
  }
  validateChanges(s) {
    var r = s.complete;
    if (PouchDB._changesFilterPlugin) PouchDB._changesFilterPlugin.validate(s, (o => {
      if (o) return r(o);
      this.doChanges(s);
    })); else this.doChanges(s);
  }
  doChanges(s) {
    var r = s.complete;
    if ("live" in (s = clone(s)) && !("continuous" in s)) s.continuous = s.live;
    s.processChange = processChange;
    if ("latest" === s.since) s.since = "now";
    if (!s.since) s.since = 0;
    if ("now" === s.since) {
      this.db.info().then((o => {
        if (this.isCancelled) {
          r(null, {
            status: "cancelled"
          });
          return;
        }
        s.since = o.update_seq;
        this.doChanges(s);
      }), r);
      return;
    }
    if (PouchDB._changesFilterPlugin) {
      PouchDB._changesFilterPlugin.normalize(s);
      if (PouchDB._changesFilterPlugin.shouldFilter(this, s)) return PouchDB._changesFilterPlugin.filter(this, s);
    } else [ "doc_ids", "filter", "selector", "view" ].forEach((function(r) {
      if (r in s) guardedConsole("warn", 'The "' + r + '" option was passed in to changes/replicate, but pouchdb-changes-filter plugin is not installed, so it was ignored. Please install the plugin to enable filtering.');
    }));
    if (!("descending" in s)) s.descending = false;
    s.limit = 0 === s.limit ? 1 : s.limit;
    s.complete = r;
    var o = this.db._changes(s);
    if (o && "function" == typeof o.cancel) {
      const s = this.cancel;
      this.cancel = (...r) => {
        o.cancel();
        s.apply(this, r);
      };
    }
  }
};

function compare2(s, r) {
  return s < r ? -1 : s > r ? 1 : 0;
}

function yankError(s, r) {
  return function(o, u) {
    if (o || u[0] && u[0].error) {
      (o = o || u[0]).docId = r;
      s(o);
    } else s(null, u.length ? u[0] : u);
  };
}

function cleanDocs(s) {
  for (var r = 0; r < s.length; r++) {
    var o = s[r];
    if (o._deleted) delete o._attachments; else if (o._attachments) for (var u = Object.keys(o._attachments), g = 0; g < u.length; g++) {
      var _ = u[g];
      o._attachments[_] = pick(o._attachments[_], [ "data", "digest", "content_type", "length", "revpos", "stub" ]);
    }
  }
}

function compareByIdThenRev(s, r) {
  var o = compare2(s._id, r._id), u, g;
  if (0 !== o) return o;
  return compare2(s._revisions ? s._revisions.start : 0, r._revisions ? r._revisions.start : 0);
}

function computeHeight(s) {
  var r = {}, o = [];
  traverseRevTree(s, (function(s, u, g, _) {
    var b = u + "-" + g;
    if (s) r[b] = 0;
    if (void 0 !== _) o.push({
      from: _,
      to: b
    });
    return b;
  }));
  o.reverse();
  o.forEach((function(s) {
    if (void 0 === r[s.from]) r[s.from] = 1 + r[s.to]; else r[s.from] = Math.min(r[s.from], 1 + r[s.to]);
  }));
  return r;
}

function allDocsKeysParse(s) {
  var r = "limit" in s ? s.keys.slice(s.skip, s.limit + s.skip) : s.skip > 0 ? s.keys.slice(s.skip) : s.keys;
  s.keys = r;
  s.skip = 0;
  delete s.limit;
  if (s.descending) {
    r.reverse();
    s.descending = false;
  }
}

function doNextCompaction(s) {
  var r = s._compactionQueue[0], o = r.opts, u = r.callback;
  s.get("_local/compaction").catch((function() {
    return false;
  })).then((function(r) {
    if (r && r.last_seq) o.last_seq = r.last_seq;
    s._compact(o, (function(r, o) {
      if (r) u(r); else u(null, o);
      (0, import_immediate.default)((function() {
        s._compactionQueue.shift();
        if (s._compactionQueue.length) doNextCompaction(s);
      }));
    }));
  }));
}

function appendPurgeSeq(s, r, o) {
  return s.get("_local/purges").then((function(s) {
    const u = s.purgeSeq + 1;
    s.purges.push({
      docId: r,
      rev: o,
      purgeSeq: u
    });
    if (s.purges.length > self.purged_infos_limit) s.purges.splice(0, s.purges.length - self.purged_infos_limit);
    s.purgeSeq = u;
    return s;
  })).catch((function(s) {
    if (404 !== s.status) throw s;
    return {
      _id: "_local/purges",
      purges: [ {
        docId: r,
        rev: o,
        purgeSeq: 0
      } ],
      purgeSeq: 0
    };
  })).then((function(r) {
    return s.put(r);
  }));
}

function attachmentNameError(s) {
  if ("_" === s.charAt(0)) return s + " is not a valid attachment name, attachment names cannot start with '_'";
  return false;
}

var AbstractPouchDB = class extends import_events2.default {
  _setup() {
    this.post = adapterFun("post", (function(s, r, o) {
      if ("function" == typeof r) {
        o = r;
        r = {};
      }
      if ("object" != typeof s || Array.isArray(s)) return o(createError(NOT_AN_OBJECT));
      this.bulkDocs({
        docs: [ s ]
      }, r, yankError(o, s._id));
    })).bind(this);
    this.put = adapterFun("put", (function(s, r, o) {
      if ("function" == typeof r) {
        o = r;
        r = {};
      }
      if ("object" != typeof s || Array.isArray(s)) return o(createError(NOT_AN_OBJECT));
      invalidIdError(s._id);
      if (isLocalId(s._id) && "function" == typeof this._putLocal) if (s._deleted) return this._removeLocal(s, o); else return this._putLocal(s, o);
      const putDoc = o => {
        if ("function" == typeof this._put && false !== r.new_edits) this._put(s, r, o); else this.bulkDocs({
          docs: [ s ]
        }, r, yankError(o, s._id));
      };
      if (r.force && s._rev) {
        transformForceOptionToNewEditsOption();
        putDoc((function(r) {
          var u = r ? null : {
            ok: true,
            id: s._id,
            rev: s._rev
          };
          o(r, u);
        }));
      } else putDoc(o);
      function transformForceOptionToNewEditsOption() {
        var o = s._rev.split("-"), u = o[1], g, _ = parseInt(o[0], 10) + 1, b = rev();
        s._revisions = {
          start: _,
          ids: [ b, u ]
        };
        s._rev = _ + "-" + b;
        r.new_edits = false;
      }
    })).bind(this);
    this.putAttachment = adapterFun("putAttachment", (function(s, r, o, u, g) {
      var _ = this;
      if ("function" == typeof g) {
        g = u;
        u = o;
        o = null;
      }
      if ("undefined" == typeof g) {
        g = u;
        u = o;
        o = null;
      }
      if (!g) guardedConsole("warn", "Attachment", r, "on document", s, "is missing content_type");
      function createAttachment(s) {
        var o = "_rev" in s ? parseInt(s._rev, 10) : 0;
        s._attachments = s._attachments || {};
        s._attachments[r] = {
          content_type: g,
          data: u,
          revpos: ++o
        };
        return _.put(s);
      }
      return _.get(s).then((function(s) {
        if (s._rev !== o) throw createError(REV_CONFLICT);
        return createAttachment(s);
      }), (function(r) {
        if (r.reason === MISSING_DOC.message) return createAttachment({
          _id: s
        }); else throw r;
      }));
    })).bind(this);
    this.removeAttachment = adapterFun("removeAttachment", (function(s, r, o, u) {
      this.get(s, ((s, g) => {
        if (s) {
          u(s);
          return;
        }
        if (g._rev !== o) {
          u(createError(REV_CONFLICT));
          return;
        }
        if (!g._attachments) return u();
        delete g._attachments[r];
        if (0 === Object.keys(g._attachments).length) delete g._attachments;
        this.put(g, u);
      }));
    })).bind(this);
    this.remove = adapterFun("remove", (function(s, r, o, u) {
      var g;
      if ("string" == typeof r) {
        g = {
          _id: s,
          _rev: r
        };
        if ("function" == typeof o) {
          u = o;
          o = {};
        }
      } else {
        g = s;
        if ("function" == typeof r) {
          u = r;
          o = {};
        } else {
          u = o;
          o = r;
        }
      }
      (o = o || {}).was_delete = true;
      var _ = {
        _id: g._id,
        _rev: g._rev || o.rev,
        _deleted: true
      };
      if (isLocalId(_._id) && "function" == typeof this._removeLocal) return this._removeLocal(g, u);
      this.bulkDocs({
        docs: [ _ ]
      }, o, yankError(u, _._id));
    })).bind(this);
    this.revsDiff = adapterFun("revsDiff", (function(s, r, o) {
      if ("function" == typeof r) {
        o = r;
        r = {};
      }
      var u = Object.keys(s);
      if (!u.length) return o(null, {});
      var g = 0, _ = new ExportedMap;
      function addToMissing(s, r) {
        if (!_.has(s)) _.set(s, {
          missing: []
        });
        _.get(s).missing.push(r);
      }
      function processDoc(r, o) {
        var u = s[r].slice(0);
        traverseRevTree(o, (function(s, o, g, _, b) {
          var w = o + "-" + g, E = u.indexOf(w);
          if (-1 === E) return;
          u.splice(E, 1);
          if ("available" !== b.status) addToMissing(r, w);
        }));
        u.forEach((function(s) {
          addToMissing(r, s);
        }));
      }
      u.map((function(r) {
        this._getRevisionTree(r, (function(b, w) {
          if (b && 404 === b.status && "missing" === b.message) _.set(r, {
            missing: s[r]
          }); else if (b) return o(b); else processDoc(r, w);
          if (++g === u.length) {
            var E = {};
            _.forEach((function(s, r) {
              E[r] = s;
            }));
            return o(null, E);
          }
        }));
      }), this);
    })).bind(this);
    this.bulkGet = adapterFun("bulkGet", (function(s, r) {
      bulkGet(this, s, r);
    })).bind(this);
    this.compactDocument = adapterFun("compactDocument", (function(s, r, o) {
      this._getRevisionTree(s, ((u, g) => {
        if (u) return o(u);
        var _ = computeHeight(g), b = [], w = [];
        Object.keys(_).forEach((function(s) {
          if (_[s] > r) b.push(s);
        }));
        traverseRevTree(g, (function(s, r, o, u, g) {
          var _ = r + "-" + o;
          if ("available" === g.status && -1 !== b.indexOf(_)) w.push(_);
        }));
        this._doCompaction(s, w, o);
      }));
    })).bind(this);
    this.compact = adapterFun("compact", (function(s, r) {
      if ("function" == typeof s) {
        r = s;
        s = {};
      }
      s = s || {};
      this._compactionQueue = this._compactionQueue || [];
      this._compactionQueue.push({
        opts: s,
        callback: r
      });
      if (1 === this._compactionQueue.length) doNextCompaction(this);
    })).bind(this);
    this.get = adapterFun("get", (function(s, r, o) {
      if ("function" == typeof r) {
        o = r;
        r = {};
      }
      if ("string" != typeof s) return o(createError(INVALID_ID));
      if (isLocalId(s) && "function" == typeof this._getLocal) return this._getLocal(s, o);
      var u = [];
      const finishOpenRevs = () => {
        var g = [], _ = u.length;
        if (!_) return o(null, g);
        u.forEach((u => {
          this.get(s, {
            rev: u,
            revs: r.revs,
            latest: r.latest,
            attachments: r.attachments,
            binary: r.binary
          }, (function(s, r) {
            if (!s) {
              for (var b, w = 0, E = g.length; w < E; w++) if (g[w].ok && g[w].ok._rev === r._rev) {
                b = true;
                break;
              }
              if (!b) g.push({
                ok: r
              });
            } else g.push({
              missing: u
            });
            if (! --_) o(null, g);
          }));
        }));
      };
      if (r.open_revs) {
        if ("all" === r.open_revs) this._getRevisionTree(s, (function(s, r) {
          if (s) return o(s);
          u = collectLeaves(r).map((function(s) {
            return s.rev;
          }));
          finishOpenRevs();
        })); else if (Array.isArray(r.open_revs)) {
          u = r.open_revs;
          for (var g = 0; g < u.length; g++) {
            var _ = u[g];
            if (!("string" == typeof _ && /^\d+-/.test(_))) return o(createError(INVALID_REV));
          }
          finishOpenRevs();
        } else return o(createError(UNKNOWN_ERROR, "function_clause"));
        return;
      }
      return this._get(s, r, ((u, g) => {
        if (u) {
          u.docId = s;
          return o(u);
        }
        var _ = g.doc, b = g.metadata, w = g.ctx;
        if (r.conflicts) {
          var E = collectConflicts(b);
          if (E.length) _._conflicts = E;
        }
        if (isDeleted(b, _._rev)) _._deleted = true;
        if (r.revs || r.revs_info) {
          for (var S = _._rev.split("-"), L = parseInt(S[0], 10), O = S[1], D = rootToLeaf(b.rev_tree), k = null, C = 0; C < D.length; C++) {
            var T = D[C], I = T.ids.map((function(s) {
              return s.id;
            })).indexOf(O), A;
            if (I === L - 1 || !k && -1 !== I) k = T;
          }
          if (!k) {
            (u = new Error("invalid rev tree")).docId = s;
            return o(u);
          }
          var x = k.ids.map((function(s) {
            return s.id;
          })).indexOf(_._rev.split("-")[1]) + 1, R = k.ids.length - x;
          k.ids.splice(x, R);
          k.ids.reverse();
          if (r.revs) _._revisions = {
            start: k.pos + k.ids.length - 1,
            ids: k.ids.map((function(s) {
              return s.id;
            }))
          };
          if (r.revs_info) {
            var P = k.pos + k.ids.length;
            _._revs_info = k.ids.map((function(s) {
              return {
                rev: --P + "-" + s.id,
                status: s.opts.status
              };
            }));
          }
        }
        if (r.attachments && _._attachments) {
          var N = _._attachments, B = Object.keys(N).length;
          if (0 === B) return o(null, _);
          Object.keys(N).forEach((s => {
            this._getAttachment(_._id, s, N[s], {
              rev: _._rev,
              binary: r.binary,
              ctx: w
            }, (function(r, u) {
              var g = _._attachments[s];
              g.data = u;
              delete g.stub;
              delete g.length;
              if (! --B) o(null, _);
            }));
          }));
        } else {
          if (_._attachments) for (var F in _._attachments) if (Object.prototype.hasOwnProperty.call(_._attachments, F)) _._attachments[F].stub = true;
          o(null, _);
        }
      }));
    })).bind(this);
    this.getAttachment = adapterFun("getAttachment", (function(s, r, o, u) {
      if (o instanceof Function) {
        u = o;
        o = {};
      }
      this._get(s, o, ((g, _) => {
        if (g) return u(g);
        if (_.doc._attachments && _.doc._attachments[r]) {
          o.ctx = _.ctx;
          o.binary = true;
          this._getAttachment(s, r, _.doc._attachments[r], o, u);
        } else return u(createError(MISSING_DOC));
      }));
    })).bind(this);
    this.allDocs = adapterFun("allDocs", (function(s, r) {
      if ("function" == typeof s) {
        r = s;
        s = {};
      }
      s.skip = "undefined" != typeof s.skip ? s.skip : 0;
      if (s.start_key) s.startkey = s.start_key;
      if (s.end_key) s.endkey = s.end_key;
      if ("keys" in s) {
        if (!Array.isArray(s.keys)) return r(new TypeError("options.keys must be an array"));
        var o = [ "startkey", "endkey", "key" ].filter((function(r) {
          return r in s;
        }))[0];
        if (o) {
          r(createError(QUERY_PARSE_ERROR, "Query parameter `" + o + "` is not compatible with multi-get"));
          return;
        }
        if (!isRemote(this)) {
          allDocsKeysParse(s);
          if (0 === s.keys.length) return this._allDocs({
            limit: 0
          }, r);
        }
      }
      return this._allDocs(s, r);
    })).bind(this);
    this.close = adapterFun("close", (function(s) {
      this._closed = true;
      this.emit("closed");
      return this._close(s);
    })).bind(this);
    this.info = adapterFun("info", (function(s) {
      this._info(((r, o) => {
        if (r) return s(r);
        o.db_name = o.db_name || this.name;
        o.auto_compaction = !!(this.auto_compaction && !isRemote(this));
        o.adapter = this.adapter;
        s(null, o);
      }));
    })).bind(this);
    this.id = adapterFun("id", (function(s) {
      return this._id(s);
    })).bind(this);
    this.bulkDocs = adapterFun("bulkDocs", (function(s, r, o) {
      if ("function" == typeof r) {
        o = r;
        r = {};
      }
      r = r || {};
      if (Array.isArray(s)) s = {
        docs: s
      };
      if (!s || !s.docs || !Array.isArray(s.docs)) return o(createError(MISSING_BULK_DOCS));
      for (var u = 0; u < s.docs.length; ++u) if ("object" != typeof s.docs[u] || Array.isArray(s.docs[u])) return o(createError(NOT_AN_OBJECT));
      var g;
      s.docs.forEach((function(s) {
        if (s._attachments) Object.keys(s._attachments).forEach((function(r) {
          g = g || attachmentNameError(r);
          if (!s._attachments[r].content_type) guardedConsole("warn", "Attachment", r, "on document", s._id, "is missing content_type");
        }));
      }));
      if (g) return o(createError(BAD_REQUEST, g));
      if (!("new_edits" in r)) if ("new_edits" in s) r.new_edits = s.new_edits; else r.new_edits = true;
      var _ = this;
      if (!r.new_edits && !isRemote(_)) s.docs.sort(compareByIdThenRev);
      cleanDocs(s.docs);
      var b = s.docs.map((function(s) {
        return s._id;
      }));
      this._bulkDocs(s, r, (function(s, u) {
        if (s) return o(s);
        if (!r.new_edits) u = u.filter((function(s) {
          return s.error;
        }));
        if (!isRemote(_)) for (var g = 0, w = u.length; g < w; g++) u[g].id = u[g].id || b[g];
        o(null, u);
      }));
    })).bind(this);
    this.registerDependentDatabase = adapterFun("registerDependentDatabase", (function(s, r) {
      var o = clone(this.__opts);
      if (this.__opts.view_adapter) o.adapter = this.__opts.view_adapter;
      var u = new this.constructor(s, o);
      function diffFun(r) {
        r.dependentDbs = r.dependentDbs || {};
        if (r.dependentDbs[s]) return false;
        r.dependentDbs[s] = true;
        return r;
      }
      upsert(this, "_local/_pouch_dependentDbs", diffFun).then((function() {
        r(null, {
          db: u
        });
      })).catch(r);
    })).bind(this);
    this.destroy = adapterFun("destroy", (function(s, r) {
      if ("function" == typeof s) {
        r = s;
        s = {};
      }
      var o = "use_prefix" in this ? this.use_prefix : true;
      const destroyDb = () => {
        this._destroy(s, ((s, o) => {
          if (s) return r(s);
          this._destroyed = true;
          this.emit("destroyed");
          r(null, o || {
            ok: true
          });
        }));
      };
      if (isRemote(this)) return destroyDb();
      this.get("_local/_pouch_dependentDbs", ((s, u) => {
        if (s) if (404 !== s.status) return r(s); else return destroyDb();
        var g = u.dependentDbs, _ = this.constructor, b = Object.keys(g).map((s => {
          var r = o ? s.replace(new RegExp("^" + _.prefix), "") : s;
          return new _(r, this.__opts).destroy();
        }));
        Promise.all(b).then(destroyDb, r);
      }));
    })).bind(this);
  }
  _compact(s, r) {
    var o = {
      return_docs: false,
      last_seq: s.last_seq || 0
    }, u = [], g, _ = 0;
    const onChange = s => {
      this.activeTasks.update(g, {
        completed_items: ++_
      });
      u.push(this.compactDocument(s.id, 0));
    }, onError = s => {
      this.activeTasks.remove(g, s);
      r(s);
    }, onComplete = s => {
      var o = s.last_seq;
      Promise.all(u).then((() => upsert(this, "_local/compaction", (s => {
        if (!s.last_seq || s.last_seq < o) {
          s.last_seq = o;
          return s;
        }
        return false;
      })))).then((() => {
        this.activeTasks.remove(g);
        r(null, {
          ok: true
        });
      })).catch(onError);
    };
    this.info().then((s => {
      g = this.activeTasks.add({
        name: "database_compaction",
        total_items: s.update_seq - o.last_seq
      });
      this.changes(o).on("change", onChange).on("complete", onComplete).on("error", onError);
    }));
  }
  changes(s, r) {
    if ("function" == typeof s) {
      r = s;
      s = {};
    }
    (s = s || {}).return_docs = "return_docs" in s ? s.return_docs : !s.live;
    return new Changes2(this, s, r);
  }
  type() {
    return "function" == typeof this._type ? this._type() : this.adapter;
  }
};

AbstractPouchDB.prototype.purge = adapterFun("_purge", (function(s, r, o) {
  if ("undefined" == typeof this._purge) return o(createError(UNKNOWN_ERROR, "Purge is not implemented in the " + this.adapter + " adapter."));
  var u = this;
  u._getRevisionTree(s, ((g, _) => {
    if (g) return o(g);
    if (!_) return o(createError(MISSING_DOC));
    let b;
    try {
      b = findPathToLeaf(_, r);
    } catch (s) {
      return o(s.message || s);
    }
    u._purge(s, b, ((g, _) => {
      if (g) return o(g); else appendPurgeSeq(u, s, r).then((function() {
        return o(null, _);
      }));
    }));
  }));
}));

var TaskQueue = class {
  constructor() {
    this.isReady = false;
    this.failed = false;
    this.queue = [];
  }
  execute() {
    var s;
    if (this.failed) for (;s = this.queue.shift(); ) s(this.failed); else for (;s = this.queue.shift(); ) s();
  }
  fail(s) {
    this.failed = s;
    this.execute();
  }
  ready(s) {
    this.isReady = true;
    this.db = s;
    this.execute();
  }
  addTask(s) {
    this.queue.push(s);
    if (this.failed) this.execute();
  }
};

function parseAdapter(s, r) {
  var o = s.match(/([a-z-]*):\/\/(.*)/);
  if (o) return {
    name: /https?/.test(o[1]) ? o[1] + "://" + o[2] : o[2],
    adapter: o[1]
  };
  var u = PouchDB.adapters, g = PouchDB.preferredAdapters, _ = PouchDB.prefix, b = r.adapter;
  if (!b) for (var w = 0; w < g.length; ++w) {
    if ("idb" === (b = g[w]) && "websql" in u && hasLocalStorage() && localStorage["_pouch__websqldb_" + _ + s]) {
      guardedConsole("log", 'PouchDB is downgrading "' + s + '" to WebSQL to avoid data loss, because it was already opened with WebSQL.');
      continue;
    }
    break;
  }
  var E = u[b], S;
  return {
    name: (E && "use_prefix" in E ? E.use_prefix : true) ? _ + s : s,
    adapter: b
  };
}

function inherits(s, r) {
  s.prototype = Object.create(r.prototype, {
    constructor: {
      value: s
    }
  });
}

function createClass(s, r) {
  let klass = function(...s) {
    if (!(this instanceof klass)) return new klass(...s);
    r.apply(this, s);
  };
  inherits(klass, s);
  return klass;
}

function prepareForDestruction(s) {
  function onDestroyed(r) {
    s.removeListener("closed", onClosed);
    if (!r) s.constructor.emit("destroyed", s.name);
  }
  function onClosed() {
    s.removeListener("destroyed", onDestroyed);
    s.constructor.emit("unref", s);
  }
  s.once("destroyed", onDestroyed);
  s.once("closed", onClosed);
  s.constructor.emit("ref", s);
}

var PouchInternal = class extends AbstractPouchDB {
  constructor(s, r) {
    super();
    this._setup(s, r);
  }
  _setup(s, r) {
    super._setup();
    r = r || {};
    if (s && "object" == typeof s) {
      s = (r = s).name;
      delete r.name;
    }
    if (void 0 === r.deterministic_revs) r.deterministic_revs = true;
    this.__opts = r = clone(r);
    this.auto_compaction = r.auto_compaction;
    this.purged_infos_limit = r.purged_infos_limit || 1e3;
    this.prefix = PouchDB.prefix;
    if ("string" != typeof s) throw new Error("Missing/invalid DB name");
    var o, u = parseAdapter((r.prefix || "") + s, r);
    r.name = u.name;
    r.adapter = r.adapter || u.adapter;
    this.name = s;
    this._adapter = r.adapter;
    PouchDB.emit("debug", [ "adapter", "Picked adapter: ", r.adapter ]);
    if (!PouchDB.adapters[r.adapter] || !PouchDB.adapters[r.adapter].valid()) throw new Error("Invalid Adapter: " + r.adapter);
    if (r.view_adapter) if (!PouchDB.adapters[r.view_adapter] || !PouchDB.adapters[r.view_adapter].valid()) throw new Error("Invalid View Adapter: " + r.view_adapter);
    this.taskqueue = new TaskQueue;
    this.adapter = r.adapter;
    PouchDB.adapters[r.adapter].call(this, r, (s => {
      if (s) return this.taskqueue.fail(s);
      prepareForDestruction(this);
      this.emit("created", this);
      PouchDB.emit("created", this.name);
      this.taskqueue.ready(this);
    }));
  }
}, PouchDB = createClass(PouchInternal, (function(s, r) {
  PouchInternal.prototype._setup.call(this, s, r);
})), ActiveTasks = class {
  constructor() {
    this.tasks = {};
  }
  list() {
    return Object.values(this.tasks);
  }
  add(s) {
    const r = v4_default();
    this.tasks[r] = {
      id: r,
      name: s.name,
      total_items: s.total_items,
      created_at: (new Date).toJSON()
    };
    return r;
  }
  get(s) {
    return this.tasks[s];
  }
  remove(s, r) {
    delete this.tasks[s];
    return this.tasks;
  }
  update(s, r) {
    const o = this.tasks[s];
    if ("undefined" != typeof o) {
      const u = {
        id: o.id,
        name: o.name,
        created_at: o.created_at,
        total_items: r.total_items || o.total_items,
        completed_items: r.completed_items || o.completed_items,
        updated_at: (new Date).toJSON()
      };
      this.tasks[s] = u;
    }
    return this.tasks;
  }
};

PouchDB.adapters = {};

PouchDB.preferredAdapters = [];

PouchDB.prefix = "_pouch_";

var eventEmitter = new import_events2.default;

function setUpEventEmitter(s) {
  Object.keys(import_events2.default.prototype).forEach((function(r) {
    if ("function" == typeof import_events2.default.prototype[r]) s[r] = eventEmitter[r].bind(eventEmitter);
  }));
  var r = s._destructionListeners = new ExportedMap;
  s.on("ref", (function onConstructorRef(s) {
    if (!r.has(s.name)) r.set(s.name, []);
    r.get(s.name).push(s);
  }));
  s.on("unref", (function onConstructorUnref(s) {
    if (!r.has(s.name)) return;
    var o = r.get(s.name), u = o.indexOf(s);
    if (u < 0) return;
    o.splice(u, 1);
    if (o.length > 1) r.set(s.name, o); else r.delete(s.name);
  }));
  s.on("destroyed", (function onConstructorDestroyed(s) {
    if (!r.has(s)) return;
    var o = r.get(s);
    r.delete(s);
    o.forEach((function(s) {
      s.emit("destroyed", true);
    }));
  }));
}

setUpEventEmitter(PouchDB);

PouchDB.adapter = function(s, r, o) {
  if (r.valid()) {
    PouchDB.adapters[s] = r;
    if (o) PouchDB.preferredAdapters.push(s);
  }
};

PouchDB.plugin = function(s) {
  if ("function" == typeof s) s(PouchDB); else if ("object" != typeof s || 0 === Object.keys(s).length) throw new Error('Invalid plugin: got "' + s + '", expected an object or a function'); else Object.keys(s).forEach((function(r) {
    PouchDB.prototype[r] = s[r];
  }));
  if (this.__defaults) PouchDB.__defaults = assign$2({}, this.__defaults);
  return PouchDB;
};

PouchDB.defaults = function(s) {
  let r = createClass(PouchDB, (function(s, o) {
    o = o || {};
    if (s && "object" == typeof s) {
      s = (o = s).name;
      delete o.name;
    }
    o = assign$2({}, r.__defaults, o);
    PouchDB.call(this, s, o);
  }));
  r.preferredAdapters = PouchDB.preferredAdapters.slice();
  Object.keys(PouchDB).forEach((function(s) {
    if (!(s in r)) r[s] = PouchDB[s];
  }));
  r.__defaults = assign$2({}, this.__defaults, s);
  return r;
};

PouchDB.fetch = function(s, r) {
  return f2(s, r);
};

PouchDB.prototype.activeTasks = PouchDB.activeTasks = new ActiveTasks;

var version = "8.0.1";

PouchDB.plugin(index_browser_es_default);

PouchDB.version = version;

var index_es_default = PouchDB;

function toObject(s) {
  return s.reduce((function(s, r) {
    s[r] = true;
    return s;
  }), {});
}

var reservedWords = toObject([ "_id", "_rev", "_access", "_attachments", "_deleted", "_revisions", "_revs_info", "_conflicts", "_deleted_conflicts", "_local_seq", "_rev_tree", "_replication_id", "_replication_state", "_replication_state_time", "_replication_state_reason", "_replication_stats", "_removed" ]), dataWords = toObject([ "_access", "_attachments", "_replication_id", "_replication_state", "_replication_state_time", "_replication_state_reason", "_replication_stats" ]);

function parseRevisionInfo(s) {
  if (!/^\d+-/.test(s)) return createError(INVALID_REV);
  var r = s.indexOf("-"), o = s.substring(0, r), u = s.substring(r + 1);
  return {
    prefix: parseInt(o, 10),
    id: u
  };
}

function makeRevTreeFromRevisions(s, r) {
  for (var o = s.start - s.ids.length + 1, u = s.ids, g = [ u[0], r, [] ], _ = 1, b = u.length; _ < b; _++) g = [ u[_], {
    status: "missing"
  }, [ g ] ];
  return [ {
    pos: o,
    ids: g
  } ];
}

function parseDoc(s, r, o) {
  if (!o) o = {
    deterministic_revs: true
  };
  var u, g, _, b = {
    status: "available"
  };
  if (s._deleted) b.deleted = true;
  if (r) {
    if (!s._id) s._id = uuid();
    g = rev(s, o.deterministic_revs);
    if (s._rev) {
      if ((_ = parseRevisionInfo(s._rev)).error) return _;
      s._rev_tree = [ {
        pos: _.prefix,
        ids: [ _.id, {
          status: "missing"
        }, [ [ g, b, [] ] ] ]
      } ];
      u = _.prefix + 1;
    } else {
      s._rev_tree = [ {
        pos: 1,
        ids: [ g, b, [] ]
      } ];
      u = 1;
    }
  } else {
    if (s._revisions) {
      s._rev_tree = makeRevTreeFromRevisions(s._revisions, b);
      u = s._revisions.start;
      g = s._revisions.ids[0];
    }
    if (!s._rev_tree) {
      if ((_ = parseRevisionInfo(s._rev)).error) return _;
      u = _.prefix;
      g = _.id;
      s._rev_tree = [ {
        pos: u,
        ids: [ g, b, [] ]
      } ];
    }
  }
  invalidIdError(s._id);
  s._rev = u + "-" + g;
  var w = {
    metadata: {},
    data: {}
  };
  for (var E in s) if (Object.prototype.hasOwnProperty.call(s, E)) {
    var S = "_" === E[0];
    if (S && !reservedWords[E]) {
      var L = createError(DOC_VALIDATION, E);
      L.message = DOC_VALIDATION.message + ": " + E;
      throw L;
    } else if (S && !dataWords[E]) w.metadata[E.slice(1)] = s[E]; else w.data[E] = s[E];
  }
  return w;
}

function parseBase64(s) {
  try {
    return thisAtob(s);
  } catch (s) {
    var r;
    return {
      error: createError(BAD_ARG, "Attachment is not a valid base64 string")
    };
  }
}

function preprocessString(s, r, o) {
  var u = parseBase64(s.data);
  if (u.error) return o(u.error);
  s.length = u.length;
  if ("blob" === r) s.data = binStringToBluffer(u, s.content_type); else if ("base64" === r) s.data = thisBtoa(u); else s.data = u;
  binaryMd5(u, (function(r) {
    s.digest = "md5-" + r;
    o();
  }));
}

function preprocessBlob(s, r, o) {
  binaryMd5(s.data, (function(u) {
    s.digest = "md5-" + u;
    s.length = s.data.size || s.data.length || 0;
    if ("binary" === r) blobToBinaryString(s.data, (function(r) {
      s.data = r;
      o();
    })); else if ("base64" === r) blobToBase64(s.data, (function(r) {
      s.data = r;
      o();
    })); else o();
  }));
}

function preprocessAttachment(s, r, o) {
  if (s.stub) return o();
  if ("string" == typeof s.data) preprocessString(s, r, o); else preprocessBlob(s, r, o);
}

function preprocessAttachments(s, r, o) {
  if (!s.length) return o();
  var u = 0, g;
  s.forEach((function(s) {
    var o = s.data && s.data._attachments ? Object.keys(s.data._attachments) : [], u = 0;
    if (!o.length) return done();
    function processedAttachment(s) {
      g = s;
      if (++u === o.length) done();
    }
    for (var _ in s.data._attachments) if (Object.prototype.hasOwnProperty.call(s.data._attachments, _)) preprocessAttachment(s.data._attachments[_], r, processedAttachment);
  }));
  function done() {
    u++;
    if (s.length === u) if (g) o(g); else o();
  }
}

function updateDoc(s, r, o, u, g, _, b, w) {
  if (revExists(r.rev_tree, o.metadata.rev) && !w) {
    u[g] = o;
    return _();
  }
  var E = r.winningRev || winningRev(r), S = "deleted" in r ? r.deleted : isDeleted(r, E), L = "deleted" in o.metadata ? o.metadata.deleted : isDeleted(o.metadata), O = /^1-/.test(o.metadata.rev);
  if (S && !L && w && O) {
    var D = o.data;
    D._rev = E;
    D._id = o.metadata.id;
    o = parseDoc(D, w);
  }
  var k = merge(r.rev_tree, o.metadata.rev_tree[0], s), C;
  if (w && (S && L && "new_leaf" !== k.conflicts || !S && "new_leaf" !== k.conflicts || S && !L && "new_branch" === k.conflicts)) {
    var T = createError(REV_CONFLICT);
    u[g] = T;
    return _();
  }
  var I = o.metadata.rev;
  o.metadata.rev_tree = k.tree;
  o.stemmedRevs = k.stemmedRevs || [];
  if (r.rev_map) o.metadata.rev_map = r.rev_map;
  var A = winningRev(o.metadata), x = isDeleted(o.metadata, A), R = S === x ? 0 : S < x ? -1 : 1, P;
  if (I === A) P = x; else P = isDeleted(o.metadata, I);
  b(o, A, x, P, true, R, g, _);
}

function rootIsMissing(s) {
  return "missing" === s.metadata.rev_tree[0].ids[1].status;
}

function processDocs(s, r, o, u, g, _, b, w, E) {
  s = s || 1e3;
  function insertDoc(s, r, o) {
    var u = winningRev(s.metadata), g = isDeleted(s.metadata, u), E, L;
    if ("was_delete" in w && g) {
      _[r] = createError(MISSING_DOC, "deleted");
      return o();
    }
    if (S && rootIsMissing(s)) {
      var O = createError(REV_CONFLICT);
      _[r] = O;
      return o();
    }
    b(s, u, g, g, false, g ? 0 : 1, r, o);
  }
  var S = w.new_edits, L = new ExportedMap, O = 0, D = r.length;
  function checkAllDocsDone() {
    if (++O === D && E) E();
  }
  r.forEach((function(s, r) {
    if (s._id && isLocalId(s._id)) {
      var u = s._deleted ? "_removeLocal" : "_putLocal";
      o[u](s, {
        ctx: g
      }, (function(s, o) {
        _[r] = s || o;
        checkAllDocsDone();
      }));
      return;
    }
    var b = s.metadata.id;
    if (L.has(b)) {
      D--;
      L.get(b).push([ s, r ]);
    } else L.set(b, [ [ s, r ] ]);
  }));
  L.forEach((function(r, o) {
    var g = 0;
    function docWritten() {
      if (++g < r.length) nextDoc(); else checkAllDocsDone();
    }
    function nextDoc() {
      var w = r[g], E = w[0], L = w[1];
      if (u.has(o)) updateDoc(s, u.get(o), E, _, L, docWritten, b, S); else {
        var O = merge([], E.metadata.rev_tree[0], s);
        E.metadata.rev_tree = O.tree;
        E.stemmedRevs = O.stemmedRevs || [];
        insertDoc(E, L, docWritten);
      }
    }
    nextDoc();
  }));
}

var import_vuvuzela = __toESM(require_vuvuzela());

function safeJsonParse(s) {
  try {
    return JSON.parse(s);
  } catch (r) {
    return import_vuvuzela.default.parse(s);
  }
}

function safeJsonStringify(s) {
  try {
    return JSON.stringify(s);
  } catch (r) {
    return import_vuvuzela.default.stringify(s);
  }
}

var ADAPTER_VERSION = 5, DOC_STORE = "document-store", BY_SEQ_STORE = "by-sequence", ATTACH_STORE = "attach-store", ATTACH_AND_SEQ_STORE = "attach-seq-store", META_STORE = "meta-store", LOCAL_STORE = "local-store", DETECT_BLOB_SUPPORT_STORE = "detect-blob-support";

function idbError(s) {
  return function(r) {
    var o = "unknown_error";
    if (r.target && r.target.error) o = r.target.error.name || r.target.error.message;
    s(createError(IDB_ERROR, o, r.type));
  };
}

function encodeMetadata(s, r, o) {
  return {
    data: safeJsonStringify(s),
    winningRev: r,
    deletedOrLocal: o ? "1" : "0",
    seq: s.seq,
    id: s.id
  };
}

function decodeMetadata(s) {
  if (!s) return null;
  var r = safeJsonParse(s.data);
  r.winningRev = s.winningRev;
  r.deleted = "1" === s.deletedOrLocal;
  r.seq = s.seq;
  return r;
}

function decodeDoc(s) {
  if (!s) return s;
  var r = s._doc_id_rev.lastIndexOf(":");
  s._id = s._doc_id_rev.substring(0, r - 1);
  s._rev = s._doc_id_rev.substring(r + 1);
  delete s._doc_id_rev;
  return s;
}

function readBlobData(s, r, o, u) {
  if (o) if (!s) u(createBlob([ "" ], {
    type: r
  })); else if ("string" != typeof s) u(s); else u(b64ToBluffer(s, r)); else if (!s) u(""); else if ("string" != typeof s) readAsBinaryString(s, (function(s) {
    u(thisBtoa(s));
  })); else u(s);
}

function fetchAttachmentsIfNecessary(s, r, o, u) {
  var g = Object.keys(s._attachments || {});
  if (!g.length) return u && u();
  var _ = 0;
  function checkDone() {
    if (++_ === g.length && u) u();
  }
  function fetchAttachment(s, r) {
    var u = s._attachments[r], g = u.digest, _;
    o.objectStore(ATTACH_STORE).get(g).onsuccess = function(s) {
      u.body = s.target.result.body;
      checkDone();
    };
  }
  g.forEach((function(o) {
    if (r.attachments && r.include_docs) fetchAttachment(s, o); else {
      s._attachments[o].stub = true;
      checkDone();
    }
  }));
}

function postProcessAttachments(s, r) {
  return Promise.all(s.map((function(s) {
    if (s.doc && s.doc._attachments) {
      var o = Object.keys(s.doc._attachments);
      return Promise.all(o.map((function(o) {
        var u = s.doc._attachments[o];
        if (!("body" in u)) return;
        var g = u.body, _ = u.content_type;
        return new Promise((function(b) {
          readBlobData(g, _, r, (function(r) {
            s.doc._attachments[o] = assign$2(pick(u, [ "digest", "content_type" ]), {
              data: r
            });
            b();
          }));
        }));
      })));
    }
  })));
}

function compactRevs(s, r, o) {
  var u = [], g = o.objectStore(BY_SEQ_STORE), _ = o.objectStore(ATTACH_STORE), b = o.objectStore(ATTACH_AND_SEQ_STORE), w = s.length;
  function checkDone() {
    if (! --w) deleteOrphanedAttachments();
  }
  function deleteOrphanedAttachments() {
    if (!u.length) return;
    u.forEach((function(s) {
      var r;
      b.index("digestSeq").count(IDBKeyRange.bound(s + "::", s + "::￿", false, false)).onsuccess = function(r) {
        var o;
        if (!r.target.result) _.delete(s);
      };
    }));
  }
  s.forEach((function(s) {
    var o = g.index("_doc_id_rev"), _ = r + "::" + s;
    o.getKey(_).onsuccess = function(s) {
      var r = s.target.result, o;
      if ("number" != typeof r) return checkDone();
      g.delete(r);
      b.index("seq").openCursor(IDBKeyRange.only(r)).onsuccess = function(s) {
        var r = s.target.result;
        if (r) {
          var o = r.value.digestSeq.split("::")[0];
          u.push(o);
          b.delete(r.primaryKey);
          r.continue();
        } else checkDone();
      };
    };
  }));
}

function openTransactionSafely(s, r, o) {
  try {
    return {
      txn: s.transaction(r, o)
    };
  } catch (s) {
    return {
      error: s
    };
  }
}

var changesHandler$1 = new Changes;

function idbBulkDocs(s, r, o, u, g, _) {
  for (var b = r.docs, w, E, S, L, O, D, k, C, T = 0, I = b.length; T < I; T++) {
    var A = b[T];
    if (A._id && isLocalId(A._id)) continue;
    if ((A = b[T] = parseDoc(A, o.new_edits, s)).error && !k) k = A;
  }
  if (k) return _(k);
  var x = false, R = 0, P = new Array(b.length), N = new ExportedMap, B = false, F = u._meta.blobSupport ? "blob" : "base64";
  preprocessAttachments(b, F, (function(s) {
    if (s) return _(s);
    startTransaction();
  }));
  function startTransaction() {
    var s, r = openTransactionSafely(g, [ DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, LOCAL_STORE, ATTACH_AND_SEQ_STORE, META_STORE ], "readwrite");
    if (r.error) return _(r.error);
    (w = r.txn).onabort = idbError(_);
    w.ontimeout = idbError(_);
    w.oncomplete = complete;
    E = w.objectStore(DOC_STORE);
    S = w.objectStore(BY_SEQ_STORE);
    L = w.objectStore(ATTACH_STORE);
    O = w.objectStore(ATTACH_AND_SEQ_STORE);
    (D = w.objectStore(META_STORE)).get(META_STORE).onsuccess = function(s) {
      C = s.target.result;
      updateDocCountIfReady();
    };
    verifyAttachments((function(s) {
      if (s) {
        B = true;
        return _(s);
      }
      fetchExistingDocs();
    }));
  }
  function onAllDocsProcessed() {
    x = true;
    updateDocCountIfReady();
  }
  function idbProcessDocs() {
    processDocs(s.revs_limit, b, u, N, w, P, writeDoc, o, onAllDocsProcessed);
  }
  function updateDocCountIfReady() {
    if (!C || !x) return;
    C.docCount += R;
    D.put(C);
  }
  function fetchExistingDocs() {
    if (!b.length) return;
    var s = 0;
    function checkDone() {
      if (++s === b.length) idbProcessDocs();
    }
    function readMetadata(s) {
      var r = decodeMetadata(s.target.result);
      if (r) N.set(r.id, r);
      checkDone();
    }
    for (var r = 0, o = b.length; r < o; r++) {
      var u = b[r], g;
      if (u._id && isLocalId(u._id)) {
        checkDone();
        continue;
      }
      E.get(u.metadata.id).onsuccess = readMetadata;
    }
  }
  function complete() {
    if (B) return;
    changesHandler$1.notify(u._meta.name);
    _(null, P);
  }
  function verifyAttachment(s, r) {
    var o;
    L.get(s).onsuccess = function(o) {
      if (!o.target.result) {
        var u = createError(MISSING_STUB, "unknown stub attachment with digest " + s);
        u.status = 412;
        r(u);
      } else r();
    };
  }
  function verifyAttachments(s) {
    var r = [];
    b.forEach((function(s) {
      if (s.data && s.data._attachments) Object.keys(s.data._attachments).forEach((function(o) {
        var u = s.data._attachments[o];
        if (u.stub) r.push(u.digest);
      }));
    }));
    if (!r.length) return s();
    var o = 0, u;
    function checkDone() {
      if (++o === r.length) s(u);
    }
    r.forEach((function(s) {
      verifyAttachment(s, (function(s) {
        if (s && !u) u = s;
        checkDone();
      }));
    }));
  }
  function writeDoc(s, r, o, u, g, _, b, w) {
    s.metadata.winningRev = r;
    s.metadata.deleted = o;
    var E = s.data, S;
    E._id = s.metadata.id;
    E._rev = s.metadata.rev;
    if (u) E._deleted = true;
    if (E._attachments && Object.keys(E._attachments).length) return writeAttachments(s, r, o, g, b, w);
    R += _;
    updateDocCountIfReady();
    finishDoc(s, r, o, g, b, w);
  }
  function finishDoc(s, r, o, g, _, b) {
    var L = s.data, O = s.metadata;
    L._doc_id_rev = O.id + "::" + O.rev;
    delete L._id;
    delete L._rev;
    function afterPutDoc(_) {
      var b = s.stemmedRevs || [];
      if (g && u.auto_compaction) b = b.concat(compactTree(s.metadata));
      if (b && b.length) compactRevs(b, s.metadata.id, w);
      O.seq = _.target.result;
      var S = encodeMetadata(O, r, o), L;
      E.put(S).onsuccess = afterPutMetadata;
    }
    function afterPutDocError(s) {
      s.preventDefault();
      s.stopPropagation();
      var r, o;
      S.index("_doc_id_rev").getKey(L._doc_id_rev).onsuccess = function(s) {
        var r;
        S.put(L, s.target.result).onsuccess = afterPutDoc;
      };
    }
    function afterPutMetadata() {
      P[_] = {
        ok: true,
        id: O.id,
        rev: O.rev
      };
      N.set(s.metadata.id, s.metadata);
      insertAttachmentMappings(s, O.seq, b);
    }
    var D = S.put(L);
    D.onsuccess = afterPutDoc;
    D.onerror = afterPutDocError;
  }
  function writeAttachments(s, r, o, u, g, _) {
    var b = s.data, w = 0, E = Object.keys(b._attachments);
    function collectResults() {
      if (w === E.length) finishDoc(s, r, o, u, g, _);
    }
    function attachmentSaved() {
      w++;
      collectResults();
    }
    E.forEach((function(o) {
      var u = s.data._attachments[o];
      if (!u.stub) {
        var g = u.data, _;
        delete u.data;
        u.revpos = parseInt(r, 10);
        saveAttachment(u.digest, g, attachmentSaved);
      } else {
        w++;
        collectResults();
      }
    }));
  }
  function insertAttachmentMappings(s, r, o) {
    var u = 0, g = Object.keys(s.data._attachments || {});
    if (!g.length) return o();
    function checkDone() {
      if (++u === g.length) o();
    }
    function add(o) {
      var u = s.data._attachments[o].digest, g = O.put({
        seq: r,
        digestSeq: u + "::" + r
      });
      g.onsuccess = checkDone;
      g.onerror = function(s) {
        s.preventDefault();
        s.stopPropagation();
        checkDone();
      };
    }
    for (var _ = 0; _ < g.length; _++) add(g[_]);
  }
  function saveAttachment(s, r, o) {
    var u;
    L.count(s).onsuccess = function(u) {
      var g;
      if (u.target.result) return o();
      var _ = {
        digest: s,
        body: r
      }, b;
      L.put(_).onsuccess = o;
    };
  }
}

function runBatchedCursor(s, r, o, u, g) {
  if (-1 === u) u = 1e3;
  var _, b, w, E;
  function onGetAll(s) {
    w = s.target.result;
    if (b) g(b, w, E);
  }
  function onGetAllKeys(s) {
    b = s.target.result;
    if (w) g(b, w, E);
  }
  function continuePseudoCursor() {
    if (!b.length) return g();
    var o = b[b.length - 1], _;
    if (r && r.upper) try {
      _ = IDBKeyRange.bound(o, r.upper, true, r.upperOpen);
    } catch (s) {
      if ("DataError" === s.name && 0 === s.code) return g();
    } else _ = IDBKeyRange.lowerBound(o, true);
    r = _;
    b = null;
    w = null;
    s.getAll(r, u).onsuccess = onGetAll;
    s.getAllKeys(r, u).onsuccess = onGetAllKeys;
  }
  function onCursor(s) {
    var r = s.target.result;
    if (!r) return g();
    g([ r.key ], [ r.value ], r);
  }
  if ("function" == typeof s.getAll && "function" == typeof s.getAllKeys && u > 1 && !o) {
    E = {
      continue: continuePseudoCursor
    };
    s.getAll(r, u).onsuccess = onGetAll;
    s.getAllKeys(r, u).onsuccess = onGetAllKeys;
  } else if (o) s.openCursor(r, "prev").onsuccess = onCursor; else s.openCursor(r).onsuccess = onCursor;
}

function getAll(s, r, o) {
  if ("function" == typeof s.getAll) {
    s.getAll(r).onsuccess = o;
    return;
  }
  var u = [];
  function onCursor(s) {
    var r = s.target.result;
    if (r) {
      u.push(r.value);
      r.continue();
    } else o({
      target: {
        result: u
      }
    });
  }
  s.openCursor(r).onsuccess = onCursor;
}

function allDocsKeys(s, r, o) {
  var u = new Array(s.length), g = 0;
  s.forEach((function(_, b) {
    r.get(_).onsuccess = function(r) {
      if (r.target.result) u[b] = r.target.result; else u[b] = {
        key: _,
        error: "not_found"
      };
      if (++g === s.length) o(s, u, {});
    };
  }));
}

function createKeyRange(s, r, o, u, g) {
  try {
    if (s && r) if (g) return IDBKeyRange.bound(r, s, !o, false); else return IDBKeyRange.bound(s, r, false, !o); else if (s) if (g) return IDBKeyRange.upperBound(s); else return IDBKeyRange.lowerBound(s); else if (r) if (g) return IDBKeyRange.lowerBound(r, !o); else return IDBKeyRange.upperBound(r, !o); else if (u) return IDBKeyRange.only(u);
  } catch (s) {
    return {
      error: s
    };
  }
  return null;
}

function idbAllDocs(s, r, o) {
  var u = "startkey" in s ? s.startkey : false, g = "endkey" in s ? s.endkey : false, _ = "key" in s ? s.key : false, b = "keys" in s ? s.keys : false, w = s.skip || 0, E = "number" == typeof s.limit ? s.limit : -1, S = false !== s.inclusive_end, L, O;
  if (!b) if ((O = (L = createKeyRange(u, g, S, _, s.descending)) && L.error) && !("DataError" === O.name && 0 === O.code)) return o(createError(IDB_ERROR, O.name, O.message));
  var D = [ DOC_STORE, BY_SEQ_STORE, META_STORE ];
  if (s.attachments) D.push(ATTACH_STORE);
  var k = openTransactionSafely(r, D, "readonly");
  if (k.error) return o(k.error);
  var C = k.txn;
  C.oncomplete = onTxnComplete;
  C.onabort = idbError(o);
  var T = C.objectStore(DOC_STORE), I = C.objectStore(BY_SEQ_STORE), A = C.objectStore(META_STORE), x = I.index("_doc_id_rev"), R = [], P, N;
  A.get(META_STORE).onsuccess = function(s) {
    P = s.target.result.docCount;
  };
  if (s.update_seq) getMaxUpdateSeq(I, (function(s) {
    if (s.target.result && s.target.result.length > 0) N = s.target.result[0];
  }));
  function getMaxUpdateSeq(s, r) {
    function onCursor(s) {
      var o = s.target.result, u = void 0;
      if (o && o.key) u = o.key;
      return r({
        target: {
          result: [ u ]
        }
      });
    }
    s.openCursor(null, "prev").onsuccess = onCursor;
  }
  function fetchDocAsynchronously(r, o, u) {
    var g = r.id + "::" + u;
    x.get(g).onsuccess = function onGetDoc(u) {
      o.doc = decodeDoc(u.target.result) || {};
      if (s.conflicts) {
        var g = collectConflicts(r);
        if (g.length) o.doc._conflicts = g;
      }
      fetchAttachmentsIfNecessary(o.doc, s, C);
    };
  }
  function allDocsInner(r, o) {
    var u = {
      id: o.id,
      key: o.id,
      value: {
        rev: r
      }
    }, g;
    if (o.deleted) {
      if (b) {
        R.push(u);
        u.value.deleted = true;
        u.doc = null;
      }
    } else if (w-- <= 0) {
      R.push(u);
      if (s.include_docs) fetchDocAsynchronously(o, u, r);
    }
  }
  function processBatch(s) {
    for (var r = 0, o = s.length; r < o && R.length !== E; r++) {
      var u = s[r];
      if (u.error && b) {
        R.push(u);
        continue;
      }
      var g = decodeMetadata(u), _;
      allDocsInner(g.winningRev, g);
    }
  }
  function onBatch(s, r, o) {
    if (!o) return;
    processBatch(r);
    if (R.length < E) o.continue();
  }
  function onGetAll(r) {
    var o = r.target.result;
    if (s.descending) o = o.reverse();
    processBatch(o);
  }
  function onResultsReady() {
    var r = {
      total_rows: P,
      offset: s.skip,
      rows: R
    };
    if (s.update_seq && void 0 !== N) r.update_seq = N;
    o(null, r);
  }
  function onTxnComplete() {
    if (s.attachments) postProcessAttachments(R, s.binary).then(onResultsReady); else onResultsReady();
  }
  if (O || 0 === E) return;
  if (b) return allDocsKeys(s.keys, T, onBatch);
  if (-1 === E) return getAll(T, L, onGetAll);
  runBatchedCursor(T, L, s.descending, E + w, onBatch);
}

function checkBlobSupport(s) {
  return new Promise((function(r) {
    var o = createBlob([ "" ]), u = s.objectStore(DETECT_BLOB_SUPPORT_STORE).put(o, "key");
    u.onsuccess = function() {
      var s = navigator.userAgent.match(/Chrome\/(\d+)/), o = navigator.userAgent.match(/Edge\//);
      r(o || !s || parseInt(s[1], 10) >= 43);
    };
    u.onerror = s.onabort = function(s) {
      s.preventDefault();
      s.stopPropagation();
      r(false);
    };
  })).catch((function() {
    return false;
  }));
}

function countDocs(s, r) {
  var o;
  s.objectStore(DOC_STORE).index("deletedOrLocal").count(IDBKeyRange.only("0")).onsuccess = function(s) {
    r(s.target.result);
  };
}

var running = false, queue = [];

function tryCode(s, r, o, u) {
  try {
    s(r, o);
  } catch (s) {
    u.emit("error", s);
  }
}

function applyNext() {
  if (running || !queue.length) return;
  running = true;
  queue.shift()();
}

function enqueueTask(s, r, o) {
  queue.push((function runAction() {
    s((function runCallback(s, u) {
      tryCode(r, s, u, o);
      running = false;
      (0, import_immediate.default)((function runNext() {
        applyNext(o);
      }));
    }));
  }));
  applyNext();
}

function changes(s, r, o, u) {
  if ((s = clone(s)).continuous) {
    var g = o + ":" + uuid();
    changesHandler$1.addListener(o, g, r, s);
    changesHandler$1.notify(o);
    return {
      cancel: function() {
        changesHandler$1.removeListener(o, g);
      }
    };
  }
  var _ = s.doc_ids && new ExportedSet(s.doc_ids);
  s.since = s.since || 0;
  var b = s.since, w = "limit" in s ? s.limit : -1;
  if (0 === w) w = 1;
  var E = [], S = 0, L = filterChange(s), O = new ExportedMap, D, k, C, T;
  function onBatch(r, o, u) {
    if (!u || !r.length) return;
    var g = new Array(r.length), _ = new Array(r.length);
    function processMetadataAndWinningDoc(r, o) {
      var u = s.processChange(o, r, s);
      b = u.seq = r.seq;
      var g = L(u);
      if ("object" == typeof g) return Promise.reject(g);
      if (!g) return Promise.resolve();
      S++;
      if (s.return_docs) E.push(u);
      if (s.attachments && s.include_docs) return new Promise((function(r) {
        fetchAttachmentsIfNecessary(o, s, D, (function() {
          postProcessAttachments([ u ], s.binary).then((function() {
            r(u);
          }));
        }));
      })); else return Promise.resolve(u);
    }
    function onBatchDone() {
      for (var r = [], o = 0, b = g.length; o < b && S !== w; o++) {
        var E = g[o];
        if (!E) continue;
        var L = _[o];
        r.push(processMetadataAndWinningDoc(L, E));
      }
      Promise.all(r).then((function(r) {
        for (var o = 0, u = r.length; o < u; o++) if (r[o]) s.onChange(r[o]);
      })).catch(s.complete);
      if (S !== w) u.continue();
    }
    var O = 0;
    o.forEach((function(s, o) {
      var u, b;
      fetchWinningDocAndMetadata(decodeDoc(s), r[o], (function(s, u) {
        _[o] = s;
        g[o] = u;
        if (++O === r.length) onBatchDone();
      }));
    }));
  }
  function onGetMetadata(s, r, o, u) {
    if (o.seq !== r) return u();
    if (o.winningRev === s._rev) return u(o, s);
    var g = s._id + "::" + o.winningRev, _;
    T.get(g).onsuccess = function(s) {
      u(o, decodeDoc(s.target.result));
    };
  }
  function fetchWinningDocAndMetadata(s, r, o) {
    if (_ && !_.has(s._id)) return o();
    var u = O.get(s._id);
    if (u) return onGetMetadata(s, r, u, o);
    C.get(s._id).onsuccess = function(g) {
      u = decodeMetadata(g.target.result);
      O.set(s._id, u);
      onGetMetadata(s, r, u, o);
    };
  }
  function finish() {
    s.complete(null, {
      results: E,
      last_seq: b
    });
  }
  function onTxnComplete() {
    if (!s.continuous && s.attachments) postProcessAttachments(E).then(finish); else finish();
  }
  var I = [ DOC_STORE, BY_SEQ_STORE ];
  if (s.attachments) I.push(ATTACH_STORE);
  var A = openTransactionSafely(u, I, "readonly"), x;
  if (A.error) return s.complete(A.error);
  (D = A.txn).onabort = idbError(s.complete);
  D.oncomplete = onTxnComplete;
  k = D.objectStore(BY_SEQ_STORE);
  C = D.objectStore(DOC_STORE);
  T = k.index("_doc_id_rev");
  runBatchedCursor(k, s.since && !s.descending ? IDBKeyRange.lowerBound(s.since, true) : null, s.descending, w, onBatch);
}

var cachedDBs = new ExportedMap, blobSupportPromise, openReqList = new ExportedMap;

function IdbPouch(s, r) {
  var o = this;
  enqueueTask((function(r) {
    init(o, s, r);
  }), r, o.constructor);
}

function init(s, r, o) {
  var u = r.name, g = null, _ = null;
  s._meta = null;
  function enrichCallbackError(s) {
    return function(r, o) {
      if (r && r instanceof Error && !r.reason) if (_) r.reason = _;
      s(r, o);
    };
  }
  function createSchema(s) {
    var r = s.createObjectStore(DOC_STORE, {
      keyPath: "id"
    });
    s.createObjectStore(BY_SEQ_STORE, {
      autoIncrement: true
    }).createIndex("_doc_id_rev", "_doc_id_rev", {
      unique: true
    });
    s.createObjectStore(ATTACH_STORE, {
      keyPath: "digest"
    });
    s.createObjectStore(META_STORE, {
      keyPath: "id",
      autoIncrement: false
    });
    s.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
    r.createIndex("deletedOrLocal", "deletedOrLocal", {
      unique: false
    });
    s.createObjectStore(LOCAL_STORE, {
      keyPath: "_id"
    });
    var o = s.createObjectStore(ATTACH_AND_SEQ_STORE, {
      autoIncrement: true
    });
    o.createIndex("seq", "seq");
    o.createIndex("digestSeq", "digestSeq", {
      unique: true
    });
  }
  function addDeletedOrLocalIndex(s, r) {
    var o = s.objectStore(DOC_STORE);
    o.createIndex("deletedOrLocal", "deletedOrLocal", {
      unique: false
    });
    o.openCursor().onsuccess = function(s) {
      var u = s.target.result;
      if (u) {
        var g = u.value, _ = isDeleted(g);
        g.deletedOrLocal = _ ? "1" : "0";
        o.put(g);
        u.continue();
      } else r();
    };
  }
  function createLocalStoreSchema(s) {
    s.createObjectStore(LOCAL_STORE, {
      keyPath: "_id"
    }).createIndex("_doc_id_rev", "_doc_id_rev", {
      unique: true
    });
  }
  function migrateLocalStore(s, r) {
    var o = s.objectStore(LOCAL_STORE), u = s.objectStore(DOC_STORE), g = s.objectStore(BY_SEQ_STORE), _;
    u.openCursor().onsuccess = function(s) {
      var _ = s.target.result;
      if (_) {
        var b = _.value, w = b.id, E = isLocalId(w), S = winningRev(b);
        if (E) {
          var L = w + "::" + S, O = w + "::", D = w + "::~", k = g.index("_doc_id_rev"), C = IDBKeyRange.bound(O, D, false, false), T = k.openCursor(C);
          T.onsuccess = function(s) {
            if (!(T = s.target.result)) {
              u.delete(_.primaryKey);
              _.continue();
            } else {
              var r = T.value;
              if (r._doc_id_rev === L) o.put(r);
              g.delete(T.primaryKey);
              T.continue();
            }
          };
        } else _.continue();
      } else if (r) r();
    };
  }
  function addAttachAndSeqStore(s) {
    var r = s.createObjectStore(ATTACH_AND_SEQ_STORE, {
      autoIncrement: true
    });
    r.createIndex("seq", "seq");
    r.createIndex("digestSeq", "digestSeq", {
      unique: true
    });
  }
  function migrateAttsAndSeqs(s, r) {
    var o = s.objectStore(BY_SEQ_STORE), u = s.objectStore(ATTACH_STORE), g = s.objectStore(ATTACH_AND_SEQ_STORE), _;
    u.count().onsuccess = function(s) {
      var u;
      if (!s.target.result) return r();
      o.openCursor().onsuccess = function(s) {
        var o = s.target.result;
        if (!o) return r();
        for (var u = o.value, _ = o.primaryKey, b = Object.keys(u._attachments || {}), w = {}, E = 0; E < b.length; E++) {
          var S;
          w[u._attachments[b[E]].digest] = true;
        }
        var L = Object.keys(w);
        for (E = 0; E < L.length; E++) {
          var O = L[E];
          g.put({
            seq: _,
            digestSeq: O + "::" + _
          });
        }
        o.continue();
      };
    };
  }
  function migrateMetadata(s) {
    function decodeMetadataCompat(s) {
      if (!s.data) {
        s.deleted = "1" === s.deletedOrLocal;
        return s;
      }
      return decodeMetadata(s);
    }
    var r = s.objectStore(BY_SEQ_STORE), o = s.objectStore(DOC_STORE), u;
    o.openCursor().onsuccess = function(s) {
      var u = s.target.result;
      if (!u) return;
      var g = decodeMetadataCompat(u.value);
      g.winningRev = g.winningRev || winningRev(g);
      function fetchMetadataSeq() {
        var s = g.id + "::", o = g.id + "::￿", u = r.index("_doc_id_rev").openCursor(IDBKeyRange.bound(s, o)), _ = 0;
        u.onsuccess = function(s) {
          var r = s.target.result;
          if (!r) {
            g.seq = _;
            return onGetMetadataSeq();
          }
          var o = r.primaryKey;
          if (o > _) _ = o;
          r.continue();
        };
      }
      function onGetMetadataSeq() {
        var s = encodeMetadata(g, g.winningRev, g.deleted), r;
        o.put(s).onsuccess = function() {
          u.continue();
        };
      }
      if (g.seq) return onGetMetadataSeq();
      fetchMetadataSeq();
    };
  }
  s._remote = false;
  s.type = function() {
    return "idb";
  };
  s._id = toPromise((function(r) {
    r(null, s._meta.instanceId);
  }));
  s._bulkDocs = function idb_bulkDocs(o, u, _) {
    idbBulkDocs(r, o, u, s, g, enrichCallbackError(_));
  };
  s._get = function idb_get(s, r, o) {
    var u, _, b, w = r.ctx;
    if (!w) {
      var E = openTransactionSafely(g, [ DOC_STORE, BY_SEQ_STORE, ATTACH_STORE ], "readonly");
      if (E.error) return o(E.error);
      w = E.txn;
    }
    function finish() {
      o(b, {
        doc: u,
        metadata: _,
        ctx: w
      });
    }
    w.objectStore(DOC_STORE).get(s).onsuccess = function(s) {
      if (!(_ = decodeMetadata(s.target.result))) {
        b = createError(MISSING_DOC, "missing");
        return finish();
      }
      var o;
      if (!r.rev) {
        o = _.winningRev;
        var g;
        if (isDeleted(_)) {
          b = createError(MISSING_DOC, "deleted");
          return finish();
        }
      } else o = r.latest ? latest(r.rev, _) : r.rev;
      var E = w.objectStore(BY_SEQ_STORE), S = _.id + "::" + o;
      E.index("_doc_id_rev").get(S).onsuccess = function(s) {
        if (u = s.target.result) u = decodeDoc(u);
        if (!u) {
          b = createError(MISSING_DOC, "missing");
          return finish();
        }
        finish();
      };
    };
  };
  s._getAttachment = function(s, r, o, u, _) {
    var b;
    if (u.ctx) b = u.ctx; else {
      var w = openTransactionSafely(g, [ DOC_STORE, BY_SEQ_STORE, ATTACH_STORE ], "readonly");
      if (w.error) return _(w.error);
      b = w.txn;
    }
    var E = o.digest, S = o.content_type;
    b.objectStore(ATTACH_STORE).get(E).onsuccess = function(s) {
      var r;
      readBlobData(s.target.result.body, S, u.binary, (function(s) {
        _(null, s);
      }));
    };
  };
  s._info = function idb_info(r) {
    var o, u, _ = openTransactionSafely(g, [ META_STORE, BY_SEQ_STORE ], "readonly");
    if (_.error) return r(_.error);
    var b = _.txn;
    b.objectStore(META_STORE).get(META_STORE).onsuccess = function(s) {
      u = s.target.result.docCount;
    };
    b.objectStore(BY_SEQ_STORE).openCursor(null, "prev").onsuccess = function(s) {
      var r = s.target.result;
      o = r ? r.key : 0;
    };
    b.oncomplete = function() {
      r(null, {
        doc_count: u,
        update_seq: o,
        idb_attachment_format: s._meta.blobSupport ? "binary" : "base64"
      });
    };
  };
  s._allDocs = function idb_allDocs(s, r) {
    idbAllDocs(s, g, enrichCallbackError(r));
  };
  s._changes = function idbChanges2(r) {
    return changes(r, s, u, g);
  };
  s._close = function(s) {
    g.close();
    cachedDBs.delete(u);
    s();
  };
  s._getRevisionTree = function(s, r) {
    var o = openTransactionSafely(g, [ DOC_STORE ], "readonly"), u, _;
    if (o.error) return r(o.error);
    o.txn.objectStore(DOC_STORE).get(s).onsuccess = function(s) {
      var o = decodeMetadata(s.target.result);
      if (!o) r(createError(MISSING_DOC)); else r(null, o.rev_tree);
    };
  };
  s._doCompaction = function(s, r, o) {
    var u, _ = openTransactionSafely(g, [ DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, ATTACH_AND_SEQ_STORE ], "readwrite");
    if (_.error) return o(_.error);
    var b = _.txn, w;
    b.objectStore(DOC_STORE).get(s).onsuccess = function(o) {
      var u = decodeMetadata(o.target.result);
      traverseRevTree(u.rev_tree, (function(s, o, u, g, _) {
        var b = o + "-" + u;
        if (-1 !== r.indexOf(b)) _.status = "missing";
      }));
      compactRevs(r, s, b);
      var g = u.winningRev, _ = u.deleted;
      b.objectStore(DOC_STORE).put(encodeMetadata(u, g, _));
    };
    b.onabort = idbError(o);
    b.oncomplete = function() {
      o();
    };
  };
  s._getLocal = function(s, r) {
    var o = openTransactionSafely(g, [ LOCAL_STORE ], "readonly");
    if (o.error) return r(o.error);
    var u, _ = o.txn.objectStore(LOCAL_STORE).get(s);
    _.onerror = idbError(r);
    _.onsuccess = function(s) {
      var o = s.target.result;
      if (!o) r(createError(MISSING_DOC)); else {
        delete o["_doc_id_rev"];
        r(null, o);
      }
    };
  };
  s._putLocal = function(s, r, o) {
    if ("function" == typeof r) {
      o = r;
      r = {};
    }
    delete s._revisions;
    var u = s._rev, _ = s._id;
    if (!u) s._rev = "0-1"; else s._rev = "0-" + (parseInt(u.split("-")[1], 10) + 1);
    var b = r.ctx, w;
    if (!b) {
      var E = openTransactionSafely(g, [ LOCAL_STORE ], "readwrite");
      if (E.error) return o(E.error);
      (b = E.txn).onerror = idbError(o);
      b.oncomplete = function() {
        if (w) o(null, w);
      };
    }
    var S = b.objectStore(LOCAL_STORE), L;
    if (u) (L = S.get(_)).onsuccess = function(g) {
      var _ = g.target.result;
      if (!_ || _._rev !== u) o(createError(REV_CONFLICT)); else {
        var b;
        S.put(s).onsuccess = function() {
          w = {
            ok: true,
            id: s._id,
            rev: s._rev
          };
          if (r.ctx) o(null, w);
        };
      }
    }; else {
      (L = S.add(s)).onerror = function(s) {
        o(createError(REV_CONFLICT));
        s.preventDefault();
        s.stopPropagation();
      };
      L.onsuccess = function() {
        w = {
          ok: true,
          id: s._id,
          rev: s._rev
        };
        if (r.ctx) o(null, w);
      };
    }
  };
  s._removeLocal = function(s, r, o) {
    if ("function" == typeof r) {
      o = r;
      r = {};
    }
    var u = r.ctx, _;
    if (!u) {
      var b = openTransactionSafely(g, [ LOCAL_STORE ], "readwrite");
      if (b.error) return o(b.error);
      (u = b.txn).oncomplete = function() {
        if (_) o(null, _);
      };
    }
    var w = s._id, E = u.objectStore(LOCAL_STORE), S = E.get(w);
    S.onerror = idbError(o);
    S.onsuccess = function(u) {
      var g = u.target.result;
      if (!g || g._rev !== s._rev) o(createError(MISSING_DOC)); else {
        E.delete(w);
        _ = {
          ok: true,
          id: w,
          rev: "0-0"
        };
        if (r.ctx) o(null, _);
      }
    };
  };
  s._destroy = function(s, r) {
    changesHandler$1.removeAllListeners(u);
    var o = openReqList.get(u);
    if (o && o.result) {
      o.result.close();
      cachedDBs.delete(u);
    }
    var g = indexedDB.deleteDatabase(u);
    g.onsuccess = function() {
      openReqList.delete(u);
      if (hasLocalStorage() && u in localStorage) delete localStorage[u];
      r(null, {
        ok: true
      });
    };
    g.onerror = idbError(r);
  };
  var b = cachedDBs.get(u);
  if (b) {
    g = b.idb;
    s._meta = b.global;
    return (0, import_immediate.default)((function() {
      o(null, s);
    }));
  }
  var w = indexedDB.open(u, ADAPTER_VERSION);
  openReqList.set(u, w);
  w.onupgradeneeded = function(s) {
    var r = s.target.result;
    if (s.oldVersion < 1) return createSchema(r);
    var o = s.currentTarget.transaction;
    if (s.oldVersion < 3) createLocalStoreSchema(r);
    if (s.oldVersion < 4) addAttachAndSeqStore(r);
    var u = [ addDeletedOrLocalIndex, migrateLocalStore, migrateAttsAndSeqs, migrateMetadata ], g = s.oldVersion;
    function next() {
      var s = u[g - 1];
      g++;
      if (s) s(o, next);
    }
    next();
  };
  w.onsuccess = function(r) {
    (g = r.target.result).onversionchange = function() {
      g.close();
      cachedDBs.delete(u);
    };
    g.onabort = function(s) {
      guardedConsole("error", "Database has a global failure", s.target.error);
      _ = s.target.error;
      g.close();
      cachedDBs.delete(u);
    };
    var b = g.transaction([ META_STORE, DETECT_BLOB_SUPPORT_STORE, DOC_STORE ], "readwrite"), w = false, E, S, L, O;
    function completeSetup() {
      if ("undefined" == typeof L || !w) return;
      s._meta = {
        name: u,
        instanceId: O,
        blobSupport: L
      };
      cachedDBs.set(u, {
        idb: g,
        global: s._meta
      });
      o(null, s);
    }
    function storeMetaDocIfReady() {
      if ("undefined" == typeof S || "undefined" == typeof E) return;
      var s = u + "_id";
      if (s in E) O = E[s]; else E[s] = O = uuid();
      E.docCount = S;
      b.objectStore(META_STORE).put(E);
    }
    b.objectStore(META_STORE).get(META_STORE).onsuccess = function(s) {
      E = s.target.result || {
        id: META_STORE
      };
      storeMetaDocIfReady();
    };
    countDocs(b, (function(s) {
      S = s;
      storeMetaDocIfReady();
    }));
    if (!blobSupportPromise) blobSupportPromise = checkBlobSupport(b);
    blobSupportPromise.then((function(s) {
      L = s;
      completeSetup();
    }));
    b.oncomplete = function() {
      w = true;
      completeSetup();
    };
    b.onabort = idbError(o);
  };
  w.onerror = function(s) {
    var r = s.target.error && s.target.error.message;
    if (!r) r = "Failed to open indexedDB, are you in private browsing mode?"; else if (-1 !== r.indexOf("stored database is a higher version")) r = new Error('This DB was created with the newer "indexeddb" adapter, but you are trying to open it with the older "idb" adapter');
    guardedConsole("error", r);
    o(createError(IDB_ERROR, r));
  };
}

IdbPouch.valid = function() {
  try {
    return "undefined" != typeof indexedDB && "undefined" != typeof IDBKeyRange;
  } catch (s) {
    return false;
  }
};

function index(s) {
  s.adapter("idb", IdbPouch, true);
}

var index_es_default2 = index, IDB_NULL = Number.MIN_SAFE_INTEGER, IDB_FALSE = Number.MIN_SAFE_INTEGER + 1, IDB_TRUE = Number.MIN_SAFE_INTEGER + 2, TEST_KEY_INVALID = /^[^a-zA-Z_$]|[^a-zA-Z0-9_$]+/, TEST_PATH_INVALID = /\\.|(^|\.)[^a-zA-Z_$]|[^a-zA-Z0-9_$.]+/;

function needsSanitise(s, r) {
  if (r) return TEST_PATH_INVALID.test(s); else return TEST_KEY_INVALID.test(s);
}

var KEY_INVALID = new RegExp(TEST_KEY_INVALID.source, "g"), PATH_INVALID = new RegExp(TEST_PATH_INVALID.source, "g"), SLASH = "\\".charCodeAt(0), IS_DOT = ".".charCodeAt(0);

function sanitise(s, r) {
  var correctCharacters = function(s) {
    for (var o = "", u = 0; u < s.length; u++) {
      var g = s.charCodeAt(u);
      if (g === IS_DOT && r && 0 === u) o += "."; else if (g === SLASH && r) continue; else o += "_c" + g + "_";
    }
    return o;
  };
  if (r) return s.replace(PATH_INVALID, correctCharacters); else return s.replace(KEY_INVALID, correctCharacters);
}

function needsRewrite(s) {
  for (var r of Object.keys(s)) if (needsSanitise(r)) return true; else if (null === s[r] || "boolean" == typeof s[r]) return true; else if ("object" == typeof s[r]) return needsRewrite(s[r]);
}

function rewrite(s) {
  if (!needsRewrite(s)) return false;
  var r = Array.isArray(s), o = r ? [] : {};
  Object.keys(s).forEach((function(u) {
    var g = r ? u : sanitise(u);
    if (null === s[u]) o[g] = IDB_NULL; else if ("boolean" == typeof s[u]) o[g] = s[u] ? IDB_TRUE : IDB_FALSE; else if ("object" == typeof s[u]) o[g] = rewrite(s[u]); else o[g] = s[u];
  }));
  return o;
}

var DOC_STORE2 = "docs", META_STORE2 = "meta";

function idbError2(s) {
  return function(r) {
    var o = "unknown_error";
    if (r.target && r.target.error) o = r.target.error.name || r.target.error.message;
    s(createError(IDB_ERROR, o, r.type));
  };
}

function processAttachment(s, r, o, u) {
  delete o._attachments[s].stub;
  if (u) {
    o._attachments[s].data = r.attachments[o._attachments[s].digest].data;
    return Promise.resolve();
  }
  return new Promise((function(u) {
    var g;
    readAsBinaryString(r.attachments[o._attachments[s].digest].data, (function(r) {
      o._attachments[s].data = thisBtoa(r);
      delete o._attachments[s].length;
      u();
    }));
  }));
}

function rawIndexFields(s, r) {
  var o;
  return (s.views[r].options && s.views[r].options.def && s.views[r].options.def.fields || []).map((function(s) {
    if ("string" == typeof s) return s; else return Object.keys(s)[0];
  }));
}

function isPartialFilterView(s, r) {
  return r in s.views && s.views[r].options && s.views[r].options.def && s.views[r].options.def.partial_filter_selector;
}

function naturalIndexName(s) {
  return "_find_idx/" + s.join("/");
}

function correctIndexFields(s) {
  return [ "deleted" ].concat(s.map((function(s) {
    if ([ "_id", "_rev", "_deleted", "_attachments" ].includes(s)) return s.substr(1); else return "data." + sanitise(s, true);
  })));
}

var POUCHDB_IDB_VERSION = 1, versionMultiplier = Math.pow(10, 13);

function createIdbVersion() {
  return versionMultiplier * POUCHDB_IDB_VERSION + (new Date).getTime();
}

function getPouchDbVersion(s) {
  return Math.floor(s / versionMultiplier);
}

function maintainNativeIndexes(s, r) {
  var o = s.transaction.objectStore(DOC_STORE2), u;
  o.getAll(IDBKeyRange.bound("_design/", "_design/￿")).onsuccess = function(s) {
    var u = s.target.result, g = Array.from(o.indexNames), _ = u.filter((function(s) {
      return 0 === s.deleted && s.revs[s.rev].data.views;
    })).map((function(s) {
      return s.revs[s.rev].data;
    })).reduce((function(s, r) {
      return Object.keys(r.views).reduce((function(s, o) {
        var u = rawIndexFields(r, o);
        if (u && u.length > 0) s[naturalIndexName(u)] = correctIndexFields(u);
        return s;
      }), s);
    }), {}), b = Object.keys(_), w = [ "seq" ];
    g.forEach((function(s) {
      if (-1 === w.indexOf(s) && -1 === b.indexOf(s)) o.deleteIndex(s);
    }));
    var E = b.filter((function(s) {
      return -1 === g.indexOf(s);
    }));
    try {
      E.forEach((function(s) {
        o.createIndex(s, _[s]);
      }));
    } catch (s) {
      r(s);
    }
  };
}

function upgradePouchDbSchema(s, r) {
  if (r < 1) {
    var o;
    s.createObjectStore(DOC_STORE2, {
      keyPath: "id"
    }).createIndex("seq", "seq", {
      unique: true
    });
    s.createObjectStore(META_STORE2, {
      keyPath: "id"
    });
  }
}

function openDatabase(s, r, o, u, g) {
  var _ = o.versionchanged ? indexedDB.open(o.name) : indexedDB.open(o.name, createIdbVersion());
  _.onupgradeneeded = function(s) {
    if (s.oldVersion > 0 && s.oldVersion < versionMultiplier) throw new Error('Incorrect adapter: you should specify the "idb" adapter to open this DB'); else if (0 === s.oldVersion && s.newVersion < versionMultiplier) {
      indexedDB.deleteDatabase(o.name);
      throw new Error("Database was deleted while open");
    }
    var r, u;
    upgradePouchDbSchema(s.target.result, getPouchDbVersion(s.oldVersion));
    maintainNativeIndexes(_, g);
  };
  _.onblocked = function(s) {
    console.error("onblocked, this should never happen", s);
  };
  _.onsuccess = function(r) {
    var g = r.target.result;
    g.onabort = function(r) {
      console.error("Database has a global failure", r.target.error);
      delete s[o.name];
      g.close();
    };
    g.onversionchange = function() {
      console.log("Database was made stale, closing handle");
      s[o.name].versionchanged = true;
      g.close();
    };
    g.onclose = function() {
      console.log("Database was made stale, closing handle");
      if (o.name in s) s[o.name].versionchanged = true;
    };
    var _ = {
      id: META_STORE2
    }, b = g.transaction([ META_STORE2 ], "readwrite");
    b.oncomplete = function() {
      u({
        idb: g,
        metadata: _
      });
    };
    var w = b.objectStore(META_STORE2);
    w.get(META_STORE2).onsuccess = function(s) {
      var r = false;
      if (!("doc_count" in (_ = s.target.result || _))) {
        r = true;
        _.doc_count = 0;
      }
      if (!("seq" in _)) {
        r = true;
        _.seq = 0;
      }
      if (!("db_uuid" in _)) {
        r = true;
        _.db_uuid = uuid();
      }
      if (r) w.put(_);
    };
  };
  _.onerror = function(s) {
    g(s.target.error);
  };
}

function setup(s, r, o) {
  if (!s[o.name] || s[o.name].versionchanged) {
    o.versionchanged = s[o.name] && s[o.name].versionchanged;
    s[o.name] = new Promise((function(u, g) {
      openDatabase(s, r, o, u, g);
    }));
  }
  return s[o.name];
}

function info(s, r) {
  r(null, {
    doc_count: s.doc_count,
    update_seq: s.seq
  });
}

function get(s, r, o, u) {
  if (s.error) return u(s.error);
  s.txn.objectStore(DOC_STORE2).get(r).onsuccess = function(r) {
    var g = r.target.result, _;
    if (!o.rev) _ = g && g.rev; else _ = o.latest ? latest(o.rev, g) : o.rev;
    if (!g || g.deleted && !o.rev || !(_ in g.revs)) {
      u(createError(MISSING_DOC, "missing"));
      return;
    }
    var b = g.revs[_].data;
    b._id = g.id;
    b._rev = _;
    u(null, {
      doc: b,
      metadata: g,
      ctx: s
    });
  };
}

function parseAttachment(s, r, o) {
  if (r.binary) return o(null, s); else readAsBinaryString(s, (function(s) {
    o(null, thisBtoa(s));
  }));
}

function getAttachment(s, r, o, u, g, _) {
  if (s.error) return _(s.error);
  var b;
  s.txn.objectStore(DOC_STORE2).get(r).onsuccess = function(s) {
    var r = s.target.result, u, _ = r.revs[g.rev || r.rev].data._attachments[o].digest;
    b = r.attachments[_].data;
  };
  s.txn.oncomplete = function() {
    parseAttachment(b, g, _);
  };
  s.txn.onabort = _;
}

function bulkDocs(s, r, o, u, g, _, b) {
  var w, E, S = [], L = [], O, D = g.revs_limit || 1e3, k = -1 === g.name.indexOf("-mrview-");
  const C = g.auto_compaction;
  function docsRevsLimit(s) {
    return /^_local/.test(s.id) ? 1 : D;
  }
  function rootIsMissing2(s) {
    return "missing" === s.rev_tree[0].ids[1].status;
  }
  function parseBase642(s) {
    try {
      return atob(s);
    } catch (s) {
      return {
        error: createError(BAD_ARG, "Attachment is not a valid base64 string")
      };
    }
  }
  function fetchExistingDocs(s, r) {
    var o = 0, u = {};
    function readDone(g) {
      if (g.target.result) u[g.target.result.id] = g.target.result;
      if (++o === r.length) processDocs2(s, r, u);
    }
    r.forEach((function(r) {
      s.objectStore(DOC_STORE2).get(r.id).onsuccess = readDone;
    }));
  }
  function revHasAttachment(s, r, o) {
    return s.revs[r] && s.revs[r].data._attachments && Object.values(s.revs[r].data._attachments).find((function(s) {
      return s.digest === o;
    }));
  }
  function processDocs2(s, r, u) {
    r.forEach((function(r, g) {
      var _;
      if ("was_delete" in o && !Object.prototype.hasOwnProperty.call(u, r.id)) _ = createError(MISSING_DOC, "deleted"); else if (o.new_edits && !Object.prototype.hasOwnProperty.call(u, r.id) && rootIsMissing2(r)) _ = createError(REV_CONFLICT); else if (Object.prototype.hasOwnProperty.call(u, r.id)) {
        if (false == (_ = update2(s, r, u[r.id]))) return;
      } else {
        var b = merge([], r.rev_tree[0], docsRevsLimit(r));
        r.rev_tree = b.tree;
        r.stemmedRevs = b.stemmedRevs;
        (_ = r).isNewDoc = true;
        _.wasDeleted = r.revs[r.rev].deleted ? 1 : 0;
      }
      if (_.error) S[g] = _; else {
        u[_.id] = _;
        O = g;
        write(s, _, g);
      }
    }));
  }
  function convertDocFormat(s) {
    var r = {
      id: s.metadata.id,
      rev: s.metadata.rev,
      rev_tree: s.metadata.rev_tree,
      revs: s.metadata.revs || {}
    };
    r.revs[r.rev] = {
      data: s.data,
      deleted: s.metadata.deleted
    };
    return r;
  }
  function update2(s, r, u) {
    if (r.rev in u.revs && !o.new_edits) return false;
    var _ = /^1-/.test(r.rev);
    if (u.deleted && !r.deleted && o.new_edits && _) {
      var b = r.revs[r.rev].data;
      b._rev = u.rev;
      b._id = u.id;
      r = convertDocFormat(parseDoc(b, o.new_edits, g));
    }
    var w = merge(u.rev_tree, r.rev_tree[0], docsRevsLimit(r));
    r.stemmedRevs = w.stemmedRevs;
    r.rev_tree = w.tree;
    var E = u.revs, S;
    E[r.rev] = r.revs[r.rev];
    r.revs = E;
    r.attachments = u.attachments;
    if (o.new_edits && (u.deleted && r.deleted || !u.deleted && "new_leaf" !== w.conflicts || u.deleted && !r.deleted && "new_branch" === w.conflicts || u.rev === r.rev)) return createError(REV_CONFLICT);
    r.wasDeleted = u.deleted;
    return r;
  }
  function write(s, r, o) {
    var g = winningRev(r), _ = r.rev, b = /^_local/.test(r.id), w = r.revs[g].data;
    const L = r.isNewDoc;
    if (k) {
      var O = rewrite(w);
      if (O) {
        r.data = O;
        delete r.data._attachments;
      } else r.data = w;
    } else r.data = w;
    r.rev = g;
    r.deleted = r.revs[g].deleted ? 1 : 0;
    if (!b) {
      r.seq = ++u.seq;
      var D = 0;
      if (r.isNewDoc) D = r.deleted ? 0 : 1; else if (r.wasDeleted !== r.deleted) D = r.deleted ? -1 : 1;
      u.doc_count += D;
    }
    delete r.isNewDoc;
    delete r.wasDeleted;
    let T = r.stemmedRevs || [];
    if (C && !L) {
      const s = compactTree(r);
      if (s.length) T = T.concat(s);
    }
    if (T.length) T.forEach((function(s) {
      delete r.revs[s];
    }));
    delete r.stemmedRevs;
    if (!("attachments" in r)) r.attachments = {};
    if (w._attachments) for (var I in w._attachments) {
      var A = w._attachments[I];
      if (A.stub) {
        if (!(A.digest in r.attachments)) {
          E = createError(MISSING_STUB);
          s.abort();
          return;
        }
        if (revHasAttachment(r, _, A.digest)) r.attachments[A.digest].revs[_] = true;
      } else {
        r.attachments[A.digest] = A;
        r.attachments[A.digest].revs = {};
        r.attachments[A.digest].revs[_] = true;
        w._attachments[I] = {
          stub: true,
          digest: A.digest,
          content_type: A.content_type,
          length: A.length,
          revpos: parseInt(_, 10)
        };
      }
    }
    if (b && r.deleted) {
      s.objectStore(DOC_STORE2).delete(r.id).onsuccess = function() {
        S[o] = {
          ok: true,
          id: r.id,
          rev: "0-0"
        };
      };
      updateSeq(o);
      return;
    }
    s.objectStore(DOC_STORE2).put(r).onsuccess = function() {
      S[o] = {
        ok: true,
        id: r.id,
        rev: _
      };
      updateSeq(o);
    };
  }
  function updateSeq(s) {
    if (s === O) w.objectStore(META_STORE2).put(u);
  }
  function preProcessAttachment(s) {
    if (s.stub) return Promise.resolve(s);
    var r;
    if ("string" == typeof s.data) {
      if ((r = parseBase642(s.data)).error) return Promise.reject(r.error);
      s.data = binStringToBluffer(r, s.content_type);
    } else r = s.data;
    return new Promise((function(o) {
      binaryMd5(r, (function(u) {
        s.digest = "md5-" + u;
        s.length = r.size || r.length || 0;
        o(s);
      }));
    }));
  }
  function preProcessAttachments() {
    var s = L.map((function(s) {
      var r = s.revs[s.rev].data;
      if (!r._attachments) return Promise.resolve(r);
      var o = Object.keys(r._attachments).map((function(s) {
        r._attachments[s].name = s;
        return preProcessAttachment(r._attachments[s]);
      }));
      return Promise.all(o).then((function(s) {
        var o = {};
        s.forEach((function(s) {
          o[s.name] = s;
          delete s.name;
        }));
        r._attachments = o;
        return r;
      }));
    }));
    return Promise.all(s);
  }
  for (var T = 0, I = r.docs.length; T < I; T++) {
    var A;
    try {
      A = parseDoc(r.docs[T], o.new_edits, g);
    } catch (s) {
      A = s;
    }
    if (A.error) return b(A);
    L.push(convertDocFormat(A));
  }
  preProcessAttachments().then((function() {
    s._openTransactionSafely([ DOC_STORE2, META_STORE2 ], "readwrite", (function(s, r) {
      if (s) return b(s);
      (w = r).onabort = function() {
        b(E || createError(UNKNOWN_ERROR, "transaction was aborted"));
      };
      w.ontimeout = idbError2(b);
      w.oncomplete = function() {
        _.notify(g.name);
        b(null, S);
      };
      fetchExistingDocs(w, L);
    }));
  })).catch((function(s) {
    b(s);
  }));
}

function allDocsKeys2(s, r, o) {
  var u = new Array(s.length), g = 0;
  s.forEach((function(_, b) {
    r.get(_).onsuccess = function(r) {
      if (r.target.result) u[b] = r.target.result; else u[b] = {
        key: _,
        error: "not_found"
      };
      if (++g === s.length) u.forEach((function(s) {
        o(s);
      }));
    };
  }));
}

function createKeyRange2(s, r, o, u, g) {
  try {
    if (s && r) if (g) return IDBKeyRange.bound(r, s, !o, false); else return IDBKeyRange.bound(s, r, false, !o); else if (s) if (g) return IDBKeyRange.upperBound(s); else return IDBKeyRange.lowerBound(s); else if (r) if (g) return IDBKeyRange.lowerBound(r, !o); else return IDBKeyRange.upperBound(r, !o); else if (u) return IDBKeyRange.only(u);
  } catch (s) {
    return {
      error: s
    };
  }
  return null;
}

function handleKeyRangeError(s, r, o, u) {
  if ("DataError" === o.name && 0 === o.code) {
    var g = {
      total_rows: r.doc_count,
      offset: s.skip,
      rows: []
    };
    if (s.update_seq) g.update_seq = r.seq;
    return u(null, g);
  }
  u(createError(IDB_ERROR, o.name, o.message));
}

function allDocs(s, r, o, u) {
  if (s.error) return u(s.error);
  if (0 === o.limit) {
    var g = {
      total_rows: r.doc_count,
      offset: o.skip,
      rows: []
    };
    if (o.update_seq) g.update_seq = r.seq;
    return u(null, g);
  }
  var _ = [], b = [], w = "startkey" in o ? o.startkey : false, E = "endkey" in o ? o.endkey : false, S = "key" in o ? o.key : false, L = "keys" in o ? o.keys : false, O = o.skip || 0, D = "number" == typeof o.limit ? o.limit : -1, k = false !== o.inclusive_end, C = "descending" in o && o.descending ? "prev" : null, T;
  if (!L) if ((T = createKeyRange2(w, E, k, S, C)) && T.error) return handleKeyRangeError(o, r, T.error, u);
  var I = s.txn.objectStore(DOC_STORE2), A;
  s.txn.oncomplete = onTxnComplete;
  if (L) return allDocsKeys2(o.keys, I, allDocsInner);
  function include_doc(s, r) {
    var u = r.revs[r.rev].data;
    s.doc = u;
    s.doc._id = r.id;
    s.doc._rev = r.rev;
    if (o.conflicts) {
      var g = collectConflicts(r);
      if (g.length) s.doc._conflicts = g;
    }
    if (o.attachments && u._attachments) for (var _ in u._attachments) b.push(processAttachment(_, r, s.doc, o.binary));
  }
  function allDocsInner(s) {
    if (s.error && L) {
      _.push(s);
      return true;
    }
    var r = {
      id: s.id,
      key: s.id,
      value: {
        rev: s.rev
      }
    }, u;
    if (s.deleted) {
      if (L) {
        _.push(r);
        r.value.deleted = true;
        r.doc = null;
      }
    } else if (O-- <= 0) {
      _.push(r);
      if (o.include_docs) include_doc(r, s);
      if (0 == --D) return false;
    }
    return true;
  }
  function onTxnComplete() {
    Promise.all(b).then((function() {
      var s = {
        total_rows: r.doc_count,
        offset: 0,
        rows: _
      };
      if (o.update_seq) s.update_seq = r.seq;
      u(null, s);
    }));
  }
  (C ? I.openCursor(T, C) : I.openCursor(T)).onsuccess = function(s) {
    var r = s.target.result && s.target.result.value, o;
    if (!r) return;
    if (/^_local/.test(r.id)) return s.target.result.continue();
    if (allDocsInner(r)) s.target.result.continue();
  };
}

function changes2(s, r, o, u, g) {
  if (s.error) return g.complete(s.error);
  if (g.continuous) {
    var _ = u.name + ":" + uuid();
    r.addListener(u.name, _, o, g);
    r.notify(u.name);
    return {
      cancel: function() {
        r.removeListener(u.name, _);
      }
    };
  }
  var b = "limit" in g ? g.limit : -1;
  if (0 === b) b = 1;
  var w = s.txn.objectStore(DOC_STORE2).index("seq"), E = filterChange(g), S = 0, L = g.since || 0, O = [], D = [], k;
  function onReqSuccess(s) {
    if (!s.target.result) return;
    var r = s.target.result, o = r.value;
    o.data = o.revs[o.rev].data;
    o.data._id = o.id;
    o.data._rev = o.rev;
    if (o.deleted) o.data._deleted = true;
    if (g.doc_ids && -1 === g.doc_ids.indexOf(o.id)) return r.continue();
    var u = g.processChange(o.data, o, g);
    u.seq = o.seq;
    L = o.seq;
    var _ = E(u);
    if ("object" == typeof _) return g.complete(_);
    if (_) {
      S++;
      if (g.return_docs) O.push(u);
      if (g.include_docs && g.attachments && o.data._attachments) {
        var w = [];
        for (var k in o.data._attachments) {
          var C = processAttachment(k, o, u.doc, g.binary);
          w.push(C);
          D.push(C);
        }
        Promise.all(w).then((function() {
          g.onChange(u);
        }));
      } else g.onChange(u);
    }
    if (S !== b) r.continue();
  }
  function onTxnComplete() {
    Promise.all(D).then((function() {
      g.complete(null, {
        results: O,
        last_seq: L
      });
    }));
  }
  if (g.descending) k = w.openCursor(null, "prev"); else k = w.openCursor(IDBKeyRange.lowerBound(g.since, true));
  s.txn.oncomplete = onTxnComplete;
  k.onsuccess = onReqSuccess;
}

function getRevisionTree(s, r, o) {
  if (s.error) return o(s.error);
  var u;
  s.txn.objectStore(DOC_STORE2).get(r).onsuccess = function(s) {
    if (!s.target.result) o(createError(MISSING_DOC)); else o(null, s.target.result.rev_tree);
  };
}

function doCompaction(s, r, o, u) {
  if (s.error) return u(s.error);
  var g = s.txn.objectStore(DOC_STORE2);
  g.get(r).onsuccess = function(s) {
    var r = s.target.result;
    traverseRevTree(r.rev_tree, (function(s, r, u, g, _) {
      var b = r + "-" + u;
      if (-1 !== o.indexOf(b)) _.status = "missing";
    }));
    var u = [];
    o.forEach((function(s) {
      if (s in r.revs) {
        if (r.revs[s].data._attachments) for (var o in r.revs[s].data._attachments) u.push(r.revs[s].data._attachments[o].digest);
        delete r.revs[s];
      }
    }));
    u.forEach((function(s) {
      o.forEach((function(o) {
        delete r.attachments[s].revs[o];
      }));
      if (!Object.keys(r.attachments[s].revs).length) delete r.attachments[s];
    }));
    g.put(r);
  };
  s.txn.oncomplete = function() {
    u();
  };
}

function destroy(s, r, o, u) {
  o.removeAllListeners(s.name);
  function doDestroy() {
    var o;
    indexedDB.deleteDatabase(s.name).onsuccess = function() {
      delete r[s.name];
      u(null, {
        ok: true
      });
    };
  }
  if (s.name in r) r[s.name].then((function(s) {
    s.idb.close();
    doDestroy();
  })); else doDestroy();
}

var COUCH_COLLATE_LO = null, COUCH_COLLATE_HI = "￿", IDB_COLLATE_LO = Number.NEGATIVE_INFINITY, IDB_COLLATE_HI = [ [ [ [ [ [ [ [ [ [ [ [] ] ] ] ] ] ] ] ] ] ] ];

function externaliseRecord(s) {
  var r = s.revs[s.rev].data;
  r._id = s.id;
  r._rev = s.rev;
  if (s.deleted) r._deleted = true;
  return r;
}

function generateKeyRange(s) {
  function defined(s, r) {
    return void 0 !== s[r];
  }
  function convert(s, r) {
    var o;
    return [ 0 ].concat(s).map((function(s) {
      if (null === s && r) return IDB_NULL; else if (true === s) return IDB_TRUE; else if (false === s) return IDB_FALSE;
      if (!r) if (s === COUCH_COLLATE_LO) return IDB_COLLATE_LO; else if (Object.prototype.hasOwnProperty.call(s, COUCH_COLLATE_HI)) return IDB_COLLATE_HI;
      return s;
    }));
  }
  if (!defined(s, "inclusive_end")) s.inclusive_end = true;
  if (!defined(s, "inclusive_start")) s.inclusive_start = true;
  if (s.descending) {
    var r = s.startkey, o = s.inclusive_start;
    s.startkey = s.endkey;
    s.endkey = r;
    s.inclusive_start = s.inclusive_end;
    s.inclusive_end = o;
  }
  try {
    if (defined(s, "key")) return IDBKeyRange.only(convert(s.key, true));
    if (defined(s, "startkey") && !defined(s, "endkey")) return IDBKeyRange.bound(convert(s.startkey), [ 1 ], !s.inclusive_start, true);
    if (!defined(s, "startkey") && defined(s, "endkey")) return IDBKeyRange.upperBound(convert(s.endkey), !s.inclusive_end);
    if (defined(s, "startkey") && defined(s, "endkey")) return IDBKeyRange.bound(convert(s.startkey), convert(s.endkey), !s.inclusive_start, !s.inclusive_end);
    return IDBKeyRange.only([ 0 ]);
  } catch (r) {
    console.error("Could not generate keyRange", r, s);
    throw Error("Could not generate key range with " + JSON.stringify(s));
  }
}

function getIndexHandle(s, r, o) {
  var u = naturalIndexName(r);
  return new Promise((function(g) {
    s._openTransactionSafely([ DOC_STORE2 ], "readonly", (function(_, b) {
      if (_) return idbError2(o)(_);
      b.onabort = idbError2(o);
      b.ontimeout = idbError2(o);
      var w;
      if (-1 === Array.from(b.objectStore(DOC_STORE2).indexNames).indexOf(u)) s._freshen().then((function() {
        return getIndexHandle(s, r, o);
      })).then(g); else g(b.objectStore(DOC_STORE2).index(u));
    }));
  }));
}

function query(s, r, o, u) {
  var g = this, _ = r.split("/");
  return new Promise((function(s, b) {
    g.get("_design/" + _[0]).then((function(w) {
      if (isPartialFilterView(w, _[1])) return u(r, o).then(s, b);
      var E = rawIndexFields(w, _[1]);
      if (!E) throw new Error("ddoc " + w._id + " with view " + _[1] + " does not have map.options.def.fields defined.");
      var S = o.skip, L = Number.isInteger(o.limit) && o.limit;
      return getIndexHandle(g, E, b).then((function(r) {
        var u = generateKeyRange(o), g = r.openCursor(u, o.descending ? "prev" : "next"), _ = [];
        g.onerror = idbError2(b);
        g.onsuccess = function(r) {
          var o = r.target.result;
          if (!o || 0 === L) return s({
            rows: _
          });
          if (S) {
            o.advance(S);
            S = false;
            return;
          }
          if (L) L -= 1;
          _.push({
            doc: externaliseRecord(o.value)
          });
          o.continue();
        };
      }));
    })).catch(b);
  }));
}

function viewCleanup(s, r) {
  return r();
}

function purgeAttachments(s, r) {
  if (!s.attachments) return {};
  for (let o in s.attachments) {
    const u = s.attachments[o];
    for (let s of r) if (u.revs[s]) delete u.revs[s];
    if (0 === Object.keys(u.revs).length) delete s.attachments[o];
  }
  return s.attachments;
}

function purge(s, r, o, u) {
  if (s.error) return u(s.error);
  const g = s.txn.objectStore(DOC_STORE2), _ = [];
  let b = false;
  g.get(r).onsuccess = s => {
    const r = s.target.result;
    for (const s of o) {
      r.rev_tree = removeLeafFromRevTree(r.rev_tree, s);
      delete r.revs[s];
      _.push(s);
    }
    if (0 === r.rev_tree.length) {
      g.delete(r.id);
      b = true;
      return;
    }
    r.rev = winningRev(r);
    r.data = r.revs[r.rev].data;
    r.attachments = purgeAttachments(r, o);
    g.put(r);
  };
  s.txn.oncomplete = function() {
    u(null, {
      ok: true,
      deletedRevs: _,
      documentWasRemovedCompletely: b
    });
  };
}

var ADAPTER_NAME = "indexeddb", idbChanges = new Changes, openDatabases = {};

function IdbPouch2(s, r) {
  if (s.view_adapter) console.log("Please note that the indexeddb adapter manages _find indexes itself, therefore it is not using your specified view_adapter");
  var o = this, u = {}, $ = function(r) {
    return function() {
      var g = Array.prototype.slice.call(arguments);
      setup(openDatabases, o, s).then((function(s) {
        u = s.metadata;
        g.unshift(s.idb);
        r.apply(o, g);
      })).catch((function(s) {
        var r = g.pop();
        if ("function" == typeof r) r(s); else console.error(s);
      }));
    };
  }, $p = function(r) {
    return function() {
      var g = Array.prototype.slice.call(arguments);
      return setup(openDatabases, o, s).then((function(s) {
        u = s.metadata;
        g.unshift(s.idb);
        return r.apply(o, g);
      }));
    };
  }, $t = function(r, g, _) {
    g = g || [ DOC_STORE2 ];
    _ = _ || "readonly";
    return function() {
      var b = Array.prototype.slice.call(arguments), w = {};
      setup(openDatabases, o, s).then((function(s) {
        u = s.metadata;
        w.txn = s.idb.transaction(g, _);
      })).catch((function(s) {
        console.error("Failed to establish transaction safely");
        console.error(s);
        w.error = s;
      })).then((function() {
        b.unshift(w);
        r.apply(o, b);
      }));
    };
  };
  o._openTransactionSafely = function(s, r, o) {
    $t((function(s, r) {
      r(s.error, s.txn);
    }), s, r)(o);
  };
  o._remote = false;
  o.type = function() {
    return ADAPTER_NAME;
  };
  o._id = $((function(s, r) {
    r(null, u.db_uuid);
  }));
  o._info = $((function(s, r) {
    return info(u, r);
  }));
  o._get = $t(get);
  o._bulkDocs = $((function(r, g, _, b) {
    bulkDocs(o, g, _, u, s, idbChanges, b);
  }));
  o._allDocs = $t((function(s, r, o) {
    allDocs(s, u, r, o);
  }));
  o._getAttachment = $t(getAttachment);
  o._changes = $t((function(r, u) {
    changes2(r, idbChanges, o, s, u);
  }));
  o._getRevisionTree = $t(getRevisionTree);
  o._doCompaction = $t(doCompaction, [ DOC_STORE2 ], "readwrite");
  o._customFindAbstractMapper = {
    query: $p(query),
    viewCleanup: $p(viewCleanup)
  };
  o._destroy = function(r, o) {
    return destroy(s, openDatabases, idbChanges, o);
  };
  o._close = $((function(r, o) {
    delete openDatabases[s.name];
    r.close();
    o();
  }));
  o._freshen = function() {
    return new Promise((function(s) {
      o._close((function() {
        $(s)();
      }));
    }));
  };
  o._purge = $t(purge, [ DOC_STORE2 ], "readwrite");
  setTimeout((function() {
    r(null, o);
  }));
}

IdbPouch2.valid = function() {
  return true;
};

function index2(s) {
  s.adapter(ADAPTER_NAME, IdbPouch2, true);
}

var index_es_default3 = index2;

function pool(s, r) {
  return new Promise((function(o, u) {
    var g = 0, _ = 0, b = 0, w = s.length, E;
    function runNext() {
      g++;
      s[_++]().then(onSuccess, onError);
    }
    function doNext() {
      if (++b === w) if (E) u(E); else o(); else runNextBatch();
    }
    function onSuccess() {
      g--;
      doNext();
    }
    function onError(s) {
      g--;
      E = E || s;
      doNext();
    }
    function runNextBatch() {
      for (;g < r && _ < w; ) runNext();
    }
    runNextBatch();
  }));
}

var CHANGES_BATCH_SIZE = 25, MAX_SIMULTANEOUS_REVS = 50, CHANGES_TIMEOUT_BUFFER = 5e3, DEFAULT_HEARTBEAT = 1e4, supportsBulkGetMap = {};

function readAttachmentsAsBlobOrBuffer(s) {
  let r = s.doc || s.ok, o = r && r._attachments;
  if (!o) return;
  Object.keys(o).forEach((function(s) {
    let r = o[s];
    r.data = b64ToBluffer(r.data, r.content_type);
  }));
}

function encodeDocId(s) {
  if (/^_design/.test(s)) return "_design/" + encodeURIComponent(s.slice(8));
  if (/^_local/.test(s)) return "_local/" + encodeURIComponent(s.slice(7));
  return encodeURIComponent(s);
}

function preprocessAttachments2(s) {
  if (!s._attachments || !Object.keys(s._attachments)) return Promise.resolve();
  return Promise.all(Object.keys(s._attachments).map((function(r) {
    let o = s._attachments[r];
    if (o.data && "string" != typeof o.data) return new Promise((function(s) {
      blobToBase64(o.data, s);
    })).then((function(s) {
      o.data = s;
    }));
  })));
}

function hasUrlPrefix(s) {
  if (!s.prefix) return false;
  let r = parseUri(s.prefix).protocol;
  return "http" === r || "https" === r;
}

function getHost(s, r) {
  if (hasUrlPrefix(r)) {
    let o = r.name.substr(r.prefix.length), u;
    s = r.prefix.replace(/\/?$/, "/") + encodeURIComponent(o);
  }
  let o = parseUri(s);
  if (o.user || o.password) o.auth = {
    username: o.user,
    password: o.password
  };
  let u = o.path.replace(/(^\/|\/$)/g, "").split("/");
  o.db = u.pop();
  if (-1 === o.db.indexOf("%")) o.db = encodeURIComponent(o.db);
  o.path = u.join("/");
  return o;
}

function genDBUrl(s, r) {
  return genUrl(s, s.db + "/" + r);
}

function genUrl(s, r) {
  let o = !s.path ? "" : "/";
  return s.protocol + "://" + s.host + (s.port ? ":" + s.port : "") + "/" + s.path + o + r;
}

function paramsToStr(s) {
  return "?" + Object.keys(s).map((function(r) {
    return r + "=" + encodeURIComponent(s[r]);
  })).join("&");
}

function shouldCacheBust(s) {
  let r = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", o = -1 !== r.indexOf("msie"), u = -1 !== r.indexOf("trident"), g = -1 !== r.indexOf("edge"), _ = !("method" in s) || "GET" === s.method;
  return (o || u || g) && _;
}

function HttpPouch(s, r) {
  let o = this, u = getHost(s.name, s), g = genDBUrl(u, "");
  s = clone(s);
  const ourFetch = async function(r, o) {
    (o = o || {}).headers = o.headers || new h;
    o.credentials = "include";
    if (s.auth || u.auth) {
      let r = s.auth || u.auth, g = r.username + ":" + r.password, _ = thisBtoa(unescape(encodeURIComponent(g)));
      o.headers.set("Authorization", "Basic " + _);
    }
    let g = s.headers || {};
    Object.keys(g).forEach((function(s) {
      o.headers.append(s, g[s]);
    }));
    if (shouldCacheBust(o)) r += (-1 === r.indexOf("?") ? "?" : "&") + "_nonce=" + Date.now();
    let _ = s.fetch || f2;
    return await _(r, o);
  };
  function adapterFun$$1(s, r) {
    return adapterFun(s, (function(...s) {
      setup2().then((function() {
        return r.apply(this, s);
      })).catch((function(r) {
        let o;
        s.pop()(r);
      }));
    })).bind(o);
  }
  async function fetchJSON(s, r) {
    let o = {};
    (r = r || {}).headers = r.headers || new h;
    if (!r.headers.get("Content-Type")) r.headers.set("Content-Type", "application/json");
    if (!r.headers.get("Accept")) r.headers.set("Accept", "application/json");
    const u = await ourFetch(s, r);
    o.ok = u.ok;
    o.status = u.status;
    const g = await u.json();
    o.data = g;
    if (!o.ok) {
      o.data.status = o.status;
      let s;
      throw generateErrorFromResponse(o.data);
    }
    if (Array.isArray(o.data)) o.data = o.data.map((function(s) {
      if (s.error || s.missing) return generateErrorFromResponse(s); else return s;
    }));
    return o;
  }
  let _;
  async function setup2() {
    if (s.skip_setup) return Promise.resolve();
    if (_) return _;
    _ = fetchJSON(g).catch((function(s) {
      if (s && s.status && 404 === s.status) {
        explainError(404, "PouchDB is just detecting if the remote exists.");
        return fetchJSON(g, {
          method: "PUT"
        });
      } else return Promise.reject(s);
    })).catch((function(s) {
      if (s && s.status && 412 === s.status) return true;
      return Promise.reject(s);
    }));
    _.catch((function() {
      _ = null;
    }));
    return _;
  }
  (0, import_immediate.default)((function() {
    r(null, o);
  }));
  o._remote = true;
  o.type = function() {
    return "http";
  };
  o.id = adapterFun$$1("id", (async function(s) {
    let r, o;
    try {
      const s = await ourFetch(genUrl(u, ""));
      r = await s.json();
    } catch (s) {
      r = {};
    }
    s(null, r && r.uuid ? r.uuid + u.db : genDBUrl(u, ""));
  }));
  o.compact = adapterFun$$1("compact", (async function(s, r) {
    if ("function" == typeof s) {
      r = s;
      s = {};
    }
    s = clone(s);
    await fetchJSON(genDBUrl(u, "_compact"), {
      method: "POST"
    });
    function ping() {
      o.info((function(o, u) {
        if (u && !u.compact_running) r(null, {
          ok: true
        }); else setTimeout(ping, s.interval || 200);
      }));
    }
    ping();
  }));
  o.bulkGet = adapterFun("bulkGet", (function(s, r) {
    let o = this;
    async function doBulkGet(r) {
      let o = {};
      if (s.revs) o.revs = true;
      if (s.attachments) o.attachments = true;
      if (s.latest) o.latest = true;
      try {
        const g = await fetchJSON(genDBUrl(u, "_bulk_get" + paramsToStr(o)), {
          method: "POST",
          body: JSON.stringify({
            docs: s.docs
          })
        });
        if (s.attachments && s.binary) g.data.results.forEach((function(s) {
          s.docs.forEach(readAttachmentsAsBlobOrBuffer);
        }));
        r(null, g.data);
      } catch (s) {
        r(s);
      }
    }
    function doBulkGetShim() {
      let u = MAX_SIMULTANEOUS_REVS, g = Math.ceil(s.docs.length / u), _ = 0, b = new Array(g);
      function onResult(s) {
        return function(o, u) {
          b[s] = u.results;
          if (++_ === g) r(null, {
            results: flatten(b)
          });
        };
      }
      for (let r = 0; r < g; r++) {
        let g = pick(s, [ "revs", "attachments", "binary", "latest" ]);
        g.docs = s.docs.slice(r * u, Math.min(s.docs.length, (r + 1) * u));
        bulkGet(o, g, onResult(r));
      }
    }
    let g = genUrl(u, ""), _ = supportsBulkGetMap[g];
    if ("boolean" != typeof _) doBulkGet((function(s, o) {
      if (s) {
        supportsBulkGetMap[g] = false;
        explainError(s.status, "PouchDB is just detecting if the remote supports the _bulk_get API.");
        doBulkGetShim();
      } else {
        supportsBulkGetMap[g] = true;
        r(null, o);
      }
    })); else if (_) doBulkGet(r); else doBulkGetShim();
  }));
  o._info = async function(s) {
    try {
      await setup2();
      const r = await ourFetch(genDBUrl(u, "")), o = await r.json();
      o.host = genDBUrl(u, "");
      s(null, o);
    } catch (r) {
      s(r);
    }
  };
  o.fetch = async function(s, r) {
    await setup2();
    const o = "/" === s.substring(0, 1) ? genUrl(u, s.substring(1)) : genDBUrl(u, s);
    return ourFetch(o, r);
  };
  o.get = adapterFun$$1("get", (async function(s, r, o) {
    if ("function" == typeof r) {
      o = r;
      r = {};
    }
    let g = {};
    if ((r = clone(r)).revs) g.revs = true;
    if (r.revs_info) g.revs_info = true;
    if (r.latest) g.latest = true;
    if (r.open_revs) {
      if ("all" !== r.open_revs) r.open_revs = JSON.stringify(r.open_revs);
      g.open_revs = r.open_revs;
    }
    if (r.rev) g.rev = r.rev;
    if (r.conflicts) g.conflicts = r.conflicts;
    if (r.update_seq) g.update_seq = r.update_seq;
    s = encodeDocId(s);
    function fetchAttachments(s) {
      let o = s._attachments, g = o && Object.keys(o), _;
      if (!o || !g.length) return;
      async function fetchData(g) {
        const _ = o[g], b = encodeDocId(s._id) + "/" + encodeAttachmentId(g) + "?rev=" + s._rev, w = await ourFetch(genDBUrl(u, b));
        let E, S;
        if ("buffer" in w) E = await w.buffer(); else E = await w.blob();
        if (r.binary) {
          let s = Object.getOwnPropertyDescriptor(E.__proto__, "type");
          if (!s || s.set) E.type = _.content_type;
          S = E;
        } else S = await new Promise((function(s) {
          blobToBase64(E, s);
        }));
        delete _.stub;
        delete _.length;
        _.data = S;
      }
      return pool(g.map((function(s) {
        return function() {
          return fetchData(s);
        };
      })), 5);
    }
    function fetchAllAttachments(s) {
      if (Array.isArray(s)) return Promise.all(s.map((function(s) {
        if (s.ok) return fetchAttachments(s.ok);
      })));
      return fetchAttachments(s);
    }
    const _ = genDBUrl(u, s + paramsToStr(g));
    try {
      const s = await fetchJSON(_);
      if (r.attachments) await fetchAllAttachments(s.data);
      o(null, s.data);
    } catch (r) {
      r.docId = s;
      o(r);
    }
  }));
  o.remove = adapterFun$$1("remove", (async function(s, r, o, g) {
    let _;
    if ("string" == typeof r) {
      _ = {
        _id: s,
        _rev: r
      };
      if ("function" == typeof o) {
        g = o;
        o = {};
      }
    } else {
      _ = s;
      if ("function" == typeof r) {
        g = r;
        o = {};
      } else {
        g = o;
        o = r;
      }
    }
    const b = _._rev || o.rev, w = genDBUrl(u, encodeDocId(_._id)) + "?rev=" + b;
    try {
      const s = void 0;
      g(null, (await fetchJSON(w, {
        method: "DELETE"
      })).data);
    } catch (s) {
      g(s);
    }
  }));
  function encodeAttachmentId(s) {
    return s.split("/").map(encodeURIComponent).join("/");
  }
  o.getAttachment = adapterFun$$1("getAttachment", (async function(s, r, o, g) {
    if ("function" == typeof o) {
      g = o;
      o = {};
    }
    const _ = o.rev ? "?rev=" + o.rev : "", b = genDBUrl(u, encodeDocId(s)) + "/" + encodeAttachmentId(r) + _;
    let w;
    try {
      const s = await ourFetch(b, {
        method: "GET"
      });
      if (!s.ok) throw s;
      w = s.headers.get("content-type");
      let r;
      if ("undefined" != typeof process && !process.browser && "function" == typeof s.buffer) r = await s.buffer(); else r = await s.blob();
      if ("undefined" != typeof process && !process.browser) {
        var E = Object.getOwnPropertyDescriptor(r.__proto__, "type");
        if (!E || E.set) r.type = w;
      }
      g(null, r);
    } catch (s) {
      g(s);
    }
  }));
  o.removeAttachment = adapterFun$$1("removeAttachment", (async function(s, r, o, g) {
    const _ = genDBUrl(u, encodeDocId(s) + "/" + encodeAttachmentId(r)) + "?rev=" + o;
    try {
      const s = void 0;
      g(null, (await fetchJSON(_, {
        method: "DELETE"
      })).data);
    } catch (s) {
      g(s);
    }
  }));
  o.putAttachment = adapterFun$$1("putAttachment", (async function(s, r, o, g, _, b) {
    if ("function" == typeof _) {
      b = _;
      _ = g;
      g = o;
      o = null;
    }
    const w = encodeDocId(s) + "/" + encodeAttachmentId(r);
    let E = genDBUrl(u, w);
    if (o) E += "?rev=" + o;
    if ("string" == typeof g) {
      let s;
      try {
        s = thisAtob(g);
      } catch (s) {
        return b(createError(BAD_ARG, "Attachment is not a valid base64 string"));
      }
      g = s ? binStringToBluffer(s, _) : "";
    }
    try {
      const s = void 0;
      b(null, (await fetchJSON(E, {
        headers: new h({
          "Content-Type": _
        }),
        method: "PUT",
        body: g
      })).data);
    } catch (s) {
      b(s);
    }
  }));
  o._bulkDocs = async function(s, r, o) {
    s.new_edits = r.new_edits;
    try {
      await setup2();
      await Promise.all(s.docs.map(preprocessAttachments2));
      const r = void 0;
      o(null, (await fetchJSON(genDBUrl(u, "_bulk_docs"), {
        method: "POST",
        body: JSON.stringify(s)
      })).data);
    } catch (s) {
      o(s);
    }
  };
  o._put = async function(s, r, o) {
    try {
      await setup2();
      await preprocessAttachments2(s);
      const r = void 0;
      o(null, (await fetchJSON(genDBUrl(u, encodeDocId(s._id)), {
        method: "PUT",
        body: JSON.stringify(s)
      })).data);
    } catch (r) {
      r.docId = s && s._id;
      o(r);
    }
  };
  o.allDocs = adapterFun$$1("allDocs", (async function(s, r) {
    if ("function" == typeof s) {
      r = s;
      s = {};
    }
    let o = {}, g, _ = "GET";
    if ((s = clone(s)).conflicts) o.conflicts = true;
    if (s.update_seq) o.update_seq = true;
    if (s.descending) o.descending = true;
    if (s.include_docs) o.include_docs = true;
    if (s.attachments) o.attachments = true;
    if (s.key) o.key = JSON.stringify(s.key);
    if (s.start_key) s.startkey = s.start_key;
    if (s.startkey) o.startkey = JSON.stringify(s.startkey);
    if (s.end_key) s.endkey = s.end_key;
    if (s.endkey) o.endkey = JSON.stringify(s.endkey);
    if ("undefined" != typeof s.inclusive_end) o.inclusive_end = !!s.inclusive_end;
    if ("undefined" != typeof s.limit) o.limit = s.limit;
    if ("undefined" != typeof s.skip) o.skip = s.skip;
    let b = paramsToStr(o);
    if ("undefined" != typeof s.keys) {
      _ = "POST";
      g = {
        keys: s.keys
      };
    }
    try {
      const o = await fetchJSON(genDBUrl(u, "_all_docs" + b), {
        method: _,
        body: JSON.stringify(g)
      });
      if (s.include_docs && s.attachments && s.binary) o.data.rows.forEach(readAttachmentsAsBlobOrBuffer);
      r(null, o.data);
    } catch (s) {
      r(s);
    }
  }));
  o._changes = function(s) {
    let r = "batch_size" in s ? s.batch_size : CHANGES_BATCH_SIZE;
    if ((s = clone(s)).continuous && !("heartbeat" in s)) s.heartbeat = DEFAULT_HEARTBEAT;
    let o = "timeout" in s ? s.timeout : 3e4;
    if ("timeout" in s && s.timeout && o - s.timeout < CHANGES_TIMEOUT_BUFFER) o = s.timeout + CHANGES_TIMEOUT_BUFFER;
    if ("heartbeat" in s && s.heartbeat && o - s.heartbeat < CHANGES_TIMEOUT_BUFFER) o = s.heartbeat + CHANGES_TIMEOUT_BUFFER;
    let g = {};
    if ("timeout" in s && s.timeout) g.timeout = s.timeout;
    let _ = "undefined" != typeof s.limit ? s.limit : false, b = _;
    if (s.style) g.style = s.style;
    if (s.include_docs || s.filter && "function" == typeof s.filter) g.include_docs = true;
    if (s.attachments) g.attachments = true;
    if (s.continuous) g.feed = "longpoll";
    if (s.seq_interval) g.seq_interval = s.seq_interval;
    if (s.conflicts) g.conflicts = true;
    if (s.descending) g.descending = true;
    if (s.update_seq) g.update_seq = true;
    if ("heartbeat" in s) if (s.heartbeat) g.heartbeat = s.heartbeat;
    if (s.filter && "string" == typeof s.filter) g.filter = s.filter;
    if (s.view && "string" == typeof s.view) {
      g.filter = "_view";
      g.view = s.view;
    }
    if (s.query_params && "object" == typeof s.query_params) for (let r in s.query_params) if (Object.prototype.hasOwnProperty.call(s.query_params, r)) g[r] = s.query_params[r];
    let w = "GET", E;
    if (s.doc_ids) {
      g.filter = "_doc_ids";
      w = "POST";
      E = {
        doc_ids: s.doc_ids
      };
    } else if (s.selector) {
      g.filter = "_selector";
      w = "POST";
      E = {
        selector: s.selector
      };
    }
    let S = new a, L;
    const fetchData = async function(o, O) {
      if (s.aborted) return;
      g.since = o;
      if ("object" == typeof g.since) g.since = JSON.stringify(g.since);
      if (s.descending) {
        if (_) g.limit = b;
      } else g.limit = !_ || b > r ? r : b;
      let D = genDBUrl(u, "_changes" + paramsToStr(g)), k = {
        signal: S.signal,
        method: w,
        body: JSON.stringify(E)
      };
      L = o;
      if (s.aborted) return;
      try {
        await setup2();
        const s = void 0;
        O(null, (await fetchJSON(D, k)).data);
      } catch (s) {
        O(s);
      }
    };
    let O = {
      results: []
    };
    const fetched = function(o, u) {
      if (s.aborted) return;
      let g = 0;
      if (u && u.results) {
        g = u.results.length;
        O.last_seq = u.last_seq;
        let r = null, o = null, _;
        if ("number" == typeof u.pending) r = u.pending;
        if ("string" == typeof O.last_seq || "number" == typeof O.last_seq) o = O.last_seq;
        ({}).query = s.query_params;
        u.results = u.results.filter((function(u) {
          b--;
          let g = filterChange(s)(u);
          if (g) {
            if (s.include_docs && s.attachments && s.binary) readAttachmentsAsBlobOrBuffer(u);
            if (s.return_docs) O.results.push(u);
            s.onChange(u, r, o);
          }
          return g;
        }));
      } else if (o) {
        s.aborted = true;
        s.complete(o);
        return;
      }
      if (u && u.last_seq) L = u.last_seq;
      let w = _ && b <= 0 || u && g < r || s.descending;
      if (s.continuous && !(_ && b <= 0) || !w) (0, import_immediate.default)((function() {
        fetchData(L, fetched);
      })); else s.complete(null, O);
    };
    fetchData(s.since || 0, fetched);
    return {
      cancel: function() {
        s.aborted = true;
        S.abort();
      }
    };
  };
  o.revsDiff = adapterFun$$1("revsDiff", (async function(s, r, o) {
    if ("function" == typeof r) {
      o = r;
      r = {};
    }
    try {
      const r = void 0;
      o(null, (await fetchJSON(genDBUrl(u, "_revs_diff"), {
        method: "POST",
        body: JSON.stringify(s)
      })).data);
    } catch (s) {
      o(s);
    }
  }));
  o._close = function(s) {
    s();
  };
  o._destroy = async function(s, r) {
    try {
      const s = void 0;
      r(null, await fetchJSON(genDBUrl(u, ""), {
        method: "DELETE"
      }));
    } catch (s) {
      if (404 === s.status) r(null, {
        ok: true
      }); else r(s);
    }
  };
}

HttpPouch.valid = function() {
  return true;
};

function index3(s) {
  s.adapter("http", HttpPouch, false);
  s.adapter("https", HttpPouch, false);
}

var index_es_default4 = index3, QueryParseError = class _QueryParseError extends Error {
  constructor(s) {
    super();
    this.status = 400;
    this.name = "query_parse_error";
    this.message = s;
    this.error = true;
    try {
      Error.captureStackTrace(this, _QueryParseError);
    } catch (s) {}
  }
}, NotFoundError = class _NotFoundError extends Error {
  constructor(s) {
    super();
    this.status = 404;
    this.name = "not_found";
    this.message = s;
    this.error = true;
    try {
      Error.captureStackTrace(this, _NotFoundError);
    } catch (s) {}
  }
}, BuiltInError = class _BuiltInError extends Error {
  constructor(s) {
    super();
    this.status = 500;
    this.name = "invalid_value";
    this.message = s;
    this.error = true;
    try {
      Error.captureStackTrace(this, _BuiltInError);
    } catch (s) {}
  }
};

function promisedCallback(s, r) {
  if (r) s.then((function(s) {
    (0, import_immediate.default)((function() {
      r(null, s);
    }));
  }), (function(s) {
    (0, import_immediate.default)((function() {
      r(s);
    }));
  }));
  return s;
}

function callbackify(s) {
  return function(...r) {
    var o = r.pop(), u = s.apply(this, r);
    if ("function" == typeof o) promisedCallback(u, o);
    return u;
  };
}

function fin(s, r) {
  return s.then((function(s) {
    return r().then((function() {
      return s;
    }));
  }), (function(s) {
    return r().then((function() {
      throw s;
    }));
  }));
}

function sequentialize(s, r) {
  return function() {
    var o = arguments, u = this;
    return s.add((function() {
      return r.apply(u, o);
    }));
  };
}

function uniq(s) {
  var r = new ExportedSet(s), o = new Array(r.size), u = -1;
  r.forEach((function(s) {
    o[++u] = s;
  }));
  return o;
}

function mapToKeysArray(s) {
  var r = new Array(s.size), o = -1;
  s.forEach((function(s, u) {
    r[++o] = u;
  }));
  return r;
}

var TaskQueue2 = class {
  constructor() {
    this.promise = new Promise((function(s) {
      s();
    }));
  }
  add(s) {
    this.promise = this.promise.catch((function() {})).then((function() {
      return s();
    }));
    return this.promise;
  }
  finish() {
    return this.promise;
  }
};

function stringify2(s) {
  if (!s) return "undefined";
  switch (typeof s) {
   case "function":
    return s.toString();

   case "string":
    return s.toString();

   default:
    return JSON.stringify(s);
  }
}

function createViewSignature(s, r) {
  return stringify2(s) + stringify2(r) + "undefined";
}

async function createView(s, r, o, u, g, _) {
  const b = createViewSignature(o, u);
  let w;
  if (!g) {
    w = s._cachedViews = s._cachedViews || {};
    if (w[b]) return w[b];
  }
  const E = s.info().then((async function(E) {
    const S = E.db_name + "-mrview-" + (g ? "temp" : stringMd5(b));
    function diffFunction(s) {
      s.views = s.views || {};
      let o = r;
      if (-1 === o.indexOf("/")) o = r + "/" + r;
      const u = s.views[o] = s.views[o] || {};
      if (u[S]) return;
      u[S] = true;
      return s;
    }
    await upsert(s, "_local/" + _, diffFunction);
    const L = void 0, O = (await s.registerDependentDatabase(S)).db;
    O.auto_compaction = true;
    const D = {
      name: S,
      db: O,
      sourceDB: s,
      adapter: s.adapter,
      mapFun: o,
      reduceFun: u
    };
    let k;
    try {
      k = await D.db.get("_local/lastSeq");
    } catch (s) {
      if (404 !== s.status) throw s;
    }
    D.seq = k ? k.seq : 0;
    if (w) D.db.once("destroyed", (function() {
      delete w[b];
    }));
    return D;
  }));
  if (w) w[b] = E;
  return E;
}

var persistentQueues = {}, tempViewQueue = new TaskQueue2, CHANGES_BATCH_SIZE2 = 50;

function parseViewName(s) {
  return -1 === s.indexOf("/") ? [ s, s ] : s.split("/");
}

function isGenOne(s) {
  return 1 === s.length && /^1-/.test(s[0].rev);
}

function emitError(s, r, o) {
  try {
    s.emit("error", r);
  } catch (s) {
    guardedConsole("error", "The user's map/reduce function threw an uncaught error.\nYou can debug this error by doing:\nmyDatabase.on('error', function (err) { debugger; });\nPlease double-check your map/reduce function.");
    guardedConsole("error", r, o);
  }
}

function createAbstractMapReduce(s, r, o, u) {
  function tryMap(s, r, o) {
    try {
      r(o);
    } catch (u) {
      emitError(s, u, {
        fun: r,
        doc: o
      });
    }
  }
  function tryReduce(s, r, o, u, g) {
    try {
      return {
        output: r(o, u, g)
      };
    } catch (_) {
      emitError(s, _, {
        fun: r,
        keys: o,
        values: u,
        rereduce: g
      });
      return {
        error: _
      };
    }
  }
  function sortByKeyThenValue(s, r) {
    const o = collate(s.key, r.key);
    return 0 !== o ? o : collate(s.value, r.value);
  }
  function sliceResults(s, r, o) {
    o = o || 0;
    if ("number" == typeof r) return s.slice(o, r + o); else if (o > 0) return s.slice(o);
    return s;
  }
  function rowToDocId(s) {
    const r = s.value, o = void 0;
    return r && "object" == typeof r && r._id || s.id;
  }
  function readAttachmentsAsBlobOrBuffer2(s) {
    s.rows.forEach((function(s) {
      const r = s.doc && s.doc._attachments;
      if (!r) return;
      Object.keys(r).forEach((function(s) {
        const o = r[s];
        r[s].data = b64ToBluffer(o.data, o.content_type);
      }));
    }));
  }
  function postprocessAttachments(s) {
    return function(r) {
      if (s.include_docs && s.attachments && s.binary) readAttachmentsAsBlobOrBuffer2(r);
      return r;
    };
  }
  function addHttpParam(s, r, o, u) {
    let g = r[s];
    if ("undefined" != typeof g) {
      if (u) g = encodeURIComponent(JSON.stringify(g));
      o.push(s + "=" + g);
    }
  }
  function coerceInteger(s) {
    if ("undefined" != typeof s) {
      const r = Number(s);
      if (!isNaN(r) && r === parseInt(s, 10)) return r; else return s;
    }
  }
  function coerceOptions(s) {
    s.group_level = coerceInteger(s.group_level);
    s.limit = coerceInteger(s.limit);
    s.skip = coerceInteger(s.skip);
    return s;
  }
  function checkPositiveInteger(s) {
    if (s) {
      if ("number" != typeof s) return new QueryParseError(`Invalid value for integer: "${s}"`);
      if (s < 0) return new QueryParseError(`Invalid value for positive integer: "${s}"`);
    }
  }
  function checkQueryParseError(s, r) {
    const o = s.descending ? "endkey" : "startkey", u = s.descending ? "startkey" : "endkey";
    if ("undefined" != typeof s[o] && "undefined" != typeof s[u] && collate(s[o], s[u]) > 0) throw new QueryParseError("No rows can match your key range, reverse your start_key and end_key or set {descending : true}"); else if (r.reduce && false !== s.reduce) if (s.include_docs) throw new QueryParseError("{include_docs:true} is invalid for reduce"); else if (s.keys && s.keys.length > 1 && !s.group && !s.group_level) throw new QueryParseError("Multi-key fetches for reduce views must use {group: true}");
    [ "group_level", "limit", "skip" ].forEach((function(r) {
      const o = checkPositiveInteger(s[r]);
      if (o) throw o;
    }));
  }
  async function httpQuery(s, r, o) {
    let u = [], g, _ = "GET", b;
    addHttpParam("reduce", o, u);
    addHttpParam("include_docs", o, u);
    addHttpParam("attachments", o, u);
    addHttpParam("limit", o, u);
    addHttpParam("descending", o, u);
    addHttpParam("group", o, u);
    addHttpParam("group_level", o, u);
    addHttpParam("skip", o, u);
    addHttpParam("stale", o, u);
    addHttpParam("conflicts", o, u);
    addHttpParam("startkey", o, u, true);
    addHttpParam("start_key", o, u, true);
    addHttpParam("endkey", o, u, true);
    addHttpParam("end_key", o, u, true);
    addHttpParam("inclusive_end", o, u);
    addHttpParam("key", o, u, true);
    addHttpParam("update_seq", o, u);
    u = u.join("&");
    u = "" === u ? "" : "?" + u;
    if ("undefined" != typeof o.keys) {
      const s = 2e3, b = `keys=${encodeURIComponent(JSON.stringify(o.keys))}`;
      if (b.length + u.length + 1 <= s) u += ("?" === u[0] ? "&" : "?") + b; else {
        _ = "POST";
        if ("string" == typeof r) g = {
          keys: o.keys
        }; else r.keys = o.keys;
      }
    }
    if ("string" == typeof r) {
      const w = parseViewName(r), E = await s.fetch("_design/" + w[0] + "/_view/" + w[1] + u, {
        headers: new h({
          "Content-Type": "application/json"
        }),
        method: _,
        body: JSON.stringify(g)
      });
      b = E.ok;
      const S = await E.json();
      if (!b) {
        S.status = E.status;
        throw generateErrorFromResponse(S);
      }
      S.rows.forEach((function(s) {
        if (s.value && s.value.error && "builtin_reduce_error" === s.value.error) throw new Error(s.reason);
      }));
      return new Promise((function(s) {
        s(S);
      })).then(postprocessAttachments(o));
    }
    g = g || {};
    Object.keys(r).forEach((function(s) {
      if (Array.isArray(r[s])) g[s] = r[s]; else g[s] = r[s].toString();
    }));
    const w = await s.fetch("_temp_view" + u, {
      headers: new h({
        "Content-Type": "application/json"
      }),
      method: "POST",
      body: JSON.stringify(g)
    });
    b = w.ok;
    const E = await w.json();
    if (!b) {
      E.status = w.status;
      throw generateErrorFromResponse(E);
    }
    return new Promise((function(s) {
      s(E);
    })).then(postprocessAttachments(o));
  }
  function customQuery(s, r, o) {
    return new Promise((function(u, g) {
      s._query(r, o, (function(s, r) {
        if (s) return g(s);
        u(r);
      }));
    }));
  }
  function customViewCleanup(s) {
    return new Promise((function(r, o) {
      s._viewCleanup((function(s, u) {
        if (s) return o(s);
        r(u);
      }));
    }));
  }
  function defaultsTo(s) {
    return function(r) {
      if (404 === r.status) return s; else throw r;
    };
  }
  async function getDocsToPersist(s, r, o) {
    const u = "_local/doc_" + s, g = {
      _id: u,
      keys: []
    }, _ = o.get(s), b = _[0], w = _[1];
    function getMetaDoc() {
      if (isGenOne(w)) return Promise.resolve(g);
      return r.db.get(u).catch(defaultsTo(g));
    }
    function getKeyValueDocs(s) {
      if (!s.keys.length) return Promise.resolve({
        rows: []
      });
      return r.db.allDocs({
        keys: s.keys,
        include_docs: true
      });
    }
    function processKeyValueDocs(s, r) {
      const o = [], u = new ExportedSet;
      for (let s = 0, g = r.rows.length; s < g; s++) {
        const g = void 0, _ = r.rows[s].doc;
        if (!_) continue;
        o.push(_);
        u.add(_._id);
        _._deleted = !b.has(_._id);
        if (!_._deleted) {
          const s = b.get(_._id);
          if ("value" in s) _.value = s.value;
        }
      }
      const g = mapToKeysArray(b);
      g.forEach((function(s) {
        if (!u.has(s)) {
          const r = {
            _id: s
          }, u = b.get(s);
          if ("value" in u) r.value = u.value;
          o.push(r);
        }
      }));
      s.keys = uniq(g.concat(s.keys));
      o.push(s);
      return o;
    }
    const E = await getMetaDoc(), S = void 0;
    return processKeyValueDocs(E, await getKeyValueDocs(E));
  }
  function updatePurgeSeq(s) {
    return s.sourceDB.get("_local/purges").then((function(r) {
      const o = r.purgeSeq;
      return s.db.get("_local/purgeSeq").then((function(s) {
        return s._rev;
      })).catch((function(s) {
        if (404 !== s.status) throw s;
        return;
      })).then((function(r) {
        return s.db.put({
          _id: "_local/purgeSeq",
          _rev: r,
          purgeSeq: o
        });
      }));
    })).catch((function(s) {
      if (404 !== s.status) throw s;
    }));
  }
  function saveKeyValues(s, r, o) {
    var u = "_local/lastSeq";
    return s.db.get(u).catch(defaultsTo({
      _id: u,
      seq: 0
    })).then((function(u) {
      var g = mapToKeysArray(r);
      return Promise.all(g.map((function(o) {
        return getDocsToPersist(o, s, r);
      }))).then((function(r) {
        var g = flatten(r);
        u.seq = o;
        g.push(u);
        return s.db.bulkDocs({
          docs: g
        });
      })).then((() => updatePurgeSeq(s)));
    }));
  }
  function getQueue(s) {
    const r = "string" == typeof s ? s : s.name;
    let o = persistentQueues[r];
    if (!o) o = persistentQueues[r] = new TaskQueue2;
    return o;
  }
  async function updateView(s, r) {
    return sequentialize(getQueue(s), (function() {
      return updateViewInQueue(s, r);
    }))();
  }
  async function updateViewInQueue(s, o) {
    let u, g, _;
    function emit2(s, r) {
      const o = {
        id: g._id,
        key: normalizeKey(s)
      };
      if ("undefined" != typeof r && null !== r) o.value = normalizeKey(r);
      u.push(o);
    }
    const b = r(s.mapFun, emit2);
    let w = s.seq || 0;
    function createTask() {
      return s.sourceDB.info().then((function(r) {
        _ = s.sourceDB.activeTasks.add({
          name: "view_indexing",
          total_items: r.update_seq - w
        });
      }));
    }
    function processChange2(r, o) {
      return function() {
        return saveKeyValues(s, r, o);
      };
    }
    let E = 0;
    const S = {
      view: s.name,
      indexed_docs: E
    };
    s.sourceDB.emit("indexing", S);
    const L = new TaskQueue2;
    async function processNextBatch() {
      const r = void 0, u = void 0;
      return processBatch(await s.sourceDB.changes({
        return_docs: true,
        conflicts: true,
        include_docs: true,
        style: "all_docs",
        since: w,
        limit: o.changes_batch_size
      }), await getRecentPurges());
    }
    function getRecentPurges() {
      return s.db.get("_local/purgeSeq").then((function(s) {
        return s.purgeSeq;
      })).catch((function(s) {
        if (s && 404 !== s.status) throw s;
        return -1;
      })).then((function(r) {
        return s.sourceDB.get("_local/purges").then((function(o) {
          const u = o.purges.filter((function(s, o) {
            return o > r;
          })).map((s => s.docId)), g = u.filter((function(s, r) {
            return u.indexOf(s) === r;
          }));
          return Promise.all(g.map((function(r) {
            return s.sourceDB.get(r).then((function(s) {
              return {
                docId: r,
                doc: s
              };
            })).catch((function(s) {
              if (404 !== s.status) throw s;
              return {
                docId: r
              };
            }));
          })));
        })).catch((function(s) {
          if (s && 404 !== s.status) throw s;
          return [];
        }));
      }));
    }
    function processBatch(r, u) {
      var g = r.results;
      if (!g.length && !u.length) return;
      for (let s of u) {
        const r = void 0;
        if (g.findIndex((function(r) {
          return r.id === s.docId;
        })) < 0) {
          const r = {
            _id: s.docId,
            doc: {
              _id: s.docId,
              _deleted: 1
            },
            changes: []
          };
          if (s.doc) {
            r.doc = s.doc;
            r.changes.push({
              rev: s.doc._rev
            });
          }
          g.push(r);
        }
      }
      var b = createDocIdsToChangesAndEmits(g);
      L.add(processChange2(b, w));
      E += g.length;
      const S = {
        view: s.name,
        last_seq: r.last_seq,
        results_count: g.length,
        indexed_docs: E
      };
      s.sourceDB.emit("indexing", S);
      s.sourceDB.activeTasks.update(_, {
        completed_items: E
      });
      if (g.length < o.changes_batch_size) return;
      return processNextBatch();
    }
    function createDocIdsToChangesAndEmits(r) {
      const o = new ExportedMap;
      for (let _ = 0, E = r.length; _ < E; _++) {
        const E = r[_];
        if ("_" !== E.doc._id[0]) {
          u = [];
          g = E.doc;
          if (!g._deleted) tryMap(s.sourceDB, b, g);
          u.sort(sortByKeyThenValue);
          const r = createIndexableKeysToKeyValues(u);
          o.set(E.doc._id, [ r, E.changes ]);
        }
        w = E.seq;
      }
      return o;
    }
    function createIndexableKeysToKeyValues(s) {
      const r = new ExportedMap;
      let o;
      for (let u = 0, g = s.length; u < g; u++) {
        const g = s[u], _ = [ g.key, g.id ];
        if (u > 0 && 0 === collate(g.key, o)) _.push(u);
        r.set(toIndexableString(_), g);
        o = g.key;
      }
      return r;
    }
    try {
      await createTask();
      await processNextBatch();
      await L.finish();
      s.seq = w;
      s.sourceDB.activeTasks.remove(_);
    } catch (r) {
      s.sourceDB.activeTasks.remove(_, r);
    }
  }
  function reduceView(s, r, u) {
    if (0 === u.group_level) delete u.group_level;
    const g = u.group || u.group_level, _ = o(s.reduceFun), b = [], w = isNaN(u.group_level) ? Number.POSITIVE_INFINITY : u.group_level;
    r.forEach((function(s) {
      const r = b[b.length - 1];
      let o = g ? s.key : null;
      if (g && Array.isArray(o)) o = o.slice(0, w);
      if (r && 0 === collate(r.groupKey, o)) {
        r.keys.push([ s.key, s.id ]);
        r.values.push(s.value);
        return;
      }
      b.push({
        keys: [ [ s.key, s.id ] ],
        values: [ s.value ],
        groupKey: o
      });
    }));
    r = [];
    for (let o = 0, u = b.length; o < u; o++) {
      const u = b[o], g = tryReduce(s.sourceDB, _, u.keys, u.values, false);
      if (g.error && g.error instanceof BuiltInError) throw g.error;
      r.push({
        value: g.error ? null : g.output,
        key: u.groupKey
      });
    }
    return {
      rows: sliceResults(r, u.limit, u.skip)
    };
  }
  function queryView(s, r) {
    return sequentialize(getQueue(s), (function() {
      return queryViewInQueue(s, r);
    }))();
  }
  async function queryViewInQueue(s, r) {
    let o;
    const u = s.reduceFun && false !== r.reduce, g = r.skip || 0;
    if ("undefined" != typeof r.keys && !r.keys.length) {
      r.limit = 0;
      delete r.keys;
    }
    async function fetchFromView(r) {
      r.include_docs = true;
      const u = await s.db.allDocs(r);
      o = u.total_rows;
      return u.rows.map((function(s) {
        if ("value" in s.doc && "object" == typeof s.doc.value && null !== s.doc.value) {
          const r = Object.keys(s.doc.value).sort(), o = [ "id", "key", "value" ];
          if (!(r < o || r > o)) return s.doc.value;
        }
        const r = parseIndexableString(s.doc._id);
        return {
          key: r[0],
          id: r[1],
          value: "value" in s.doc ? s.doc.value : null
        };
      }));
    }
    async function onMapResultsReady(_) {
      let b;
      if (u) b = reduceView(s, _, r); else if ("undefined" == typeof r.keys) b = {
        total_rows: o,
        offset: g,
        rows: _
      }; else b = {
        total_rows: o,
        offset: g,
        rows: sliceResults(_, r.limit, r.skip)
      };
      if (r.update_seq) b.update_seq = s.seq;
      if (r.include_docs) {
        const o = uniq(_.map(rowToDocId)), u = await s.sourceDB.allDocs({
          keys: o,
          include_docs: true,
          conflicts: r.conflicts,
          attachments: r.attachments,
          binary: r.binary
        });
        var w = new ExportedMap;
        u.rows.forEach((function(s) {
          w.set(s.id, s.doc);
        }));
        _.forEach((function(s) {
          var r = rowToDocId(s), o = w.get(r);
          if (o) s.doc = o;
        }));
        return b;
      } else return b;
    }
    if ("undefined" != typeof r.keys) {
      const s = void 0, o = r.keys.map((function(s) {
        const o = {
          startkey: toIndexableString([ s ]),
          endkey: toIndexableString([ s, {} ])
        };
        if (r.update_seq) o.update_seq = true;
        return fetchFromView(o);
      })), u = void 0, g = void 0;
      return onMapResultsReady(flatten(await Promise.all(o)));
    } else {
      const s = {
        descending: r.descending
      };
      if (r.update_seq) s.update_seq = true;
      let o, _;
      if ("start_key" in r) o = r.start_key;
      if ("startkey" in r) o = r.startkey;
      if ("end_key" in r) _ = r.end_key;
      if ("endkey" in r) _ = r.endkey;
      if ("undefined" != typeof o) s.startkey = r.descending ? toIndexableString([ o, {} ]) : toIndexableString([ o ]);
      if ("undefined" != typeof _) {
        let o = false !== r.inclusive_end;
        if (r.descending) o = !o;
        s.endkey = toIndexableString(o ? [ _, {} ] : [ _ ]);
      }
      if ("undefined" != typeof r.key) {
        const o = toIndexableString([ r.key ]), u = toIndexableString([ r.key, {} ]);
        if (s.descending) {
          s.endkey = o;
          s.startkey = u;
        } else {
          s.startkey = o;
          s.endkey = u;
        }
      }
      if (!u) {
        if ("number" == typeof r.limit) s.limit = r.limit;
        s.skip = g;
      }
      const b = void 0;
      return onMapResultsReady(await fetchFromView(s));
    }
  }
  async function httpViewCleanup(s) {
    const r = void 0;
    return (await s.fetch("_view_cleanup", {
      headers: new h({
        "Content-Type": "application/json"
      }),
      method: "POST"
    })).json();
  }
  async function localViewCleanup(r) {
    try {
      const o = await r.get("_local/" + s), u = new ExportedMap;
      Object.keys(o.views).forEach((function(s) {
        const r = parseViewName(s), o = "_design/" + r[0], g = r[1];
        let _ = u.get(o);
        if (!_) {
          _ = new ExportedSet;
          u.set(o, _);
        }
        _.add(g);
      }));
      const g = {
        keys: mapToKeysArray(u),
        include_docs: true
      }, _ = await r.allDocs(g), b = {};
      _.rows.forEach((function(s) {
        const r = s.key.substring(8);
        u.get(s.key).forEach((function(u) {
          let g = r + "/" + u;
          if (!o.views[g]) g = u;
          const _ = Object.keys(o.views[g]), w = s.doc && s.doc.views && s.doc.views[u];
          _.forEach((function(s) {
            b[s] = b[s] || w;
          }));
        }));
      }));
      const w = void 0, E = Object.keys(b).filter((function(s) {
        return !b[s];
      })).map((function(s) {
        return sequentialize(getQueue(s), (function() {
          return new r.constructor(s, r.__opts).destroy();
        }))();
      }));
      return Promise.all(E).then((function() {
        return {
          ok: true
        };
      }));
    } catch (s) {
      if (404 === s.status) return {
        ok: true
      }; else throw s;
    }
  }
  async function queryPromised(r, o, g) {
    if ("function" == typeof r._query) return customQuery(r, o, g);
    if (isRemote(r)) return httpQuery(r, o, g);
    const _ = {
      changes_batch_size: r.__opts.view_update_changes_batch_size || CHANGES_BATCH_SIZE2
    };
    if ("string" != typeof o) {
      checkQueryParseError(g, o);
      tempViewQueue.add((async function() {
        const u = await createView(r, "temp_view/temp_view", o.map, o.reduce, true, s);
        return fin(updateView(u, _).then((function() {
          return queryView(u, g);
        })), (function() {
          return u.db.destroy();
        }));
      }));
      return tempViewQueue.finish();
    } else {
      const b = o, w = parseViewName(b), E = w[0], S = w[1], L = await r.get("_design/" + E);
      if (!(o = L.views && L.views[S])) throw new NotFoundError(`ddoc ${L._id} has no view named ${S}`);
      u(L, S);
      checkQueryParseError(g, o);
      const O = await createView(r, b, o.map, o.reduce, false, s);
      if ("ok" === g.stale || "update_after" === g.stale) {
        if ("update_after" === g.stale) (0, import_immediate.default)((function() {
          updateView(O, _);
        }));
        return queryView(O, g);
      } else {
        await updateView(O, _);
        return queryView(O, g);
      }
    }
  }
  function abstractQuery(s, r, o) {
    const u = this;
    if ("function" == typeof r) {
      o = r;
      r = {};
    }
    r = r ? coerceOptions(r) : {};
    if ("function" == typeof s) s = {
      map: s
    };
    const g = Promise.resolve().then((function() {
      return queryPromised(u, s, r);
    }));
    promisedCallback(g, o);
    return g;
  }
  const g = void 0;
  return {
    query: abstractQuery,
    viewCleanup: callbackify((function() {
      const s = this;
      if ("function" == typeof s._viewCleanup) return customViewCleanup(s);
      if (isRemote(s)) return httpViewCleanup(s);
      return localViewCleanup(s);
    }))
  };
}

var index_es_default5 = createAbstractMapReduce;

function createBuiltInError(s) {
  var r;
  return new BuiltInError("builtin " + s + " function requires map values to be numbers or number arrays");
}

function sum(s) {
  for (var r = 0, o = 0, u = s.length; o < u; o++) {
    var g = s[o];
    if ("number" != typeof g) if (Array.isArray(g)) {
      r = "number" == typeof r ? [ r ] : r;
      for (var _ = 0, b = g.length; _ < b; _++) {
        var w = g[_];
        if ("number" != typeof w) throw createBuiltInError("_sum"); else if ("undefined" == typeof r[_]) r.push(w); else r[_] += w;
      }
    } else throw createBuiltInError("_sum"); else if ("number" == typeof r) r += g; else r[0] += g;
  }
  return r;
}

var log = guardedConsole.bind(null, "log"), isArray = Array.isArray, toJSON = JSON.parse;

function evalFunctionWithEval(s, r) {
  return scopeEval("return (" + s.replace(/;\s*$/, "") + ");", {
    emit: r,
    sum,
    log,
    isArray,
    toJSON
  });
}

var builtInReduce = {
  _sum: function(s, r) {
    return sum(r);
  },
  _count: function(s, r) {
    return r.length;
  },
  _stats: function(s, r) {
    function sumsqr(s) {
      for (var r = 0, o = 0, u = s.length; o < u; o++) {
        var g = s[o];
        r += g * g;
      }
      return r;
    }
    return {
      sum: sum(r),
      min: Math.min.apply(null, r),
      max: Math.max.apply(null, r),
      count: r.length,
      sumsqr: sumsqr(r)
    };
  }
};

function getBuiltIn(s) {
  if (/^_sum/.test(s)) return builtInReduce._sum; else if (/^_count/.test(s)) return builtInReduce._count; else if (/^_stats/.test(s)) return builtInReduce._stats; else if (/^_/.test(s)) throw new Error(s + " is not a supported reduce function.");
}

function mapper(s, r) {
  if ("function" == typeof s && 2 === s.length) {
    var o = s;
    return function(s) {
      return o(s, r);
    };
  } else return evalFunctionWithEval(s.toString(), r);
}

function reducer(s) {
  var r = s.toString(), o = getBuiltIn(r);
  if (o) return o; else return evalFunctionWithEval(r);
}

function ddocValidator(s, r) {
  var o = s.views && s.views[r];
  if ("string" != typeof o.map) throw new NotFoundError("ddoc " + s._id + " has no string view named " + r + ", instead found object of type: " + typeof o.map);
}

var localDocName = "mrviews", abstract = index_es_default5(localDocName, mapper, reducer, ddocValidator);

function query2(s, r, o) {
  return abstract.query.call(this, s, r, o);
}

function viewCleanup2(s) {
  return abstract.viewCleanup.call(this, s);
}

var index4 = {
  query: query2,
  viewCleanup: viewCleanup2
}, index_browser_es_default2 = index4, CHECKPOINT_VERSION = 1, REPLICATOR = "pouchdb", CHECKPOINT_HISTORY_SIZE = 5, LOWEST_SEQ = 0;

function updateCheckpoint(s, r, o, u, g) {
  return s.get(r).catch((function(o) {
    if (404 === o.status) {
      if ("http" === s.adapter || "https" === s.adapter) explainError(404, "PouchDB is just checking if a remote checkpoint exists.");
      return {
        session_id: u,
        _id: r,
        history: [],
        replicator: REPLICATOR,
        version: CHECKPOINT_VERSION
      };
    }
    throw o;
  })).then((function(_) {
    if (g.cancelled) return;
    if (_.last_seq === o) return;
    _.history = (_.history || []).filter((function(s) {
      return s.session_id !== u;
    }));
    _.history.unshift({
      last_seq: o,
      session_id: u
    });
    _.history = _.history.slice(0, CHECKPOINT_HISTORY_SIZE);
    _.version = CHECKPOINT_VERSION;
    _.replicator = REPLICATOR;
    _.session_id = u;
    _.last_seq = o;
    return s.put(_).catch((function(_) {
      if (409 === _.status) return updateCheckpoint(s, r, o, u, g);
      throw _;
    }));
  }));
}

var CheckpointerInternal = class {
  constructor(s, r, o, u, g) {
    this.src = s;
    this.target = r;
    this.id = o;
    this.returnValue = u;
    this.opts = g || {};
  }
  writeCheckpoint(s, r) {
    var o = this;
    return this.updateTarget(s, r).then((function() {
      return o.updateSource(s, r);
    }));
  }
  updateTarget(s, r) {
    if (this.opts.writeTargetCheckpoint) return updateCheckpoint(this.target, this.id, s, r, this.returnValue); else return Promise.resolve(true);
  }
  updateSource(s, r) {
    if (this.opts.writeSourceCheckpoint) {
      var o = this;
      return updateCheckpoint(this.src, this.id, s, r, this.returnValue).catch((function(s) {
        if (isForbiddenError(s)) {
          o.opts.writeSourceCheckpoint = false;
          return true;
        }
        throw s;
      }));
    } else return Promise.resolve(true);
  }
  getCheckpoint() {
    var s = this;
    if (s.opts && s.opts.writeSourceCheckpoint && !s.opts.writeTargetCheckpoint) return s.src.get(s.id).then((function(s) {
      return s.last_seq || LOWEST_SEQ;
    })).catch((function(s) {
      if (404 !== s.status) throw s;
      return LOWEST_SEQ;
    }));
    return s.target.get(s.id).then((function(r) {
      if (s.opts && s.opts.writeTargetCheckpoint && !s.opts.writeSourceCheckpoint) return r.last_seq || LOWEST_SEQ;
      return s.src.get(s.id).then((function(s) {
        if (r.version !== s.version) return LOWEST_SEQ;
        var o;
        if (r.version) o = r.version.toString(); else o = "undefined";
        if (o in comparisons) return comparisons[o](r, s);
        return LOWEST_SEQ;
      }), (function(o) {
        if (404 === o.status && r.last_seq) return s.src.put({
          _id: s.id,
          last_seq: LOWEST_SEQ
        }).then((function() {
          return LOWEST_SEQ;
        }), (function(o) {
          if (isForbiddenError(o)) {
            s.opts.writeSourceCheckpoint = false;
            return r.last_seq;
          }
          return LOWEST_SEQ;
        }));
        throw o;
      }));
    })).catch((function(s) {
      if (404 !== s.status) throw s;
      return LOWEST_SEQ;
    }));
  }
}, comparisons = {
  undefined: function(s, r) {
    if (0 === collate(s.last_seq, r.last_seq)) return r.last_seq;
    return 0;
  },
  1: function(s, r) {
    return compareReplicationLogs(r, s).last_seq;
  }
};

function compareReplicationLogs(s, r) {
  if (s.session_id === r.session_id) return {
    last_seq: s.last_seq,
    history: s.history
  };
  return compareReplicationHistory(s.history, r.history);
}

function compareReplicationHistory(s, r) {
  var o = s[0], u = s.slice(1), g = r[0], _ = r.slice(1), b, w;
  if (!o || 0 === r.length) return {
    last_seq: LOWEST_SEQ,
    history: []
  };
  if (hasSessionId(o.session_id, r)) return {
    last_seq: o.last_seq,
    history: s
  };
  if (hasSessionId(g.session_id, u)) return {
    last_seq: g.last_seq,
    history: _
  };
  return compareReplicationHistory(u, _);
}

function hasSessionId(s, r) {
  var o = r[0], u = r.slice(1);
  if (!s || 0 === r.length) return false;
  if (s === o.session_id) return true;
  return hasSessionId(s, u);
}

function isForbiddenError(s) {
  return "number" == typeof s.status && 4 === Math.floor(s.status / 100);
}

function Checkpointer(s, r, o, u, g) {
  if (!(this instanceof CheckpointerInternal)) return new CheckpointerInternal(s, r, o, u, g);
  return Checkpointer;
}

var index_es_default6 = Checkpointer;

function sortObjectPropertiesByKey(s) {
  return Object.keys(s).sort(collate).reduce((function(r, o) {
    r[o] = s[o];
    return r;
  }), {});
}

function generateReplicationId(s, r, o) {
  var u = o.doc_ids ? o.doc_ids.sort(collate) : "", g = o.filter ? o.filter.toString() : "", _ = "", b = "", w = "";
  if (o.selector) w = JSON.stringify(o.selector);
  if (o.filter && o.query_params) _ = JSON.stringify(sortObjectPropertiesByKey(o.query_params));
  if (o.filter && "_view" === o.filter) b = o.view.toString();
  return Promise.all([ s.id(), r.id() ]).then((function(s) {
    var r = s[0] + s[1] + g + b + _ + u + w;
    return new Promise((function(s) {
      binaryMd5(r, s);
    }));
  })).then((function(s) {
    return "_local/" + (s = s.replace(/\//g, ".").replace(/\+/g, "_"));
  }));
}

var index_es_default7 = generateReplicationId, import_events3 = __toESM(require_events());

function fileHasChanged(s, r, o) {
  return !s._attachments || !s._attachments[o] || s._attachments[o].digest !== r._attachments[o].digest;
}

function getDocAttachments(s, r) {
  var o = Object.keys(r._attachments);
  return Promise.all(o.map((function(o) {
    return s.getAttachment(r._id, o, {
      rev: r._rev
    });
  })));
}

function getDocAttachmentsFromTargetOrSource(s, r, o) {
  var u = isRemote(r) && !isRemote(s), g = Object.keys(o._attachments);
  if (!u) return getDocAttachments(r, o);
  return s.get(o._id).then((function(u) {
    return Promise.all(g.map((function(g) {
      if (fileHasChanged(u, o, g)) return r.getAttachment(o._id, g);
      return s.getAttachment(u._id, g);
    })));
  })).catch((function(s) {
    if (404 !== s.status) throw s;
    return getDocAttachments(r, o);
  }));
}

function createBulkGetOpts(s) {
  var r = [];
  Object.keys(s).forEach((function(o) {
    var u;
    s[o].missing.forEach((function(s) {
      r.push({
        id: o,
        rev: s
      });
    }));
  }));
  return {
    docs: r,
    revs: true,
    latest: true
  };
}

function getDocs(s, r, o, u) {
  o = clone(o);
  var g = [], _ = true;
  function getAllDocs() {
    var b = createBulkGetOpts(o);
    if (!b.docs.length) return;
    return s.bulkGet(b).then((function(o) {
      if (u.cancelled) throw new Error("cancelled");
      return Promise.all(o.results.map((function(o) {
        return Promise.all(o.docs.map((function(o) {
          var u = o.ok;
          if (o.error) _ = false;
          if (!u || !u._attachments) return u;
          return getDocAttachmentsFromTargetOrSource(r, s, u).then((function(s) {
            var r = Object.keys(u._attachments);
            s.forEach((function(s, o) {
              var g = u._attachments[r[o]];
              delete g.stub;
              delete g.length;
              g.data = s;
            }));
            return u;
          }));
        })));
      }))).then((function(s) {
        g = g.concat(flatten(s).filter(Boolean));
      }));
    }));
  }
  function returnResult() {
    return {
      ok: _,
      docs: g
    };
  }
  return Promise.resolve().then(getAllDocs).then(returnResult);
}

var STARTING_BACK_OFF = 0;

function backOff(s, r, o, u) {
  if (false === s.retry) {
    r.emit("error", o);
    r.removeAllListeners();
    return;
  }
  if ("function" != typeof s.back_off_function) s.back_off_function = defaultBackOff;
  r.emit("requestError", o);
  if ("active" === r.state || "pending" === r.state) {
    r.emit("paused", o);
    r.state = "stopped";
    var g = function backoffTimeSet() {
      s.current_back_off = STARTING_BACK_OFF;
    }, _ = function removeBackOffTimeSet() {
      r.removeListener("active", g);
    };
    r.once("paused", _);
    r.once("active", g);
  }
  s.current_back_off = s.current_back_off || STARTING_BACK_OFF;
  s.current_back_off = s.back_off_function(s.current_back_off);
  setTimeout(u, s.current_back_off);
}

function replicate(s, r, o, u, g) {
  var _ = [], b, w = {
    seq: 0,
    changes: [],
    docs: []
  }, E = false, S = false, L = false, O = 0, D = 0, k = o.continuous || o.live || false, C = o.batch_size || 100, T = o.batches_limit || 10, I = o.style || "all_docs", A = false, x = o.doc_ids, R = o.selector, P, N, B = [], F = uuid(), M;
  g = g || {
    ok: true,
    start_time: (new Date).toISOString(),
    docs_read: 0,
    docs_written: 0,
    doc_write_failures: 0,
    errors: []
  };
  var V = {};
  u.ready(s, r);
  function initCheckpointer() {
    if (N) return Promise.resolve();
    return index_es_default7(s, r, o).then((function(g) {
      P = g;
      var _ = {};
      if (false === o.checkpoint) _ = {
        writeSourceCheckpoint: false,
        writeTargetCheckpoint: false
      }; else if ("source" === o.checkpoint) _ = {
        writeSourceCheckpoint: true,
        writeTargetCheckpoint: false
      }; else if ("target" === o.checkpoint) _ = {
        writeSourceCheckpoint: false,
        writeTargetCheckpoint: true
      }; else _ = {
        writeSourceCheckpoint: true,
        writeTargetCheckpoint: true
      };
      N = new index_es_default6(s, r, P, u, _);
    }));
  }
  function writeDocs() {
    B = [];
    if (0 === b.docs.length) return;
    var s = b.docs, _ = {
      timeout: o.timeout
    };
    return r.bulkDocs({
      docs: s,
      new_edits: false
    }, _).then((function(r) {
      if (u.cancelled) {
        completeReplication();
        throw new Error("cancelled");
      }
      var o = Object.create(null);
      r.forEach((function(s) {
        if (s.error) o[s.id] = s;
      }));
      var _ = Object.keys(o).length;
      g.doc_write_failures += _;
      g.docs_written += s.length - _;
      s.forEach((function(s) {
        var r = o[s._id];
        if (r) {
          g.errors.push(r);
          var _ = (r.name || "").toLowerCase();
          if ("unauthorized" === _ || "forbidden" === _) u.emit("denied", clone(r)); else throw r;
        } else B.push(s);
      }));
    }), (function(r) {
      g.doc_write_failures += s.length;
      throw r;
    }));
  }
  function finishBatch() {
    if (b.error) throw new Error("There was a problem getting docs.");
    g.last_seq = D = b.seq;
    var r = clone(g);
    if (B.length) {
      r.docs = B;
      if ("number" == typeof b.pending) {
        r.pending = b.pending;
        delete b.pending;
      }
      u.emit("change", r);
    }
    E = true;
    s.info().then((function(r) {
      var o = s.activeTasks.get(M);
      if (!b || !o) return;
      var u = o.completed_items || 0, g = parseInt(r.update_seq, 10) - parseInt(O, 10);
      s.activeTasks.update(M, {
        completed_items: u + b.changes.length,
        total_items: g
      });
    }));
    return N.writeCheckpoint(b.seq, F).then((function() {
      u.emit("checkpoint", {
        checkpoint: b.seq
      });
      E = false;
      if (u.cancelled) {
        completeReplication();
        throw new Error("cancelled");
      }
      b = void 0;
      getChanges();
    })).catch((function(s) {
      onCheckpointError(s);
      throw s;
    }));
  }
  function getDiffs() {
    var s = {};
    b.changes.forEach((function(r) {
      u.emit("checkpoint", {
        revs_diff: r
      });
      if ("_user/" === r.id) return;
      s[r.id] = r.changes.map((function(s) {
        return s.rev;
      }));
    }));
    return r.revsDiff(s).then((function(s) {
      if (u.cancelled) {
        completeReplication();
        throw new Error("cancelled");
      }
      b.diffs = s;
    }));
  }
  function getBatchDocs() {
    return getDocs(s, r, b.diffs, u).then((function(s) {
      b.error = !s.ok;
      s.docs.forEach((function(s) {
        delete b.diffs[s._id];
        g.docs_read++;
        b.docs.push(s);
      }));
    }));
  }
  function startNextBatch() {
    if (u.cancelled || b) return;
    if (0 === _.length) {
      processPendingBatch(true);
      return;
    }
    b = _.shift();
    u.emit("checkpoint", {
      start_next_batch: b.seq
    });
    getDiffs().then(getBatchDocs).then(writeDocs).then(finishBatch).then(startNextBatch).catch((function(s) {
      abortReplication("batch processing terminated with error", s);
    }));
  }
  function processPendingBatch(s) {
    if (0 === w.changes.length) {
      if (0 === _.length && !b) {
        if (k && V.live || S) {
          u.state = "pending";
          u.emit("paused");
        }
        if (S) completeReplication();
      }
      return;
    }
    if (s || S || w.changes.length >= C) {
      _.push(w);
      w = {
        seq: 0,
        changes: [],
        docs: []
      };
      if ("pending" === u.state || "stopped" === u.state) {
        u.state = "active";
        u.emit("active");
      }
      startNextBatch();
    }
  }
  function abortReplication(s, r) {
    if (L) return;
    if (!r.message) r.message = s;
    g.ok = false;
    g.status = "aborting";
    _ = [];
    w = {
      seq: 0,
      changes: [],
      docs: []
    };
    completeReplication(r);
  }
  function completeReplication(_) {
    if (L) return;
    if (u.cancelled) {
      g.status = "cancelled";
      if (E) return;
    }
    g.status = g.status || "complete";
    g.end_time = (new Date).toISOString();
    g.last_seq = D;
    L = true;
    s.activeTasks.remove(M, _);
    if (_) {
      (_ = createError(_)).result = g;
      var b = (_.name || "").toLowerCase();
      if ("unauthorized" === b || "forbidden" === b) {
        u.emit("error", _);
        u.removeAllListeners();
      } else backOff(o, u, _, (function() {
        replicate(s, r, o, u);
      }));
    } else {
      u.emit("complete", g);
      u.removeAllListeners();
    }
  }
  function onChange(r, g, b) {
    if (u.cancelled) return completeReplication();
    if ("number" == typeof g) w.pending = g;
    var E;
    if (!filterChange(o)(r)) {
      var S = s.activeTasks.get(M);
      if (S) {
        var L = S.completed_items || 0;
        s.activeTasks.update(M, {
          completed_items: ++L
        });
      }
      return;
    }
    w.seq = r.seq || b;
    w.changes.push(r);
    u.emit("checkpoint", {
      pending_batch: w.seq
    });
    (0, import_immediate.default)((function() {
      processPendingBatch(0 === _.length && V.live);
    }));
  }
  function onChangesComplete(s) {
    A = false;
    if (u.cancelled) return completeReplication();
    if (s.results.length > 0) {
      V.since = s.results[s.results.length - 1].seq;
      getChanges();
      processPendingBatch(true);
    } else {
      var complete = function() {
        if (k) {
          V.live = true;
          getChanges();
        } else S = true;
        processPendingBatch(true);
      };
      if (!b && 0 === s.results.length) {
        E = true;
        N.writeCheckpoint(s.last_seq, F).then((function() {
          E = false;
          g.last_seq = D = s.last_seq;
          if (u.cancelled) {
            completeReplication();
            throw new Error("cancelled");
          } else complete();
        })).catch(onCheckpointError);
      } else complete();
    }
  }
  function onChangesError(s) {
    A = false;
    if (u.cancelled) return completeReplication();
    abortReplication("changes rejected", s);
  }
  function getChanges() {
    if (!(!A && !S && _.length < T)) return;
    A = true;
    function abortChanges() {
      r.cancel();
    }
    function removeListener() {
      u.removeListener("cancel", abortChanges);
    }
    if (u._changes) {
      u.removeListener("cancel", u._abortChanges);
      u._changes.cancel();
    }
    u.once("cancel", abortChanges);
    var r = s.changes(V).on("change", onChange);
    r.then(removeListener, removeListener);
    r.then(onChangesComplete).catch(onChangesError);
    if (o.retry) {
      u._changes = r;
      u._abortChanges = abortChanges;
    }
  }
  function createTask(r) {
    return s.info().then((function(u) {
      var g = "undefined" == typeof o.since ? parseInt(u.update_seq, 10) - parseInt(r, 10) : parseInt(u.update_seq, 10);
      M = s.activeTasks.add({
        name: `${k ? "continuous " : ""}replication from ${u.db_name}`,
        total_items: g
      });
      return r;
    }));
  }
  function startChanges() {
    initCheckpointer().then((function() {
      if (u.cancelled) {
        completeReplication();
        return;
      }
      return N.getCheckpoint().then(createTask).then((function(s) {
        O = s;
        V = {
          since: D = s,
          limit: C,
          batch_size: C,
          style: I,
          doc_ids: x,
          selector: R,
          return_docs: true
        };
        if (o.filter) if ("string" != typeof o.filter) V.include_docs = true; else V.filter = o.filter;
        if ("heartbeat" in o) V.heartbeat = o.heartbeat;
        if ("timeout" in o) V.timeout = o.timeout;
        if (o.query_params) V.query_params = o.query_params;
        if (o.view) V.view = o.view;
        getChanges();
      }));
    })).catch((function(s) {
      abortReplication("getCheckpoint rejected with ", s);
    }));
  }
  function onCheckpointError(s) {
    E = false;
    abortReplication("writeCheckpoint completed with error", s);
  }
  if (u.cancelled) {
    completeReplication();
    return;
  }
  if (!u._addedListeners) {
    u.once("cancel", completeReplication);
    if ("function" == typeof o.complete) {
      u.once("error", o.complete);
      u.once("complete", (function(s) {
        o.complete(null, s);
      }));
    }
    u._addedListeners = true;
  }
  if ("undefined" == typeof o.since) startChanges(); else initCheckpointer().then((function() {
    E = true;
    return N.writeCheckpoint(o.since, F);
  })).then((function() {
    E = false;
    if (u.cancelled) {
      completeReplication();
      return;
    }
    D = o.since;
    startChanges();
  })).catch(onCheckpointError);
}

var Replication = class extends import_events3.default {
  constructor() {
    super();
    this.cancelled = false;
    this.state = "pending";
    const s = new Promise(((s, r) => {
      this.once("complete", s);
      this.once("error", r);
    }));
    this.then = function(r, o) {
      return s.then(r, o);
    };
    this.catch = function(r) {
      return s.catch(r);
    };
    this.catch((function() {}));
  }
  cancel() {
    this.cancelled = true;
    this.state = "cancelled";
    this.emit("cancel");
  }
  ready(s, r) {
    if (this._readyCalled) return;
    this._readyCalled = true;
    const onDestroy2 = () => {
      this.cancel();
    };
    s.once("destroyed", onDestroy2);
    r.once("destroyed", onDestroy2);
    function cleanup() {
      s.removeListener("destroyed", onDestroy2);
      r.removeListener("destroyed", onDestroy2);
    }
    this.once("complete", cleanup);
    this.once("error", cleanup);
  }
};

function toPouch(s, r) {
  var o = r.PouchConstructor;
  if ("string" == typeof s) return new o(s, r); else return s;
}

function replicateWrapper(s, r, o, u) {
  if ("function" == typeof o) {
    u = o;
    o = {};
  }
  if ("undefined" == typeof o) o = {};
  if (o.doc_ids && !Array.isArray(o.doc_ids)) throw createError(BAD_REQUEST, "`doc_ids` filter parameter is not a list.");
  o.complete = u;
  (o = clone(o)).continuous = o.continuous || o.live;
  o.retry = "retry" in o ? o.retry : false;
  o.PouchConstructor = o.PouchConstructor || this;
  var g = new Replication(o), _, b;
  replicate(toPouch(s, o), toPouch(r, o), o, g);
  return g;
}

function sync(s, r, o, u) {
  if ("function" == typeof o) {
    u = o;
    o = {};
  }
  if ("undefined" == typeof o) o = {};
  (o = clone(o)).PouchConstructor = o.PouchConstructor || this;
  s = toPouch(s, o);
  r = toPouch(r, o);
  return new Sync(s, r, o, u);
}

var Sync = class extends import_events3.default {
  constructor(s, r, o, u) {
    super();
    this.canceled = false;
    const g = o.push ? assign$2({}, o, o.push) : o, _ = o.pull ? assign$2({}, o, o.pull) : o;
    this.push = replicateWrapper(s, r, g);
    this.pull = replicateWrapper(r, s, _);
    this.pushPaused = true;
    this.pullPaused = true;
    const pullChange = s => {
      this.emit("change", {
        direction: "pull",
        change: s
      });
    }, pushChange = s => {
      this.emit("change", {
        direction: "push",
        change: s
      });
    }, pushDenied = s => {
      this.emit("denied", {
        direction: "push",
        doc: s
      });
    }, pullDenied = s => {
      this.emit("denied", {
        direction: "pull",
        doc: s
      });
    }, pushPaused = () => {
      this.pushPaused = true;
      if (this.pullPaused) this.emit("paused");
    }, pullPaused = () => {
      this.pullPaused = true;
      if (this.pushPaused) this.emit("paused");
    }, pushActive = () => {
      this.pushPaused = false;
      if (this.pullPaused) this.emit("active", {
        direction: "push"
      });
    }, pullActive = () => {
      this.pullPaused = false;
      if (this.pushPaused) this.emit("active", {
        direction: "pull"
      });
    };
    let b = {};
    const removeAll = s => (r, o) => {
      const u = void 0, g = void 0, _ = void 0, w = void 0;
      if ("change" === r && (o === pullChange || o === pushChange) || "denied" === r && (o === pullDenied || o === pushDenied) || "paused" === r && (o === pullPaused || o === pushPaused) || "active" === r && (o === pullActive || o === pushActive)) {
        if (!(r in b)) b[r] = {};
        b[r][s] = true;
        if (2 === Object.keys(b[r]).length) this.removeAllListeners(r);
      }
    };
    if (o.live) {
      this.push.on("complete", this.pull.cancel.bind(this.pull));
      this.pull.on("complete", this.push.cancel.bind(this.push));
    }
    function addOneListener(s, r, o) {
      if (-1 == s.listeners(r).indexOf(o)) s.on(r, o);
    }
    this.on("newListener", (function(s) {
      if ("change" === s) {
        addOneListener(this.pull, "change", pullChange);
        addOneListener(this.push, "change", pushChange);
      } else if ("denied" === s) {
        addOneListener(this.pull, "denied", pullDenied);
        addOneListener(this.push, "denied", pushDenied);
      } else if ("active" === s) {
        addOneListener(this.pull, "active", pullActive);
        addOneListener(this.push, "active", pushActive);
      } else if ("paused" === s) {
        addOneListener(this.pull, "paused", pullPaused);
        addOneListener(this.push, "paused", pushPaused);
      }
    }));
    this.on("removeListener", (function(s) {
      if ("change" === s) {
        this.pull.removeListener("change", pullChange);
        this.push.removeListener("change", pushChange);
      } else if ("denied" === s) {
        this.pull.removeListener("denied", pullDenied);
        this.push.removeListener("denied", pushDenied);
      } else if ("active" === s) {
        this.pull.removeListener("active", pullActive);
        this.push.removeListener("active", pushActive);
      } else if ("paused" === s) {
        this.pull.removeListener("paused", pullPaused);
        this.push.removeListener("paused", pushPaused);
      }
    }));
    this.pull.on("removeListener", removeAll("pull"));
    this.push.on("removeListener", removeAll("push"));
    const w = Promise.all([ this.push, this.pull ]).then((s => {
      const r = {
        push: s[0],
        pull: s[1]
      };
      this.emit("complete", r);
      if (u) u(null, r);
      this.removeAllListeners();
      return r;
    }), (s => {
      this.cancel();
      if (u) u(s); else this.emit("error", s);
      this.removeAllListeners();
      if (u) throw s;
    }));
    this.then = function(s, r) {
      return w.then(s, r);
    };
    this.catch = function(s) {
      return w.catch(s);
    };
  }
  cancel() {
    if (!this.canceled) {
      this.canceled = true;
      this.push.cancel();
      this.pull.cancel();
    }
  }
};

function replication(s) {
  s.replicate = replicateWrapper;
  s.sync = sync;
  Object.defineProperty(s.prototype, "replicate", {
    get: function() {
      var s = this;
      if ("undefined" == typeof this.replicateMethods) this.replicateMethods = {
        from: function(r, o, u) {
          return s.constructor.replicate(r, s, o, u);
        },
        to: function(r, o, u) {
          return s.constructor.replicate(s, r, o, u);
        }
      };
      return this.replicateMethods;
    }
  });
  s.prototype.sync = function(s, r, o) {
    return this.constructor.sync(this, s, r, o);
  };
}

var index_es_default8 = replication;

function massageCreateIndexRequest(s) {
  if (!(s = clone(s)).index) s.index = {};
  [ "type", "name", "ddoc" ].forEach((function(r) {
    if (s.index[r]) {
      s[r] = s.index[r];
      delete s.index[r];
    }
  }));
  if (s.fields) {
    s.index.fields = s.fields;
    delete s.fields;
  }
  if (!s.type) s.type = "json";
  return s;
}

function checkFieldValueType(s, r, o) {
  var u = "", g = r, _ = true;
  if (-1 !== [ "$in", "$nin", "$or", "$and", "$mod", "$nor", "$all" ].indexOf(s)) if (!Array.isArray(r)) u = "Query operator " + s + " must be an array.";
  if (-1 !== [ "$not", "$elemMatch", "$allMatch" ].indexOf(s)) if (!(!Array.isArray(r) && "object" == typeof r && null !== r)) u = "Query operator " + s + " must be an object.";
  if ("$mod" === s && Array.isArray(r)) if (2 !== r.length) u = "Query operator $mod must be in the format [divisor, remainder], where divisor and remainder are both integers."; else {
    var b = r[0], w = r[1];
    if (0 === b) {
      u = "Query operator $mod's divisor cannot be 0, cannot divide by zero.";
      _ = false;
    }
    if ("number" != typeof b || parseInt(b, 10) !== b) {
      u = "Query operator $mod's divisor is not an integer.";
      g = b;
    }
    if (parseInt(w, 10) !== w) {
      u = "Query operator $mod's remainder is not an integer.";
      g = w;
    }
  }
  if ("$exists" === s) if ("boolean" != typeof r) u = "Query operator $exists must be a boolean.";
  if ("$type" === s) {
    var E = [ "null", "boolean", "number", "string", "array", "object" ], S = '"' + E.slice(0, E.length - 1).join('", "') + '", or "' + E[E.length - 1] + '"';
    if ("string" != typeof r) u = "Query operator $type must be a string. Supported values: " + S + "."; else if (-1 == E.indexOf(r)) u = "Query operator $type must be a string. Supported values: " + S + ".";
  }
  if ("$size" === s) if (parseInt(r, 10) !== r) u = "Query operator $size must be a integer.";
  if ("$regex" === s) if ("string" != typeof r) if (o) u = "Query operator $regex must be a string."; else if (!(r instanceof RegExp)) u = "Query operator $regex must be a string or an instance of a javascript regular expression.";
  if (u) {
    if (_) {
      var L, O;
      u += " Received" + (null === g ? " " : Array.isArray(g) ? " array" : " " + typeof g) + ": " + ("object" == typeof g && null !== g ? JSON.stringify(g, null, "\t") : g);
    }
    throw new Error(u);
  }
}

var requireValidation = [ "$all", "$allMatch", "$and", "$elemMatch", "$exists", "$in", "$mod", "$nin", "$nor", "$not", "$or", "$regex", "$size", "$type" ], arrayTypeComparisonOperators = [ "$in", "$nin", "$mod", "$all" ], equalityOperators = [ "$eq", "$gt", "$gte", "$lt", "$lte" ];

function validateSelector(s, r) {
  if (Array.isArray(s)) {
    for (var o of s) if ("object" == typeof o && null !== b) validateSelector(o, r);
  } else for (var u = Object.keys(s), g = 0; g < u.length; g++) {
    var _ = u[g], b = s[_];
    if (-1 !== requireValidation.indexOf(_)) checkFieldValueType(_, b, r);
    if (-1 !== equalityOperators.indexOf(_)) continue;
    if (-1 !== arrayTypeComparisonOperators.indexOf(_)) continue;
    if ("object" == typeof b && null !== b) validateSelector(b, r);
  }
}

function dbFetch(s, r, o, u) {
  var g, _;
  o.headers = new h({
    "Content-type": "application/json"
  });
  s.fetch(r, o).then((function(s) {
    g = s.status;
    _ = s.ok;
    return s.json();
  })).then((function(s) {
    if (!_) {
      s.status = g;
      var r = generateErrorFromResponse(s);
      u(r);
    } else u(null, s);
  })).catch(u);
}

function createIndex(s, r, o) {
  r = massageCreateIndexRequest(r);
  dbFetch(s, "_index", {
    method: "POST",
    body: JSON.stringify(r)
  }, o);
}

function find(s, r, o) {
  validateSelector(r.selector, true);
  dbFetch(s, "_find", {
    method: "POST",
    body: JSON.stringify(r)
  }, o);
}

function explain(s, r, o) {
  dbFetch(s, "_explain", {
    method: "POST",
    body: JSON.stringify(r)
  }, o);
}

function getIndexes(s, r) {
  dbFetch(s, "_index", {
    method: "GET"
  }, r);
}

function deleteIndex(s, r, o) {
  var u = r.ddoc, g = r.type || "json", _ = r.name, b;
  if (!u) return o(new Error("you must provide an index's ddoc"));
  if (!_) return o(new Error("you must provide an index's name"));
  dbFetch(s, "_index/" + [ u, g, _ ].map(encodeURIComponent).join("/"), {
    method: "DELETE"
  }, o);
}

function callbackify2(s) {
  return function(...r) {
    var o = r.pop(), u = s.apply(this, r);
    promisedCallback2(u, o);
    return u;
  };
}

function promisedCallback2(s, r) {
  s.then((function(s) {
    (0, import_immediate.default)((function() {
      r(null, s);
    }));
  }), (function(s) {
    (0, import_immediate.default)((function() {
      r(s);
    }));
  }));
  return s;
}

var flatten2 = function(...s) {
  for (var r = [], o = 0, u = s.length; o < u; o++) {
    var g = s[o];
    if (Array.isArray(g)) r = r.concat(flatten2.apply(null, g)); else r.push(g);
  }
  return r;
};

function mergeObjects(s) {
  for (var r = {}, o = 0, u = s.length; o < u; o++) r = assign$2(r, s[o]);
  return r;
}

function pick2(s, r) {
  for (var o = {}, u = 0, g = r.length; u < g; u++) {
    var _ = parseField(r[u]), b = getFieldFromDoc(s, _);
    if ("undefined" != typeof b) setFieldInDoc(o, _, b);
  }
  return o;
}

function oneArrayIsSubArrayOfOther(s, r) {
  for (var o = 0, u = Math.min(s.length, r.length); o < u; o++) if (s[o] !== r[o]) return false;
  return true;
}

function oneArrayIsStrictSubArrayOfOther(s, r) {
  if (s.length > r.length) return false;
  return oneArrayIsSubArrayOfOther(s, r);
}

function oneSetIsSubArrayOfOther(s, r) {
  s = s.slice();
  for (var o = 0, u = r.length; o < u; o++) {
    var g = r[o];
    if (!s.length) break;
    var _ = s.indexOf(g);
    if (-1 === _) return false; else s.splice(_, 1);
  }
  return true;
}

function arrayToObject(s) {
  for (var r = {}, o = 0, u = s.length; o < u; o++) r[s[o]] = true;
  return r;
}

function max(s, r) {
  for (var o = null, u = -1, g = 0, _ = s.length; g < _; g++) {
    var b = s[g], w = r(b);
    if (w > u) {
      u = w;
      o = b;
    }
  }
  return o;
}

function arrayEquals(s, r) {
  if (s.length !== r.length) return false;
  for (var o = 0, u = s.length; o < u; o++) if (s[o] !== r[o]) return false;
  return true;
}

function uniq2(s) {
  for (var r = {}, o = 0; o < s.length; o++) r["$" + s[o]] = true;
  return Object.keys(r).map((function(s) {
    return s.substring(1);
  }));
}

function createDeepMultiMapper(s, r, o) {
  return function(u) {
    if (o && !matchesSelector(u, o)) return;
    for (var g = [], _ = 0, b = s.length; _ < b; _++) {
      for (var w = parseField(s[_]), E = u, S = 0, L = w.length; S < L; S++) {
        var O;
        if ("undefined" == typeof (E = E[w[S]])) return;
      }
      g.push(E);
    }
    r(g);
  };
}

function createDeepSingleMapper(s, r, o) {
  var u = parseField(s);
  return function(s) {
    if (o && !matchesSelector(s, o)) return;
    for (var g = s, _ = 0, b = u.length; _ < b; _++) {
      var w;
      if ("undefined" == typeof (g = g[u[_]])) return;
    }
    r(g);
  };
}

function createShallowSingleMapper(s, r, o) {
  return function(u) {
    if (o && !matchesSelector(u, o)) return;
    r(u[s]);
  };
}

function createShallowMultiMapper(s, r, o) {
  return function(u) {
    if (o && !matchesSelector(u, o)) return;
    for (var g = [], _ = 0, b = s.length; _ < b; _++) g.push(u[s[_]]);
    r(g);
  };
}

function checkShallow(s) {
  for (var r = 0, o = s.length; r < o; r++) {
    var u;
    if (-1 !== s[r].indexOf(".")) return false;
  }
  return true;
}

function createMapper(s, r, o) {
  var u = checkShallow(s), g = 1 === s.length;
  if (u) if (g) return createShallowSingleMapper(s[0], r, o); else return createShallowMultiMapper(s, r, o); else if (g) return createDeepSingleMapper(s[0], r, o); else return createDeepMultiMapper(s, r, o);
}

function mapper2(s, r) {
  const o = void 0, u = void 0;
  return createMapper(Object.keys(s.fields), r, s.partial_filter_selector);
}

function reducer2() {
  throw new Error("reduce not supported");
}

function ddocValidator2(s, r) {
  var o = s.views[r];
  if (!o.map || !o.map.fields) throw new Error("ddoc " + s._id + " with view " + r + " doesn't have map.fields defined. maybe it wasn't created by this plugin?");
}

var abstractMapper = index_es_default5("indexes", mapper2, reducer2, ddocValidator2);

function abstractMapper$1(s) {
  if (s._customFindAbstractMapper) return {
    query: function addQueryFallback(r, o) {
      var u = abstractMapper.query.bind(this);
      return s._customFindAbstractMapper.query.call(this, r, o, u);
    },
    viewCleanup: function addViewCleanupFallback() {
      var r = abstractMapper.viewCleanup.bind(this);
      return s._customFindAbstractMapper.viewCleanup.call(this, r);
    }
  };
  return abstractMapper;
}

function massageSort(s) {
  if (!Array.isArray(s)) throw new Error("invalid sort json - should be an array");
  return s.map((function(s) {
    if ("string" == typeof s) {
      var r = {};
      r[s] = "asc";
      return r;
    } else return s;
  }));
}

function massageUseIndex(s) {
  var r = [];
  if ("string" == typeof s) r.push(s); else r = s;
  return r.map((function(s) {
    return s.replace("_design/", "");
  }));
}

function massageIndexDef(s) {
  s.fields = s.fields.map((function(s) {
    if ("string" == typeof s) {
      var r = {};
      r[s] = "asc";
      return r;
    }
    return s;
  }));
  if (s.partial_filter_selector) s.partial_filter_selector = massageSelector(s.partial_filter_selector);
  return s;
}

function getKeyFromDoc(s, r) {
  for (var o = [], u = 0; u < r.def.fields.length; u++) {
    var g = getKey(r.def.fields[u]);
    o.push(getFieldFromDoc(s, parseField(g)));
  }
  return o;
}

function filterInclusiveStart(s, r, o) {
  for (var u = o.def.fields, g = 0, _ = s.length; g < _; g++) {
    var b, w = getKeyFromDoc(s[g].doc, o);
    if (1 === u.length) w = w[0]; else for (;w.length > r.length; ) w.pop();
    if (Math.abs(collate(w, r)) > 0) break;
  }
  return g > 0 ? s.slice(g) : s;
}

function reverseOptions(s) {
  var r = clone(s);
  delete r.startkey;
  delete r.endkey;
  delete r.inclusive_start;
  delete r.inclusive_end;
  if ("endkey" in s) r.startkey = s.endkey;
  if ("startkey" in s) r.endkey = s.startkey;
  if ("inclusive_start" in s) r.inclusive_end = s.inclusive_start;
  if ("inclusive_end" in s) r.inclusive_start = s.inclusive_end;
  return r;
}

function validateIndex(s) {
  var r = s.fields.filter((function(s) {
    return "asc" === getValue(s);
  }));
  if (0 !== r.length && r.length !== s.fields.length) throw new Error("unsupported mixed sorting");
}

function validateSort(s, r) {
  if (r.defaultUsed && s.sort) {
    var o = s.sort.filter((function(s) {
      return "_id" !== Object.keys(s)[0];
    })).map((function(s) {
      return Object.keys(s)[0];
    }));
    if (o.length > 0) throw new Error('Cannot sort on field(s) "' + o.join(",") + '" when using the default index');
  }
  if (r.defaultUsed) return;
}

function validateFindRequest(s) {
  if ("object" != typeof s.selector) throw new Error("you must provide a selector when you find()");
}

function getUserFields(s, r) {
  var o = Object.keys(s), u = r ? r.map(getKey) : [], g;
  if (o.length >= u.length) g = o; else g = u;
  if (0 === u.length) return {
    fields: g
  };
  return {
    fields: g = g.sort((function(s, r) {
      var o = u.indexOf(s);
      if (-1 === o) o = Number.MAX_VALUE;
      var g = u.indexOf(r);
      if (-1 === g) g = Number.MAX_VALUE;
      return o < g ? -1 : o > g ? 1 : 0;
    })),
    sortOrder: r.map(getKey)
  };
}

function createIndex$1(s, r) {
  var o = clone((r = massageCreateIndexRequest(r)).index), u;
  r.index = massageIndexDef(r.index);
  validateIndex(r.index);
  function getMd5() {
    return u || (u = stringMd5(JSON.stringify(r)));
  }
  var g = r.name || "idx-" + getMd5(), _ = r.ddoc || "idx-" + getMd5(), b = "_design/" + _, w = false, E = false;
  function updateDdoc(s) {
    if (s._rev && "query" !== s.language) w = true;
    s.language = "query";
    s.views = s.views || {};
    if (E = !!s.views[g]) return false;
    s.views[g] = {
      map: {
        fields: mergeObjects(r.index.fields),
        partial_filter_selector: r.index.partial_filter_selector
      },
      reduce: "_count",
      options: {
        def: o
      }
    };
    return s;
  }
  s.constructor.emit("debug", [ "find", "creating index", b ]);
  return upsert(s, b, updateDdoc).then((function() {
    if (w) throw new Error('invalid language for ddoc with id "' + b + '" (should be "query")');
  })).then((function() {
    var r = _ + "/" + g;
    return abstractMapper$1(s).query.call(s, r, {
      limit: 0,
      reduce: false
    }).then((function() {
      return {
        id: b,
        name: g,
        result: E ? "exists" : "created"
      };
    }));
  }));
}

function getIndexes$1(s) {
  return s.allDocs({
    startkey: "_design/",
    endkey: "_design/￿",
    include_docs: true
  }).then((function(s) {
    var r = {
      indexes: [ {
        ddoc: null,
        name: "_all_docs",
        type: "special",
        def: {
          fields: [ {
            _id: "asc"
          } ]
        }
      } ]
    };
    r.indexes = flatten2(r.indexes, s.rows.filter((function(s) {
      return "query" === s.doc.language;
    })).map((function(s) {
      var r;
      return (void 0 !== s.doc.views ? Object.keys(s.doc.views) : []).map((function(r) {
        var o = s.doc.views[r];
        return {
          ddoc: s.id,
          name: r,
          type: "json",
          def: massageIndexDef(o.options.def)
        };
      }));
    })));
    r.indexes.sort((function(s, r) {
      return compare(s.name, r.name);
    }));
    r.total_rows = r.indexes.length;
    return r;
  }));
}

var COLLATE_LO = null, COLLATE_HI = {
  "￿": {}
}, SHORT_CIRCUIT_QUERY = {
  queryOpts: {
    limit: 0,
    startkey: COLLATE_HI,
    endkey: COLLATE_LO
  },
  inMemoryFields: []
};

function checkFieldInIndex(s, r) {
  for (var o = s.def.fields.map(getKey), u = 0, g = o.length; u < g; u++) {
    var _;
    if (r === o[u]) return true;
  }
  return false;
}

function userOperatorLosesPrecision(s, r) {
  var o, u;
  return "$eq" !== getKey(s[r]);
}

function sortFieldsByIndex(s, r) {
  var o = r.def.fields.map(getKey);
  return s.slice().sort((function(s, r) {
    var u = o.indexOf(s), g = o.indexOf(r);
    if (-1 === u) u = Number.MAX_VALUE;
    if (-1 === g) g = Number.MAX_VALUE;
    return compare(u, g);
  }));
}

function getBasicInMemoryFields(s, r, o) {
  for (var u = false, g = 0, _ = (o = sortFieldsByIndex(o, s)).length; g < _; g++) {
    var b = o[g];
    if (u || !checkFieldInIndex(s, b)) return o.slice(g);
    if (g < _ - 1 && userOperatorLosesPrecision(r, b)) u = true;
  }
  return [];
}

function getInMemoryFieldsFromNe(s) {
  var r = [];
  Object.keys(s).forEach((function(o) {
    var u = s[o];
    Object.keys(u).forEach((function(s) {
      if ("$ne" === s) r.push(o);
    }));
  }));
  return r;
}

function getInMemoryFields(s, r, o, u) {
  var g;
  return sortFieldsByIndex(uniq2(flatten2(s, getBasicInMemoryFields(r, o, u), getInMemoryFieldsFromNe(o))), r);
}

function checkIndexFieldsMatch(s, r, o) {
  if (r) {
    var u = oneArrayIsStrictSubArrayOfOther(r, s), g = oneArrayIsSubArrayOfOther(o, s);
    return u && g;
  }
  return oneSetIsSubArrayOfOther(o, s);
}

var logicalMatchers = [ "$eq", "$gt", "$gte", "$lt", "$lte" ];

function isNonLogicalMatcher(s) {
  return -1 === logicalMatchers.indexOf(s);
}

function checkFieldsLogicallySound(s, r) {
  var o, u = r[s[0]], g;
  if ("undefined" == typeof u) return true;
  return !(1 === Object.keys(u).length && "$ne" === getKey(u));
}

function checkIndexMatches(s, r, o, u) {
  var g = s.def.fields.map(getKey), _;
  if (!checkIndexFieldsMatch(g, r, o)) return false;
  return checkFieldsLogicallySound(g, u);
}

function findMatchingIndexes(s, r, o, u) {
  return u.filter((function(u) {
    return checkIndexMatches(u, o, r, s);
  }));
}

function findBestMatchingIndex(s, r, o, u, g) {
  var _ = findMatchingIndexes(s, r, o, u);
  if (0 === _.length) {
    if (g) throw {
      error: "no_usable_index",
      message: "There is no index available for this selector."
    };
    var b = u[0];
    b.defaultUsed = true;
    return b;
  }
  if (1 === _.length && !g) return _[0];
  var w = arrayToObject(r);
  function scoreIndex(s) {
    for (var r = s.def.fields.map(getKey), o = 0, u = 0, g = r.length; u < g; u++) {
      var _ = r[u];
      if (w[_]) o++;
    }
    return o;
  }
  if (g) {
    var E = "_design/" + g[0], S = 2 === g.length ? g[1] : false, L = _.find((function(s) {
      if (S && s.ddoc === E && S === s.name) return true;
      if (s.ddoc === E) return true;
      return false;
    }));
    if (!L) throw {
      error: "unknown_error",
      message: "Could not find that index or could not use that index for the query"
    };
    return L;
  }
  return max(_, scoreIndex);
}

function getSingleFieldQueryOptsFor(s, r) {
  switch (s) {
   case "$eq":
    return {
      key: r
    };

   case "$lte":
    return {
      endkey: r
    };

   case "$gte":
    return {
      startkey: r
    };

   case "$lt":
    return {
      endkey: r,
      inclusive_end: false
    };

   case "$gt":
    return {
      startkey: r,
      inclusive_start: false
    };
  }
  return {
    startkey: COLLATE_LO
  };
}

function getSingleFieldCoreQueryPlan(s, r) {
  var o = getKey(r.def.fields[0]), u = s[o] || {}, g = [], _, b;
  Object.keys(u).forEach((function(s) {
    if (isNonLogicalMatcher(s)) g.push(o);
    var r, _ = getSingleFieldQueryOptsFor(s, u[s]);
    if (b) b = mergeObjects([ b, _ ]); else b = _;
  }));
  return {
    queryOpts: b,
    inMemoryFields: g
  };
}

function getMultiFieldCoreQueryPlan(s, r) {
  switch (s) {
   case "$eq":
    return {
      startkey: r,
      endkey: r
    };

   case "$lte":
    return {
      endkey: r
    };

   case "$gte":
    return {
      startkey: r
    };

   case "$lt":
    return {
      endkey: r,
      inclusive_end: false
    };

   case "$gt":
    return {
      startkey: r,
      inclusive_start: false
    };
  }
}

function getMultiFieldQueryOpts(s, r) {
  var o = r.def.fields.map(getKey), u = [], g = [], _ = [], b, w;
  function finish(s) {
    if (false !== b) g.push(COLLATE_LO);
    if (false !== w) _.push(COLLATE_HI);
    u = o.slice(s);
  }
  for (var E = 0, S = o.length; E < S; E++) {
    var L, O = s[o[E]];
    if (!O || !Object.keys(O).length) {
      finish(E);
      break;
    } else if (Object.keys(O).some(isNonLogicalMatcher)) {
      finish(E);
      break;
    } else if (E > 0) {
      var D = "$gt" in O || "$gte" in O || "$lt" in O || "$lte" in O, k = Object.keys(s[o[E - 1]]), C = arrayEquals(k, [ "$eq" ]), T = arrayEquals(k, Object.keys(O)), I;
      if (D && !C && !T) {
        finish(E);
        break;
      }
    }
    for (var A = Object.keys(O), x = null, R = 0; R < A.length; R++) {
      var P = A[R], N, B = getMultiFieldCoreQueryPlan(P, O[P]);
      if (x) x = mergeObjects([ x, B ]); else x = B;
    }
    g.push("startkey" in x ? x.startkey : COLLATE_LO);
    _.push("endkey" in x ? x.endkey : COLLATE_HI);
    if ("inclusive_start" in x) b = x.inclusive_start;
    if ("inclusive_end" in x) w = x.inclusive_end;
  }
  var F = {
    startkey: g,
    endkey: _
  };
  if ("undefined" != typeof b) F.inclusive_start = b;
  if ("undefined" != typeof w) F.inclusive_end = w;
  return {
    queryOpts: F,
    inMemoryFields: u
  };
}

function shouldShortCircuit(s) {
  const r = void 0;
  return Object.keys(s).map((function(r) {
    return s[r];
  })).some((function(s) {
    return "object" == typeof s && 0 === Object.keys(s).length;
  }));
}

function getDefaultQueryPlan(s) {
  return {
    queryOpts: {
      startkey: null
    },
    inMemoryFields: [ Object.keys(s) ]
  };
}

function getCoreQueryPlan(s, r) {
  if (r.defaultUsed) return getDefaultQueryPlan(s, r);
  if (1 === r.def.fields.length) return getSingleFieldCoreQueryPlan(s, r);
  return getMultiFieldQueryOpts(s, r);
}

function planQuery(s, r) {
  var o = s.selector, u = s.sort;
  if (shouldShortCircuit(o)) return assign$2({}, SHORT_CIRCUIT_QUERY, {
    index: r[0]
  });
  var g = getUserFields(o, u), _ = g.fields, b, w = findBestMatchingIndex(o, _, g.sortOrder, r, s.use_index), E = getCoreQueryPlan(o, w), S, L, O, D;
  return {
    queryOpts: E.queryOpts,
    index: w,
    inMemoryFields: getInMemoryFields(E.inMemoryFields, w, o, _)
  };
}

function indexToSignature(s) {
  return s.ddoc.substring(8) + "/" + s.name;
}

function doAllDocs(s, r) {
  var o = clone(r);
  if (o.descending) {
    if ("endkey" in o && "string" != typeof o.endkey) o.endkey = "";
    if ("startkey" in o && "string" != typeof o.startkey) o.limit = 0;
  } else {
    if ("startkey" in o && "string" != typeof o.startkey) o.startkey = "";
    if ("endkey" in o && "string" != typeof o.endkey) o.limit = 0;
  }
  if ("key" in o && "string" != typeof o.key) o.limit = 0;
  if (o.limit > 0 && o.indexes_count) {
    o.original_limit = o.limit;
    o.limit += o.indexes_count;
  }
  return s.allDocs(o).then((function(s) {
    s.rows = s.rows.filter((function(s) {
      return !/^_design\//.test(s.id);
    }));
    if (o.original_limit) o.limit = o.original_limit;
    s.rows = s.rows.slice(0, o.limit);
    return s;
  }));
}

function find$1(s, r, o) {
  if (r.selector) {
    validateSelector(r.selector, false);
    r.selector = massageSelector(r.selector);
  }
  if (r.sort) r.sort = massageSort(r.sort);
  if (r.use_index) r.use_index = massageUseIndex(r.use_index);
  validateFindRequest(r);
  return getIndexes$1(s).then((function(u) {
    s.constructor.emit("debug", [ "find", "planning query", r ]);
    var g = planQuery(r, u.indexes);
    s.constructor.emit("debug", [ "find", "query plan", g ]);
    var _ = g.index;
    validateSort(r, _);
    var b = assign$2({
      include_docs: true,
      reduce: false,
      indexes_count: u.total_rows
    }, g.queryOpts), w;
    if ("startkey" in b && "endkey" in b && collate(b.startkey, b.endkey) > 0) return {
      docs: []
    };
    if (r.sort && "string" != typeof r.sort[0] && "desc" === getValue(r.sort[0])) {
      b.descending = true;
      b = reverseOptions(b);
    }
    if (!g.inMemoryFields.length) {
      if ("limit" in r) b.limit = r.limit;
      if ("skip" in r) b.skip = r.skip;
    }
    if (o) return Promise.resolve(g, b);
    return Promise.resolve().then((function() {
      if ("_all_docs" === _.name) return doAllDocs(s, b); else {
        var r = indexToSignature(_);
        return abstractMapper$1(s).query.call(s, r, b);
      }
    })).then((function(s) {
      if (false === b.inclusive_start) s.rows = filterInclusiveStart(s.rows, b.startkey, _);
      if (g.inMemoryFields.length) s.rows = filterInMemoryFields(s.rows, r, g.inMemoryFields);
      var o = {
        docs: s.rows.map((function(s) {
          var o = s.doc;
          if (r.fields) return pick2(o, r.fields);
          return o;
        }))
      };
      if (_.defaultUsed) o.warning = "No matching index found, create an index to optimize query time.";
      return o;
    }));
  }));
}

function explain$1(s, r) {
  return find$1(s, r, true).then((function(o) {
    return {
      dbname: s.name,
      index: o.index,
      selector: r.selector,
      range: {
        start_key: o.queryOpts.startkey,
        end_key: o.queryOpts.endkey
      },
      opts: {
        use_index: r.use_index || [],
        bookmark: "nil",
        limit: r.limit,
        skip: r.skip,
        sort: r.sort || {},
        fields: r.fields,
        conflicts: false,
        r: [ 49 ]
      },
      limit: r.limit,
      skip: r.skip || 0,
      fields: r.fields
    };
  }));
}

function deleteIndex$1(s, r) {
  if (!r.ddoc) throw new Error("you must supply an index.ddoc when deleting");
  if (!r.name) throw new Error("you must supply an index.name when deleting");
  var o = r.ddoc, u = r.name;
  function deltaFun(s) {
    if (1 === Object.keys(s.views).length && s.views[u]) return {
      _id: o,
      _deleted: true
    };
    delete s.views[u];
    return s;
  }
  return upsert(s, o, deltaFun).then((function() {
    return abstractMapper$1(s).viewCleanup.apply(s);
  })).then((function() {
    return {
      ok: true
    };
  }));
}

var createIndexAsCallback = callbackify2(createIndex$1), findAsCallback = callbackify2(find$1), explainAsCallback = callbackify2(explain$1), getIndexesAsCallback = callbackify2(getIndexes$1), deleteIndexAsCallback = callbackify2(deleteIndex$1), plugin = {};

plugin.createIndex = toPromise((function(s, r) {
  if ("object" != typeof s) return r(new Error("you must provide an index to create"));
  var o;
  (isRemote(this) ? createIndex : createIndexAsCallback)(this, s, r);
}));

plugin.find = toPromise((function(s, r) {
  if ("undefined" == typeof r) {
    r = s;
    s = void 0;
  }
  if ("object" != typeof s) return r(new Error("you must provide search parameters to find()"));
  var o;
  (isRemote(this) ? find : findAsCallback)(this, s, r);
}));

plugin.explain = toPromise((function(s, r) {
  if ("undefined" == typeof r) {
    r = s;
    s = void 0;
  }
  if ("object" != typeof s) return r(new Error("you must provide search parameters to explain()"));
  var o;
  (isRemote(this) ? explain : explainAsCallback)(this, s, r);
}));

plugin.getIndexes = toPromise((function(s) {
  var r;
  (isRemote(this) ? getIndexes : getIndexesAsCallback)(this, s);
}));

plugin.deleteIndex = toPromise((function(s, r) {
  if ("object" != typeof s) return r(new Error("you must provide an index to delete"));
  var o;
  (isRemote(this) ? deleteIndex : deleteIndexAsCallback)(this, s, r);
}));

var index_browser_es_default3 = plugin, import_transform_pouch = __toESM(require_transform_pouch(), 1);

index_es_default.plugin(index_es_default2).plugin(index_es_default3).plugin(index_es_default4).plugin(index_browser_es_default2).plugin(index_es_default8).plugin(index_browser_es_default3).plugin(import_transform_pouch.default);

function appendPurgeSeqs(s, r) {
  return s.get("_local/purges").then((function(o) {
    for (const [u, g] of r) {
      const r = o.purgeSeq + 1;
      o.purges.push({
        docId: u,
        rev: g,
        purgeSeq: r
      });
      if (o.purges.length > s.purged_infos_limit) o.purges.splice(0, o.purges.length - s.purged_infos_limit);
      o.purgeSeq = r;
    }
    return o;
  })).catch((function(s) {
    if (404 !== s.status) throw s;
    return {
      _id: "_local/purges",
      purges: r.map((([s, r], o) => ({
        docId: s,
        rev: r,
        purgeSeq: o
      }))),
      purgeSeq: r.length
    };
  })).then((function(r) {
    return s.put(r);
  }));
}

index_es_default.prototype.purgeMulti = adapterFun("_purgeMulti", (function(s, r) {
  if ("undefined" == typeof this._purge) return r(createError(UNKNOWN_ERROR, "Purge is not implemented in the " + this.adapter + " adapter."));
  const o = this, u = s.map((s => () => new Promise(((r, u) => {
    const [g, _] = s;
    o._getRevisionTree(g, ((u, b) => {
      if (u) return r([ s, u ]);
      if (!b) return r([ s, createError(MISSING_DOC) ]);
      let w;
      try {
        w = findPathToLeaf(b, _);
      } catch (o) {
        return r([ s, o.message || o ]);
      }
      o._purge(g, w, ((o, u) => {
        if (o) return r([ s, o ]); else return r([ s, u ]);
      }));
    }));
  }))));
  (async () => {
    const s = void 0, r = (await mapAllTasksWithConcurrencyLimit(1, u)).map((s => unwrapTaskResult(s)));
    await appendPurgeSeqs(o, r.filter((s => "ok" in s[1])).map((s => s[0])));
    const g = void 0;
    return r.map((s => ({
      [s[0][0]]: s[1]
    }))).reduce(((s, r) => ({
      ...s,
      ...r
    })), {});
  })().then((s => r(void 0, s))).catch((s => r(s)));
}));

var import_diff_match_patch2 = __toESM(require_diff_match_patch(), 1), ConflictResolveModal = class extends import_obsidian.Modal {
  constructor(s, r, o, u) {
    super(s);
    this.result = o;
    this.callback = u;
    this.filename = r;
  }
  onOpen() {
    const {contentEl: s} = this;
    s.empty();
    s.createEl("h2", {
      text: "This document has conflicted changes."
    });
    s.createEl("span", {
      text: this.filename
    });
    const r = s.createDiv("");
    r.addClass("op-scrollable");
    let o = "";
    for (const s of this.result.diff) {
      const r = s[0], u = s[1];
      if (r == import_diff_match_patch2.DIFF_DELETE) o += "<span class='deleted'>" + escapeStringToHTML(u).replace(/\n/g, "<span class='ls-mark-cr'></span>\n") + "</span>"; else if (r == import_diff_match_patch2.DIFF_EQUAL) o += "<span class='normal'>" + escapeStringToHTML(u).replace(/\n/g, "<span class='ls-mark-cr'></span>\n") + "</span>"; else if (r == import_diff_match_patch2.DIFF_INSERT) o += "<span class='added'>" + escapeStringToHTML(u).replace(/\n/g, "<span class='ls-mark-cr'></span>\n") + "</span>";
    }
    o = o.replace(/\n/g, "<br>");
    r.innerHTML = o;
    const u = s.createDiv(""), g = new Date(this.result.left.mtime).toLocaleString() + (this.result.left.deleted ? " (Deleted)" : ""), _ = new Date(this.result.right.mtime).toLocaleString() + (this.result.right.deleted ? " (Deleted)" : "");
    u.innerHTML = `\n<span class='deleted'>A:${g}</span><br /><span class='added'>B:${_}</span><br> \n        `;
    s.createEl("button", {
      text: "Keep A"
    }, (s => {
      s.addEventListener("click", (async () => {
        const s = this.callback;
        this.callback = null;
        this.close();
        await s(this.result.right.rev);
      }));
    }));
    s.createEl("button", {
      text: "Keep B"
    }, (s => {
      s.addEventListener("click", (async () => {
        const s = this.callback;
        this.callback = null;
        this.close();
        await s(this.result.left.rev);
      }));
    }));
    s.createEl("button", {
      text: "Concat both"
    }, (s => {
      s.addEventListener("click", (async () => {
        const s = this.callback;
        this.callback = null;
        this.close();
        await s("");
      }));
    }));
    s.createEl("button", {
      text: "Not now"
    }, (s => {
      s.addEventListener("click", (() => {
        this.close();
      }));
    }));
  }
  onClose() {
    const {contentEl: s} = this;
    s.empty();
    if (null != this.callback) this.callback(null);
  }
}, import_obsidian3 = require("obsidian");

function noop() {}

function assign(s, r) {
  for (const o in r) s[o] = r[o];
  return s;
}

function run(s) {
  return s();
}

function blank_object() {
  return Object.create(null);
}

function run_all(s) {
  s.forEach(run);
}

function is_function(s) {
  return "function" == typeof s;
}

function safe_not_equal(s, r) {
  return s != s ? r == r : s !== r || s && "object" == typeof s || "function" == typeof s;
}

function is_empty(s) {
  return 0 === Object.keys(s).length;
}

function null_to_empty(s) {
  return null == s ? "" : s;
}

var globals = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : window, ResizeObserverSingleton = class _ResizeObserverSingleton {
  constructor(s) {
    __publicField(this, "_listeners", "WeakMap" in globals ? new WeakMap : void 0);
    __publicField(this, "_observer");
    __publicField(this, "options");
    this.options = s;
  }
  observe(s, r) {
    this._listeners.set(s, r);
    this._getObserver().observe(s, this.options);
    return () => {
      this._listeners.delete(s);
      this._observer.unobserve(s);
    };
  }
  _getObserver() {
    var s;
    return null != (s = this._observer) ? s : this._observer = new ResizeObserver((s => {
      var r;
      for (const o of s) {
        _ResizeObserverSingleton.entries.set(o.target, o);
        null == (r = this._listeners.get(o.target)) || r(o);
      }
    }));
  }
};

ResizeObserverSingleton.entries = "WeakMap" in globals ? new WeakMap : void 0;

var is_hydrating = false, current_component;

function start_hydrating() {
  is_hydrating = true;
}

function end_hydrating() {
  is_hydrating = false;
}

function append(s, r) {
  s.appendChild(r);
}

function append_styles(s, r, o) {
  const u = get_root_for_style(s);
  if (!u.getElementById(r)) {
    const s = element("style");
    s.id = r;
    s.textContent = o;
    append_stylesheet(u, s);
  }
}

function get_root_for_style(s) {
  if (!s) return document;
  const r = s.getRootNode ? s.getRootNode() : s.ownerDocument;
  if (r && r.host) return r;
  return s.ownerDocument;
}

function append_stylesheet(s, r) {
  append(s.head || s, r);
  return r.sheet;
}

function insert(s, r, o) {
  s.insertBefore(r, o || null);
}

function detach(s) {
  if (s.parentNode) s.parentNode.removeChild(s);
}

function destroy_each(s, r) {
  for (let o = 0; o < s.length; o += 1) if (s[o]) s[o].d(r);
}

function element(s) {
  return document.createElement(s);
}

function text(s) {
  return document.createTextNode(s);
}

function space() {
  return text(" ");
}

function empty() {
  return text("");
}

function comment(s) {
  return document.createComment(s);
}

function listen(s, r, o, u) {
  s.addEventListener(r, o, u);
  return () => s.removeEventListener(r, o, u);
}

function attr(s, r, o) {
  if (null == o) s.removeAttribute(r); else if (s.getAttribute(r) !== o) s.setAttribute(r, o);
}

function init_binding_group(s) {
  let r;
  return {
    p(...o) {
      r = o;
      r.forEach((r => s.push(r)));
    },
    r() {
      r.forEach((r => s.splice(s.indexOf(r), 1)));
    }
  };
}

function children(s) {
  return Array.from(s.childNodes);
}

function set_data(s, r) {
  r = "" + r;
  if (s.data === r) return;
  s.data = r;
}

function set_input_value(s, r) {
  s.value = null == r ? "" : r;
}

function select_option(s, r, o) {
  for (let o = 0; o < s.options.length; o += 1) {
    const u = s.options[o];
    if (u.__value === r) {
      u.selected = true;
      return;
    }
  }
  if (!o || void 0 !== r) s.selectedIndex = -1;
}

function select_value(s) {
  const r = s.querySelector(":checked");
  return r && r.__value;
}

function toggle_class(s, r, o) {
  s.classList.toggle(r, !!o);
}

function get_custom_elements_slots(s) {
  const r = {};
  s.childNodes.forEach((s => {
    r[s.slot || "default"] = true;
  }));
  return r;
}

function set_current_component(s) {
  current_component = s;
}

function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}

function onMount(s) {
  get_current_component().$$.on_mount.push(s);
}

function onDestroy(s) {
  get_current_component().$$.on_destroy.push(s);
}

var dirty_components = [], binding_callbacks = [], render_callbacks = [], flush_callbacks = [], resolved_promise = Promise.resolve(), update_scheduled = false;

function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}

function add_render_callback(s) {
  render_callbacks.push(s);
}

var seen_callbacks = new Set, flushidx = 0;

function flush() {
  if (0 !== flushidx) return;
  const s = current_component;
  do {
    try {
      for (;flushidx < dirty_components.length; ) {
        const s = dirty_components[flushidx];
        flushidx++;
        set_current_component(s);
        update(s.$$);
      }
    } catch (s) {
      dirty_components.length = 0;
      flushidx = 0;
      throw s;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    for (;binding_callbacks.length; ) binding_callbacks.pop()();
    for (let s = 0; s < render_callbacks.length; s += 1) {
      const r = render_callbacks[s];
      if (!seen_callbacks.has(r)) {
        seen_callbacks.add(r);
        r();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (;flush_callbacks.length; ) flush_callbacks.pop()();
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(s);
}

function update(s) {
  if (null !== s.fragment) {
    s.update();
    run_all(s.before_update);
    const r = s.dirty;
    s.dirty = [ -1 ];
    s.fragment && s.fragment.p(s.ctx, r);
    s.after_update.forEach(add_render_callback);
  }
}

function flush_render_callbacks(s) {
  const r = [], o = [];
  render_callbacks.forEach((u => -1 === s.indexOf(u) ? r.push(u) : o.push(u)));
  o.forEach((s => s()));
  render_callbacks = r;
}

var outroing = new Set, outros;

function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}

function check_outros() {
  if (!outros.r) run_all(outros.c);
  outros = outros.p;
}

function transition_in(s, r) {
  if (s && s.i) {
    outroing.delete(s);
    s.i(r);
  }
}

function transition_out(s, r, o, u) {
  if (s && s.o) {
    if (outroing.has(s)) return;
    outroing.add(s);
    outros.c.push((() => {
      outroing.delete(s);
      if (u) {
        if (o) s.d(1);
        u();
      }
    }));
    s.o(r);
  } else if (u) u();
}

function ensure_array_like(s) {
  return void 0 !== (null == s ? void 0 : s.length) ? s : Array.from(s);
}

function get_spread_update(s, r) {
  const o = {}, u = {}, g = {
    $$scope: 1
  };
  let _ = s.length;
  for (;_--; ) {
    const b = s[_], w = r[_];
    if (w) {
      for (const s in b) if (!(s in w)) u[s] = 1;
      for (const s in w) if (!g[s]) {
        o[s] = w[s];
        g[s] = 1;
      }
      s[_] = w;
    } else for (const s in b) g[s] = 1;
  }
  for (const s in u) if (!(s in o)) o[s] = void 0;
  return o;
}

function get_spread_object(s) {
  return "object" == typeof s && null !== s ? s : {};
}

var _boolean_attributes = [ "allowfullscreen", "allowpaymentrequest", "async", "autofocus", "autoplay", "checked", "controls", "default", "defer", "disabled", "formnovalidate", "hidden", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected" ], boolean_attributes = new Set([ ..._boolean_attributes ]), SvelteElement;

function create_component(s) {
  s && s.c();
}

function mount_component(s, r, o) {
  const {fragment: u, after_update: g} = s.$$;
  u && u.m(r, o);
  add_render_callback((() => {
    const r = s.$$.on_mount.map(run).filter(is_function);
    if (s.$$.on_destroy) s.$$.on_destroy.push(...r); else run_all(r);
    s.$$.on_mount = [];
  }));
  g.forEach(add_render_callback);
}

function destroy_component(s, r) {
  const o = s.$$;
  if (null !== o.fragment) {
    flush_render_callbacks(o.after_update);
    run_all(o.on_destroy);
    o.fragment && o.fragment.d(r);
    o.on_destroy = o.fragment = null;
    o.ctx = [];
  }
}

function make_dirty(s, r) {
  if (-1 === s.$$.dirty[0]) {
    dirty_components.push(s);
    schedule_update();
    s.$$.dirty.fill(0);
  }
  s.$$.dirty[r / 31 | 0] |= 1 << r % 31;
}

function init2(s, r, o, u, g, _, b, w = [ -1 ]) {
  const E = current_component;
  set_current_component(s);
  const S = s.$$ = {
    fragment: null,
    ctx: [],
    props: _,
    update: noop,
    not_equal: g,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(r.context || (E ? E.$$.context : [])),
    callbacks: blank_object(),
    dirty: w,
    skip_bound: false,
    root: r.target || E.$$.root
  };
  b && b(S.root);
  let L = false;
  S.ctx = o ? o(s, r.props || {}, ((r, o, ...u) => {
    const _ = u.length ? u[0] : o;
    if (S.ctx && g(S.ctx[r], S.ctx[r] = _)) {
      if (!S.skip_bound && S.bound[r]) S.bound[r](_);
      if (L) make_dirty(s, r);
    }
    return o;
  })) : [];
  S.update();
  L = true;
  run_all(S.before_update);
  S.fragment = u ? u(S.ctx) : false;
  if (r.target) {
    if (r.hydrate) {
      start_hydrating();
      const s = children(r.target);
      S.fragment && S.fragment.l(s);
      s.forEach(detach);
    } else S.fragment && S.fragment.c();
    if (r.intro) transition_in(s.$$.fragment);
    mount_component(s, r.target, r.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(E);
}

if ("function" == typeof HTMLElement) SvelteElement = class extends HTMLElement {
  constructor(s, r, o) {
    super();
    __publicField(this, "$$ctor");
    __publicField(this, "$$s");
    __publicField(this, "$$c");
    __publicField(this, "$$cn", false);
    __publicField(this, "$$d", {});
    __publicField(this, "$$r", false);
    __publicField(this, "$$p_d", {});
    __publicField(this, "$$l", {});
    __publicField(this, "$$l_u", new Map);
    this.$$ctor = s;
    this.$$s = r;
    if (o) this.attachShadow({
      mode: "open"
    });
  }
  addEventListener(s, r, o) {
    this.$$l[s] = this.$$l[s] || [];
    this.$$l[s].push(r);
    if (this.$$c) {
      const o = this.$$c.$on(s, r);
      this.$$l_u.set(r, o);
    }
    super.addEventListener(s, r, o);
  }
  removeEventListener(s, r, o) {
    super.removeEventListener(s, r, o);
    if (this.$$c) {
      const s = this.$$l_u.get(r);
      if (s) {
        s();
        this.$$l_u.delete(r);
      }
    }
  }
  async connectedCallback() {
    this.$$cn = true;
    if (!this.$$c) {
      let create_slot = function(s) {
        return () => {
          let r;
          const o = void 0;
          return {
            c: function create() {
              r = element("slot");
              if ("default" !== s) attr(r, "name", s);
            },
            m: function mount(s, o) {
              insert(s, r, o);
            },
            d: function destroy2(s) {
              if (s) detach(r);
            }
          };
        };
      };
      await Promise.resolve();
      if (!this.$$cn) return;
      const s = {}, r = get_custom_elements_slots(this);
      for (const o of this.$$s) if (o in r) s[o] = [ create_slot(o) ];
      for (const s of this.attributes) {
        const r = this.$$g_p(s.name);
        if (!(r in this.$$d)) this.$$d[r] = get_custom_element_value(r, s.value, this.$$p_d, "toProp");
      }
      this.$$c = new this.$$ctor({
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: s,
          $$scope: {
            ctx: []
          }
        }
      });
      const reflect_attributes = () => {
        this.$$r = true;
        for (const s in this.$$p_d) {
          this.$$d[s] = this.$$c.$$.ctx[this.$$c.$$.props[s]];
          if (this.$$p_d[s].reflect) {
            const r = get_custom_element_value(s, this.$$d[s], this.$$p_d, "toAttribute");
            if (null == r) this.removeAttribute(s); else this.setAttribute(this.$$p_d[s].attribute || s, r);
          }
        }
        this.$$r = false;
      };
      this.$$c.$$.after_update.push(reflect_attributes);
      reflect_attributes();
      for (const s in this.$$l) for (const r of this.$$l[s]) {
        const o = this.$$c.$on(s, r);
        this.$$l_u.set(r, o);
      }
      this.$$l = {};
    }
  }
  attributeChangedCallback(s, r, o) {
    var u;
    if (this.$$r) return;
    s = this.$$g_p(s);
    this.$$d[s] = get_custom_element_value(s, o, this.$$p_d, "toProp");
    null == (u = this.$$c) || u.$set({
      [s]: this.$$d[s]
    });
  }
  disconnectedCallback() {
    this.$$cn = false;
    Promise.resolve().then((() => {
      if (!this.$$cn) {
        this.$$c.$destroy();
        this.$$c = void 0;
      }
    }));
  }
  $$g_p(s) {
    return Object.keys(this.$$p_d).find((r => this.$$p_d[r].attribute === s || !this.$$p_d[r].attribute && r.toLowerCase() === s)) || s;
  }
};

function get_custom_element_value(s, r, o, u) {
  var g;
  const _ = null == (g = o[s]) ? void 0 : g.type;
  r = "Boolean" === _ && "boolean" != typeof r ? null != r : r;
  if (!u || !o[s]) return r; else if ("toAttribute" === u) switch (_) {
   case "Object":
   case "Array":
    return null == r ? null : JSON.stringify(r);

   case "Boolean":
    return r ? "" : null;

   case "Number":
    return null == r ? null : r;

   default:
    return r;
  } else switch (_) {
   case "Object":
   case "Array":
    return r && JSON.parse(r);

   case "Boolean":
    return r;

   case "Number":
    return null != r ? +r : r;

   default:
    return r;
  }
}

var SvelteComponent = class {
  constructor() {
    __publicField(this, "$$");
    __publicField(this, "$$set");
  }
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(s, r) {
    if (!is_function(r)) return noop;
    const o = this.$$.callbacks[s] || (this.$$.callbacks[s] = []);
    o.push(r);
    return () => {
      const s = o.indexOf(r);
      if (-1 !== s) o.splice(s, 1);
    };
  }
  $set(s) {
    if (this.$$set && !is_empty(s)) {
      this.$$.skip_bound = true;
      this.$$set(s);
      this.$$.skip_bound = false;
    }
  }
}, PUBLIC_VERSION = "4";

if ("undefined" != typeof window) (window.__svelte || (window.__svelte = {
  v: new Set
})).v.add(PUBLIC_VERSION);

var subscriber_queue = [];

function writable(s, r = noop) {
  let o;
  const u = new Set;
  function set(r) {
    if (safe_not_equal(s, r)) {
      s = r;
      if (o) {
        const r = !subscriber_queue.length;
        for (const r of u) {
          r[1]();
          subscriber_queue.push(r, s);
        }
        if (r) {
          for (let s = 0; s < subscriber_queue.length; s += 2) subscriber_queue[s][0](subscriber_queue[s + 1]);
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(r) {
    set(r(s));
  }
  function subscribe2(g, _ = noop) {
    const b = [ g, _ ];
    u.add(b);
    if (1 === u.size) o = r(set, update2) || noop;
    g(s);
    return () => {
      u.delete(b);
      if (0 === u.size && o) {
        o();
        o = null;
      }
    };
  }
  return {
    set,
    update: update2,
    subscribe: subscribe2
  };
}

var WrappedNotice = class {
  constructor(s, r) {
    var o;
    let u = "";
    if (s instanceof DocumentFragment) u = null != (o = s.textContent) ? o : ""; else u = s;
    Logger(u, LOG_LEVEL_NOTICE);
  }
  setMessage(s) {
    var r;
    let o = "";
    if (s instanceof DocumentFragment) o = null != (r = s.textContent) ? r : ""; else o = s;
    Logger(o, LOG_LEVEL_NOTICE);
    return this;
  }
  hide() {}
}, _notice = WrappedNotice;

function setNoticeClass(s) {
  _notice = s;
}

var LiveSyncCommands = class {
  get app() {
    return this.plugin.app;
  }
  get settings() {
    return this.plugin.settings;
  }
  get localDatabase() {
    return this.plugin.localDatabase;
  }
  id2path(s, r, o) {
    return this.plugin.id2path(s, r, o);
  }
  async path2id(s, r) {
    return await this.plugin.path2id(s, r);
  }
  getPath(s) {
    return this.plugin.getPath(s);
  }
  constructor(s) {
    this.plugin = s;
  }
};

function add_css(s) {
  append_styles(s, "svelte-guf68w", ".deleted.svelte-guf68w{text-decoration:line-through}.svelte-guf68w{box-sizing:border-box}.scroller.svelte-guf68w{display:flex;flex-direction:column;overflow-y:scroll;max-height:60vh;user-select:text}.json-source.svelte-guf68w{white-space:pre;height:auto;overflow:auto;min-height:var(--font-ui-medium);flex-grow:1}");
}

function get_each_context(s, r, o) {
  const u = s.slice();
  u[25] = r[o];
  return u;
}

function get_each_context_1(s, r, o) {
  const u = s.slice();
  u[28] = r[o];
  return u;
}

function create_else_block(s) {
  let r, o, u, g, _, b, w, E = new Date(s[3].mtime).toLocaleString() + "", S, L, O = s[5].length + "", D, k, C, T, I, A, x, R = new Date(s[4].mtime).toLocaleString() + "", P, N, B = s[6].length + "", F, M, V, G, j, q, z, U = ensure_array_like(s[11]), W = [];
  for (let r = 0; r < U.length; r += 1) W[r] = create_each_block_1(get_each_context_1(s, U, r));
  function select_block_type_1(s, r) {
    if (false != s[8]) return create_if_block_3;
    return create_else_block_1;
  }
  let H = select_block_type_1(s, -1), K = H(s), Q = s[3]._id == s[4]._id && create_if_block_2(s), J = s[3]._id == s[4]._id && create_if_block_1(s);
  return {
    c() {
      r = element("div");
      for (let s = 0; s < W.length; s += 1) W[s].c();
      o = space();
      K.c();
      u = space();
      g = element("div");
      _ = text(s[1]);
      b = space();
      if (Q) Q.c();
      w = text(" ,");
      S = text(E);
      L = space();
      D = text(O);
      k = text(" letters");
      C = space();
      T = element("div");
      I = text(s[2]);
      A = space();
      if (J) J.c();
      x = text(" ,");
      P = text(R);
      N = space();
      F = text(B);
      M = text(" letters");
      V = space();
      G = element("div");
      j = element("button");
      j.textContent = "Apply";
      attr(r, "class", "options svelte-guf68w");
      attr(g, "class", "svelte-guf68w");
      attr(T, "class", "svelte-guf68w");
      attr(j, "class", "svelte-guf68w");
      attr(G, "class", "buttons svelte-guf68w");
    },
    m(E, O) {
      insert(E, r, O);
      for (let s = 0; s < W.length; s += 1) if (W[s]) W[s].m(r, null);
      insert(E, o, O);
      K.m(E, O);
      insert(E, u, O);
      insert(E, g, O);
      append(g, _);
      append(g, b);
      if (Q) Q.m(g, null);
      append(g, w);
      append(g, S);
      append(g, L);
      append(g, D);
      append(g, k);
      insert(E, C, O);
      insert(E, T, O);
      append(T, I);
      append(T, A);
      if (J) J.m(T, null);
      append(T, x);
      append(T, P);
      append(T, N);
      append(T, F);
      append(T, M);
      insert(E, V, O);
      insert(E, G, O);
      append(G, j);
      if (!q) {
        z = listen(j, "click", s[12]);
        q = true;
      }
    },
    p(s, o) {
      if (2688 & o) {
        U = ensure_array_like(s[11]);
        let u;
        for (u = 0; u < U.length; u += 1) {
          const g = get_each_context_1(s, U, u);
          if (W[u]) W[u].p(g, o); else {
            W[u] = create_each_block_1(g);
            W[u].c();
            W[u].m(r, null);
          }
        }
        for (;u < W.length; u += 1) W[u].d(1);
        W.length = U.length;
      }
      if (H === (H = select_block_type_1(s, o)) && K) K.p(s, o); else {
        K.d(1);
        K = H(s);
        if (K) {
          K.c();
          K.m(u.parentNode, u);
        }
      }
      if (2 & o) set_data(_, s[1]);
      if (s[3]._id == s[4]._id) if (Q) Q.p(s, o); else {
        Q = create_if_block_2(s);
        Q.c();
        Q.m(g, w);
      } else if (Q) {
        Q.d(1);
        Q = null;
      }
      if (8 & o && E !== (E = new Date(s[3].mtime).toLocaleString() + "")) set_data(S, E);
      if (32 & o && O !== (O = s[5].length + "")) set_data(D, O);
      if (4 & o) set_data(I, s[2]);
      if (s[3]._id == s[4]._id) if (J) J.p(s, o); else {
        J = create_if_block_1(s);
        J.c();
        J.m(T, x);
      } else if (J) {
        J.d(1);
        J = null;
      }
      if (16 & o && R !== (R = new Date(s[4].mtime).toLocaleString() + "")) set_data(P, R);
      if (64 & o && B !== (B = s[6].length + "")) set_data(F, B);
    },
    d(s) {
      if (s) {
        detach(r);
        detach(o);
        detach(u);
        detach(g);
        detach(C);
        detach(T);
        detach(V);
        detach(G);
      }
      destroy_each(W, s);
      K.d(s);
      if (Q) Q.d();
      if (J) J.d();
      q = false;
      z();
    }
  };
}

function create_if_block(s) {
  let r, o, u, g, _, b;
  return {
    c() {
      r = element("div");
      r.textContent = "Just for a minute, please!";
      o = space();
      u = element("div");
      g = element("button");
      g.textContent = "Dismiss";
      attr(r, "class", "message svelte-guf68w");
      attr(g, "class", "svelte-guf68w");
      attr(u, "class", "buttons svelte-guf68w");
    },
    m(w, E) {
      insert(w, r, E);
      insert(w, o, E);
      insert(w, u, E);
      append(u, g);
      if (!_) {
        b = listen(g, "click", s[12]);
        _ = true;
      }
    },
    p: noop,
    d(s) {
      if (s) {
        detach(r);
        detach(o);
        detach(u);
      }
      _ = false;
      b();
    }
  };
}

function create_if_block_4(s) {
  let r, o, u, g = false, _, b, w = s[28][1] + "", E, S, L, O, D;
  L = init_binding_group(s[21][0]);
  return {
    c() {
      r = element("label");
      o = element("input");
      _ = space();
      b = element("div");
      E = text(w);
      attr(o, "type", "radio");
      attr(o, "name", "disp");
      o.__value = u = s[28][0];
      set_input_value(o, o.__value);
      attr(o, "class", "sls-setting-tab svelte-guf68w");
      attr(b, "class", "sls-setting-menu-btn svelte-guf68w");
      attr(r, "class", S = null_to_empty("sls-setting-label " + (s[28][0] == s[7] ? "selected" : "")) + " svelte-guf68w");
      L.p(o);
    },
    m(u, g) {
      insert(u, r, g);
      append(r, o);
      o.checked = o.__value === s[7];
      append(r, _);
      append(r, b);
      append(b, E);
      if (!O) {
        D = listen(o, "change", s[20]);
        O = true;
      }
    },
    p(s, _) {
      if (2048 & _ && u !== (u = s[28][0])) {
        o.__value = u;
        set_input_value(o, o.__value);
        g = true;
      }
      if (g || 2176 & _) o.checked = o.__value === s[7];
      if (2048 & _ && w !== (w = s[28][1] + "")) set_data(E, w);
      if (2176 & _ && S !== (S = null_to_empty("sls-setting-label " + (s[28][0] == s[7] ? "selected" : "")) + " svelte-guf68w")) attr(r, "class", S);
    },
    d(s) {
      if (s) detach(r);
      L.r();
      O = false;
      D();
    }
  };
}

function create_each_block_1(s) {
  let r, o = ("" == s[28][0] || false != s[9][s[28][0]]) && create_if_block_4(s);
  return {
    c() {
      if (o) o.c();
      r = empty();
    },
    m(s, u) {
      if (o) o.m(s, u);
      insert(s, r, u);
    },
    p(s, u) {
      if ("" == s[28][0] || false != s[9][s[28][0]]) if (o) o.p(s, u); else {
        o = create_if_block_4(s);
        o.c();
        o.m(r.parentNode, r);
      } else if (o) {
        o.d(1);
        o = null;
      }
    },
    d(s) {
      if (s) detach(r);
      if (o) o.d(s);
    }
  };
}

function create_else_block_1(s) {
  let r;
  return {
    c() {
      r = text("NO PREVIEW");
    },
    m(s, o) {
      insert(s, r, o);
    },
    p: noop,
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_if_block_3(s) {
  let r, o = ensure_array_like(s[10]), u = [];
  for (let r = 0; r < o.length; r += 1) u[r] = create_each_block(get_each_context(s, o, r));
  return {
    c() {
      r = element("div");
      for (let s = 0; s < u.length; s += 1) u[s].c();
      attr(r, "class", "op-scrollable json-source svelte-guf68w");
    },
    m(s, o) {
      insert(s, r, o);
      for (let s = 0; s < u.length; s += 1) if (u[s]) u[s].m(r, null);
    },
    p(s, g) {
      if (1024 & g) {
        o = ensure_array_like(s[10]);
        let _;
        for (_ = 0; _ < o.length; _ += 1) {
          const b = get_each_context(s, o, _);
          if (u[_]) u[_].p(b, g); else {
            u[_] = create_each_block(b);
            u[_].c();
            u[_].m(r, null);
          }
        }
        for (;_ < u.length; _ += 1) u[_].d(1);
        u.length = o.length;
      }
    },
    d(s) {
      if (s) detach(r);
      destroy_each(u, s);
    }
  };
}

function create_each_block(s) {
  let r, o = s[25][1] + "", u, g;
  return {
    c() {
      r = element("span");
      u = text(o);
      attr(r, "class", g = null_to_empty(s[25][0] == import_diff_match_patch.DIFF_DELETE ? "deleted" : s[25][0] == import_diff_match_patch.DIFF_INSERT ? "added" : "normal") + " svelte-guf68w");
    },
    m(s, o) {
      insert(s, r, o);
      append(r, u);
    },
    p(s, _) {
      if (1024 & _ && o !== (o = s[25][1] + "")) set_data(u, o);
      if (1024 & _ && g !== (g = null_to_empty(s[25][0] == import_diff_match_patch.DIFF_DELETE ? "deleted" : s[25][0] == import_diff_match_patch.DIFF_INSERT ? "added" : "normal") + " svelte-guf68w")) attr(r, "class", g);
    },
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_if_block_2(s) {
  let r, o = revStringToRevNumber(s[3]._rev) + "", u;
  return {
    c() {
      r = text("Rev:");
      u = text(o);
    },
    m(s, o) {
      insert(s, r, o);
      insert(s, u, o);
    },
    p(s, r) {
      if (8 & r && o !== (o = revStringToRevNumber(s[3]._rev) + "")) set_data(u, o);
    },
    d(s) {
      if (s) {
        detach(r);
        detach(u);
      }
    }
  };
}

function create_if_block_1(s) {
  let r, o = revStringToRevNumber(s[4]._rev) + "", u;
  return {
    c() {
      r = text("Rev:");
      u = text(o);
    },
    m(s, o) {
      insert(s, r, o);
      insert(s, u, o);
    },
    p(s, r) {
      if (16 & r && o !== (o = revStringToRevNumber(s[4]._rev) + "")) set_data(u, o);
    },
    d(s) {
      if (s) {
        detach(r);
        detach(u);
      }
    }
  };
}

function create_fragment(s) {
  let r, o, u, g, _, b;
  function select_block_type(s, r) {
    if (!s[3] || !s[4]) return create_if_block;
    return create_else_block;
  }
  let w = select_block_type(s, -1), E = w(s);
  return {
    c() {
      r = element("h1");
      r.textContent = "Conflicted settings";
      o = space();
      u = element("h2");
      g = text(s[0]);
      _ = space();
      E.c();
      b = empty();
      attr(r, "class", "svelte-guf68w");
      attr(u, "class", "svelte-guf68w");
    },
    m(s, w) {
      insert(s, r, w);
      insert(s, o, w);
      insert(s, u, w);
      append(u, g);
      insert(s, _, w);
      E.m(s, w);
      insert(s, b, w);
    },
    p(s, [r]) {
      if (1 & r) set_data(g, s[0]);
      if (w === (w = select_block_type(s, r)) && E) E.p(s, r); else {
        E.d(1);
        E = w(s);
        if (E) {
          E.c();
          E.m(b.parentNode, b);
        }
      }
    },
    i: noop,
    o: noop,
    d(s) {
      if (s) {
        detach(r);
        detach(o);
        detach(u);
        detach(_);
        detach(b);
      }
      E.d(s);
    }
  };
}

function revStringToRevNumber(s) {
  return s.split("-")[0];
}

function instance(s, r, o) {
  let u, g, _, {docs: b = []} = r, {callback: w = (async (s, r) => {
    Promise.resolve();
  })} = r, {filename: E = ""} = r, {nameA: S = "A"} = r, {nameB: L = "B"} = r, {defaultSelect: O = ""} = r, D, k, C = "", T = "", I = {}, A = {}, x = {}, R = {}, P, N = O;
  function docToString(s) {
    return "plain" == s.datatype ? getDocData(s.data) : base64ToString(s.data);
  }
  function getDiff(s, r) {
    const o = new import_diff_match_patch.diff_match_patch, u = o.diff_linesToChars_(s, r), g = o.diff_main(u.chars1, u.chars2, false);
    o.diff_charsToLines_(g, u.lineArray);
    return g;
  }
  function getJsonDiff(s, r) {
    return getDiff(JSON.stringify(s, null, 2), JSON.stringify(r, null, 2));
  }
  function apply() {
    if (D._id == k._id) {
      if ("A" == N) return w(D._rev, null);
      if ("B" == N) return w(k._rev, null);
    } else {
      if ("A" == N) return w(null, docToString(D));
      if ("B" == N) return w(null, docToString(k));
    }
    if ("BA" == N) return w(null, JSON.stringify(R, null, 2));
    if ("AB" == N) return w(null, JSON.stringify(x, null, 2));
    w(null, null);
  }
  const B = [ [] ];
  function input_change_handler() {
    N = this.__value;
    o(7, N);
  }
  s.$$set = s => {
    if ("docs" in s) o(13, b = s.docs);
    if ("callback" in s) o(14, w = s.callback);
    if ("filename" in s) o(0, E = s.filename);
    if ("nameA" in s) o(1, S = s.nameA);
    if ("nameB" in s) o(2, L = s.nameB);
    if ("defaultSelect" in s) o(15, O = s.defaultSelect);
  };
  s.$$.update = () => {
    if (991352 & s.$$.dirty) if (b && b.length >= 1) {
      if (b[0].mtime < b[1].mtime) {
        o(3, D = b[0]);
        o(4, k = b[1]);
      } else {
        o(3, D = b[1]);
        o(4, k = b[0]);
      }
      o(5, C = docToString(D));
      o(6, T = docToString(k));
      try {
        o(16, I = false);
        o(17, A = false);
        o(16, I = JSON.parse(C));
        o(17, A = JSON.parse(T));
        o(18, x = mergeObject(I, A));
        o(19, R = mergeObject(A, I));
        if (JSON.stringify(x) == JSON.stringify(R)) o(19, R = false);
      } catch (s) {
        o(19, R = false);
        o(18, x = false);
      }
    }
    if (983040 & s.$$.dirty) o(9, u = {
      "": false,
      A: I,
      B: A,
      AB: x,
      BA: R
    });
    if (640 & s.$$.dirty) o(8, g = N in u ? u[N] : {});
    if (65792 & s.$$.dirty) o(10, P = getJsonDiff(I, g));
    if (6 & s.$$.dirty) o(11, _ = [ [ "", "Not now" ], [ "A", S || "A" ], [ "B", L || "B" ], [ "AB", `${S || "A"} + ${L || "B"}` ], [ "BA", `${L || "B"} + ${S || "A"}` ] ]);
  };
  return [ E, S, L, D, k, C, T, N, g, u, P, _, apply, b, w, O, I, A, x, R, input_change_handler, B ];
}

var JsonResolvePane = class extends SvelteComponent {
  constructor(s) {
    super();
    init2(this, s, instance, create_fragment, safe_not_equal, {
      docs: 13,
      callback: 14,
      filename: 0,
      nameA: 1,
      nameB: 2,
      defaultSelect: 15
    }, add_css);
  }
}, JsonResolvePane_default = JsonResolvePane, JsonResolveModal = class extends import_obsidian.Modal {
  constructor(s, r, o, u, g, _, b) {
    super(s);
    this.callback = u;
    this.filename = r;
    this.docs = o;
    this.nameA = g;
    this.nameB = _;
    this.defaultSelect = b;
  }
  async UICallback(s, r) {
    this.close();
    await this.callback(s, r);
    this.callback = null;
  }
  onOpen() {
    const {contentEl: s} = this;
    s.empty();
    if (null == this.component) this.component = new JsonResolvePane_default({
      target: s,
      props: {
        docs: this.docs,
        filename: this.filename,
        nameA: this.nameA,
        nameB: this.nameB,
        defaultSelect: this.defaultSelect,
        callback: (s, r) => this.UICallback(s, r)
      }
    });
    return;
  }
  onClose() {
    const {contentEl: s} = this;
    s.empty();
    if (null != this.callback) this.callback(null);
    if (null != this.component) {
      this.component.$destroy();
      this.component = null;
    }
  }
};

function serialize(s) {
  return JSON.stringify(s, null, 1);
}

function deserialize(s, r) {
  try {
    return JSON.parse(s);
  } catch (o) {
    try {
      return (0, import_obsidian.parseYaml)(s);
    } catch (s) {
      return r;
    }
  }
}

var pluginList = writable([]), pluginIsEnumerating = writable(false), ConfigSync = class extends LiveSyncCommands {
  constructor() {
    super(...arguments);
    this.confirmPopup = null;
    this.pluginDialog = null;
    this.periodicPluginSweepProcessor = new PeriodicProcessor(this.plugin, (async () => await this.scanAllConfigFiles(false)));
    this.pluginList = [];
    this.recentProcessedInternalFiles = [];
  }
  get kvDB() {
    return this.plugin.kvDB;
  }
  ensureDirectoryEx(s) {
    return this.plugin.ensureDirectoryEx(s);
  }
  showPluginSyncModal() {
    if (!this.settings.usePluginSync) return;
    if (null != this.pluginDialog) this.pluginDialog.open(); else {
      this.pluginDialog = new PluginDialogModal(this.app, this.plugin);
      this.pluginDialog.open();
    }
  }
  hidePluginSyncModal() {
    if (null != this.pluginDialog) {
      this.pluginDialog.close();
      this.pluginDialog = null;
    }
  }
  onunload() {
    var s;
    this.hidePluginSyncModal();
    null == (s = this.periodicPluginSweepProcessor) || s.disable();
  }
  onload() {
    this.plugin.addCommand({
      id: "livesync-plugin-dialog-ex",
      name: "Show customization sync dialog",
      callback: () => {
        this.showPluginSyncModal();
      }
    });
  }
  getFileCategory(s) {
    if (2 == s.split("/").length && s.endsWith(".json")) return "CONFIG";
    if (4 == s.split("/").length && s.startsWith(`${this.app.vault.configDir}/themes/`)) return "THEME";
    if (s.startsWith(`${this.app.vault.configDir}/snippets/`) && s.endsWith(".css")) return "SNIPPET";
    if (s.startsWith(`${this.app.vault.configDir}/plugins/`)) if (s.endsWith("/styles.css") || s.endsWith("/manifest.json") || s.endsWith("/main.js")) return "PLUGIN_MAIN"; else if (s.endsWith("/data.json")) return "PLUGIN_DATA"; else return "";
    return "";
  }
  isTargetPath(s) {
    if (!s.startsWith(this.app.vault.configDir)) return false;
    return "" != this.getFileCategory(s);
  }
  async onInitializeDatabase(s) {
    if (this.settings.usePluginSync) try {
      Logger("Scanning customizations...");
      await this.scanAllConfigFiles(s);
      Logger("Scanning customizations : done");
    } catch (s) {
      Logger("Scanning customizations : failed");
      Logger(s, LOG_LEVEL_VERBOSE);
    }
  }
  async beforeReplicate(s) {
    if (this.settings.autoSweepPlugins && this.settings.usePluginSync) await this.scanAllConfigFiles(s);
  }
  async onResume() {
    if (this.plugin.suspended) return;
    if (this.settings.autoSweepPlugins && this.settings.usePluginSync) await this.scanAllConfigFiles(false);
    this.periodicPluginSweepProcessor.enable(this.settings.autoSweepPluginsPeriodic && !this.settings.watchInternalFileChanges ? 1e3 * PERIODIC_PLUGIN_SWEEP : 0);
  }
  async reloadPluginList(s) {
    this.pluginList = [];
    pluginList.set(this.pluginList);
    await this.updatePluginList(s);
  }
  async updatePluginList(s, r) {
    const o = s ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO;
    if (!this.settings.usePluginSync) {
      this.pluginList = [];
      pluginList.set(this.pluginList);
      return;
    }
    await Promise.resolve();
    scheduleTask("update-plugin-list-task", 200, (async () => {
      await runWithLock("update-plugin-list", false, (async () => {
        try {
          const s = r ? await this.path2id(r) : "", u = r ? this.localDatabase.findEntries(s, s + "􏿿", {
            include_docs: true,
            key: s,
            limit: 1
          }) : this.localDatabase.findEntries(ICXHeader + "", `${ICXHeader}􏿿`, {
            include_docs: true
          });
          let g = 0;
          pluginIsEnumerating.set(true);
          for await (const s of processAllGeneratorTasksWithConcurrencyLimit(20, pipeGeneratorToGenerator(u, (async s => {
            const u = s.path || this.getPath(s);
            if (r && r != u) return false;
            const _ = this.pluginList.find((s => s.documentPath == u));
            if (_ && _.mtime == s.mtime) return false;
            try {
              g++;
              if (g % 10 == 0) Logger(`Enumerating files... ${g}`, o, "get-plugins");
              Logger(`plugin-${u}`, LOG_LEVEL_VERBOSE);
              const s = await this.localDatabase.getDBEntry(u, null, false, false);
              if (s) {
                const r = deserialize(getDocData(s.data), {}), o = [];
                for (const s of r.files) {
                  const r = {
                    ...s
                  }, u = getDocData(r.data);
                  r.data = [ crc32CKHash(u) ];
                  o.push(r);
                }
                return {
                  ...r,
                  documentPath: this.getPath(s),
                  files: o
                };
              }
            } catch (s) {
              Logger(`Something happened at enumerating customization :${u}`, LOG_LEVEL_NOTICE);
              console.warn(s);
            }
            return false;
          })))) if ("ok" in s) if (false != s.ok) {
            let o = [ ...this.pluginList ];
            const u = s.ok;
            o = o.filter((s => s.documentPath != u.documentPath));
            o.push(u);
            if ("" != r) o = o.filter((s => s.documentPath != r));
            this.pluginList = o;
            pluginList.set(o);
          }
          Logger("All files enumerated", o, "get-plugins");
        } finally {
          pluginIsEnumerating.set(false);
        }
      }));
    }));
  }
  async compareUsingDisplayData(s, r) {
    const o = await this.localDatabase.getDBEntry(s.documentPath), u = await this.localDatabase.getDBEntry(r.documentPath);
    if (o && u) {
      const g = deserialize(getDocData(o.data), {});
      g.documentPath = s.documentPath;
      const _ = deserialize(getDocData(u.data), {});
      _.documentPath = r.documentPath;
      return await this.showJSONMergeDialogAndMerge(o, u, g, _);
    }
    return false;
  }
  showJSONMergeDialogAndMerge(s, r, o, u) {
    const g = {
      ...o.files[0],
      ctime: o.files[0].mtime,
      _id: `${o.documentPath}`
    }, _ = u.files[0], b = {
      ...s,
      ...g
    }, w = {
      ...r,
      ..._
    };
    return runWithLock("config:merge-data", false, (() => new Promise((s => {
      Logger("Opening data-merging dialog", LOG_LEVEL_VERBOSE);
      const r = stripAllPrefixes(b.path.split("/").slice(-1).join("/")), u = void 0;
      new JsonResolveModal(this.app, r, [ b, w ], (async (r, u) => {
        if (null == u) return s(false);
        try {
          s(await this.applyData(o, u));
        } catch (r) {
          Logger("Could not apply merged file");
          Logger(r, LOG_LEVEL_VERBOSE);
          s(false);
        }
      }), "📡", "🛰️", "B").open();
    }))));
  }
  async applyData(s, r) {
    Logger(`Applying ${s.displayName || s.name}..`);
    const o = this.app.vault.configDir;
    try {
      if (!s.documentPath) throw "InternalError: Document path not exist";
      const u = await this.localDatabase.getDBEntry(s.documentPath);
      if (false == u) throw "Not found on database";
      const g = deserialize(getDocData(u.data), {});
      for (const u of g.files) {
        Logger(`Applying ${u.filename} of ${s.displayName || s.name}..`);
        try {
          const g = `${o}/${u.filename}`;
          await this.ensureDirectoryEx(g);
          if (!r) {
            const s = base64ToArrayBuffer(u.data);
            await this.app.vault.adapter.writeBinary(g, s);
          } else await this.app.vault.adapter.write(g, r);
          Logger(`Applying ${u.filename} of ${s.displayName || s.name}.. Done`);
        } catch (r) {
          Logger(`Applying ${u.filename} of ${s.displayName || s.name}.. Failed`);
          Logger(r, LOG_LEVEL_VERBOSE);
        }
      }
      const _ = `${o}/${g.files[0].filename}`;
      await this.storeCustomizationFiles(_);
      await this.updatePluginList(true, _);
      await delay(100);
      Logger(`Config ${s.displayName || s.name} has been applied`, LOG_LEVEL_NOTICE);
      if ("PLUGIN_DATA" == s.category || "PLUGIN_MAIN" == s.category) {
        const r = Object.values(this.app.plugins.manifests), u = this.app.plugins.enabledPlugins, g = r.find((r => u.has(r.id) && r.dir == `${o}/plugins/${s.name}`));
        if (g) {
          Logger(`Unloading plugin: ${g.name}`, LOG_LEVEL_NOTICE, "plugin-reload-" + g.id);
          await this.app.plugins.unloadPlugin(g.id);
          await this.app.plugins.loadPlugin(g.id);
          Logger(`Plugin reloaded: ${g.name}`, LOG_LEVEL_NOTICE, "plugin-reload-" + g.id);
        }
      } else if ("CONFIG" == s.category) scheduleTask("configReload", 250, (async () => {
        if ("yes" == await askYesNo(this.app, "Do you want to restart and reload Obsidian now?")) this.app.commands.executeCommandById("app:reload");
      }));
      return true;
    } catch (r) {
      Logger(`Applying ${s.displayName || s.name}.. Failed`);
      Logger(r, LOG_LEVEL_VERBOSE);
      return false;
    }
  }
  async deleteData(s) {
    try {
      if (s.documentPath) {
        await this.deleteConfigOnDatabase(s.documentPath);
        await this.updatePluginList(false, s.documentPath);
        Logger(`Delete: ${s.documentPath}`, LOG_LEVEL_NOTICE);
      }
      return true;
    } catch (r) {
      Logger(`Failed to delete: ${s.documentPath}`, LOG_LEVEL_NOTICE);
      return false;
    }
  }
  async parseReplicationResultItem(s) {
    if (s._id.startsWith(ICXHeader)) {
      if (this.plugin.settings.usePluginSync) await this.updatePluginList(false, s.path ? s.path : this.getPath(s));
      if (this.plugin.settings.usePluginSync && this.plugin.settings.notifyPluginOrSettingUpdated) if (!this.pluginDialog || this.pluginDialog && !this.pluginDialog.isOpened()) {
        const s = createFragment((s => {
          s.createEl("span", null, (s => {
            s.appendText("Some configuration has been arrived, Press ");
            s.appendChild(s.createEl("a", null, (s => {
              s.text = "HERE";
              s.addEventListener("click", (() => {
                this.showPluginSyncModal();
              }));
            })));
            s.appendText(" to open the config sync dialog , or press elsewhere to dismiss this message.");
          }));
        })), r = "popupUpdated-plugins";
        scheduleTask(r, 1e3, (async () => {
          var o;
          const u = await memoIfNotExist(r, (() => new import_obsidian.Notice(s, 0))), g = void 0;
          if (!(null == (o = null == u ? void 0 : u.noticeEl) ? void 0 : o.isShown())) memoObject(r, new import_obsidian.Notice(s, 0));
          scheduleTask(r + "-close", 2e4, (() => {
            var s;
            const o = retrieveMemoObject(r);
            if (!o) return;
            if (null == (s = null == o ? void 0 : o.noticeEl) ? void 0 : s.isShown()) o.hide();
            disposeMemoObject(r);
          }));
        }));
      }
      return true;
    }
    return false;
  }
  async realizeSettingSyncMode() {
    var s;
    null == (s = this.periodicPluginSweepProcessor) || s.disable();
    if (this.plugin.suspended) return;
    if (!this.settings.usePluginSync) return;
    if (this.settings.autoSweepPlugins) await this.scanAllConfigFiles(false);
    this.periodicPluginSweepProcessor.enable(this.settings.autoSweepPluginsPeriodic && !this.settings.watchInternalFileChanges ? 1e3 * PERIODIC_PLUGIN_SWEEP : 0);
    return;
  }
  async makeEntryFromFile(s) {
    const r = await this.app.vault.adapter.stat(s);
    let o, u;
    if (!r) return false;
    const g = await this.app.vault.adapter.readBinary(s);
    let _;
    try {
      _ = await arrayBufferToBase64(g);
      if (s.toLowerCase().endsWith("/manifest.json")) {
        const r = readString(new Uint8Array(g));
        try {
          const s = JSON.parse(r);
          if ("version" in s) o = `${s.version}`;
          if ("name" in s) u = `${s.name}`;
        } catch (r) {
          Logger(`Configuration sync data: ${s} looks like manifest, but could not read the version`, LOG_LEVEL_INFO);
        }
      }
    } catch (r) {
      Logger(`The file ${s} could not be encoded`);
      Logger(r, LOG_LEVEL_VERBOSE);
      return false;
    }
    const b = r.mtime;
    return {
      filename: s.substring(this.app.vault.configDir.length + 1),
      data: _,
      mtime: b,
      size: r.size,
      version: o,
      displayName: u
    };
  }
  filenameToUnifiedKey(s, r) {
    const o = r || this.plugin.deviceAndVaultName, u = this.getFileCategory(s), g = "CONFIG" == u || "SNIPPET" == u ? s.split("/").slice(-1)[0] : "PLUGIN_ETC" == u ? s.split("/").slice(-2).join("/") : s.split("/").slice(-2)[0];
    return `${ICXHeader}${o}/${u}/${g}.md`;
  }
  async storeCustomizationFiles(s, r) {
    const o = r || this.plugin.deviceAndVaultName;
    if ("" == o) {
      Logger("We have to configure the device name", LOG_LEVEL_NOTICE);
      return;
    }
    const u = this.filenameToUnifiedKey(s, o);
    return await runWithLock(`plugin-${u}`, false, (async () => {
      const r = this.getFileCategory(s);
      let u = 0, g = [];
      const _ = "CONFIG" == r || "SNIPPET" == r ? s.split("/").reverse()[0] : s.split("/").reverse()[1], b = s.split("/").slice(0, -1).join("/"), w = this.filenameToUnifiedKey(s, o), E = await this.path2id(w), S = {
        category: r,
        files: [],
        name: _,
        mtime: 0,
        term: o
      };
      if ("CONFIG" == r || "SNIPPET" == r || "PLUGIN_ETC" == r || "PLUGIN_DATA" == r) {
        g = [ s ];
        if ("PLUGIN_ETC" == r) S.displayName = s.split("/").slice(-1).join("/");
      } else if ("PLUGIN_MAIN" == r) g = [ "manifest.json", "main.js", "styles.css" ].map((s => `${b}/${s}`)); else if ("THEME" == r) g = [ "manifest.json", "theme.css" ].map((s => `${b}/${s}`));
      for (const s of g) {
        const r = await this.makeEntryFromFile(s);
        if (false == r) continue;
        if (r.version) S.version = r.version;
        if (r.displayName) S.displayName = r.displayName;
        u = 0 == u ? r.mtime : (r.mtime + u) / 2;
        S.files.push(r);
      }
      S.mtime = u;
      if (0 == S.files.length) {
        Logger(`Nothing left: deleting.. ${s}`);
        await this.deleteConfigOnDatabase(w);
        await this.updatePluginList(false, w);
        return;
      }
      const L = serialize(S);
      try {
        const s = await this.localDatabase.getDBEntryMeta(w, null, false);
        let r;
        if (false === s) r = {
          _id: E,
          path: w,
          data: L,
          mtime: u,
          ctime: u,
          datatype: "newnote",
          size: L.length,
          children: [],
          deleted: false,
          type: "newnote"
        }; else {
          if (s.mtime == u) return true;
          r = {
            ...s,
            data: L,
            mtime: u,
            size: L.length,
            datatype: "newnote",
            children: [],
            deleted: false,
            type: "newnote"
          };
        }
        const o = await this.localDatabase.putDBEntry(r);
        await this.updatePluginList(false, r.path);
        Logger(`STORAGE --\x3e DB:${w}: (config) Done`);
        return o;
      } catch (s) {
        Logger(`STORAGE --\x3e DB:${w}: (config) Failed`);
        Logger(s, LOG_LEVEL_VERBOSE);
        return false;
      }
    }));
  }
  async watchVaultRawEventsAsync(s) {
    if (!this.settings.usePluginSync) return false;
    if (!this.isTargetPath(s)) return false;
    const r = await this.app.vault.adapter.stat(s);
    if (r && "file" != r.type) return false;
    const o = void 0, u = `${s}-${~~((r && r.mtime || 0) / 1e3)}`;
    if (this.recentProcessedInternalFiles.contains(u)) return true;
    this.recentProcessedInternalFiles = [ u, ...this.recentProcessedInternalFiles ].slice(0, 100);
    this.storeCustomizationFiles(s).then((() => {}));
  }
  async scanAllConfigFiles(s) {
    const r = void 0;
    Logger("Scanning customizing files.", s ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "scan-all-config");
    const o = this.plugin.deviceAndVaultName;
    if ("" == o) {
      Logger("We have to configure the device name", LOG_LEVEL_NOTICE);
      return;
    }
    const u = void 0, g = (await this.scanInternalFiles()).filter((s => this.isTargetPath(s))).map((s => ({
      key: this.filenameToUnifiedKey(s),
      file: s
    }))), _ = [ ...new Set(g.map((s => s.key))) ], b = void 0;
    let w = (await this.localDatabase.allDocsRaw({
      startkey: ICXHeader + "",
      endkey: `${ICXHeader}􏿿`,
      include_docs: true
    })).rows.map((s => s.doc)).filter((s => !s.deleted)).map((s => this.getPath(s))).filter((s => s.startsWith(`${ICXHeader}${o}/`)));
    for (const s of _) {
      const r = g.find((r => r.key == s)).file;
      await this.storeCustomizationFiles(r);
      w = w.filter((r => r != s));
    }
    for (const s of w) await this.deleteConfigOnDatabase(s);
    this.updatePluginList(false).then();
  }
  async deleteConfigOnDatabase(s, r = false) {
    const o = (new Date).getTime();
    await runWithLock("file-x-" + s, false, (async () => {
      try {
        const r = await this.localDatabase.getDBEntryMeta(s, null, false);
        let u;
        if (false === r) Logger(`STORAGE -x> DB:${s}: (config) already deleted (Not found on database)`); else {
          if (r.deleted) {
            Logger(`STORAGE -x> DB:${s}: (config) already deleted`);
            return;
          }
          u = {
            ...r,
            mtime: o,
            size: 0,
            children: [],
            deleted: true,
            type: "newnote"
          };
        }
        await this.localDatabase.putRaw(u);
        await this.updatePluginList(false, s);
        Logger(`STORAGE -x> DB:${s}: (config) Done`);
      } catch (r) {
        Logger(`STORAGE -x> DB:${s}: (config) Failed`);
        Logger(r, LOG_LEVEL_VERBOSE);
        return false;
      }
    }));
  }
  async scanInternalFiles() {
    const s = void 0;
    return (await this.getFiles(this.app.vault.configDir, 2)).filter((s => s.startsWith("."))).filter((s => !s.startsWith(".trash")));
  }
  async getFiles(s, r) {
    if (-1 == r) return [];
    const o = await this.app.vault.adapter.list(s);
    let u = [ ...o.files ];
    for (const s of o.folders) u = u.concat(await this.getFiles(s, r - 1));
    return u;
  }
};

function add_css2(s) {
  append_styles(s, "svelte-tsbdtg", ".spacer.svelte-tsbdtg{min-width:1px;flex-grow:1}button.svelte-tsbdtg{margin:2px 4px;min-width:3em;max-width:4em}button.svelte-tsbdtg:disabled{border:none;box-shadow:none;background-color:transparent;visibility:collapse}button.svelte-tsbdtg:disabled:hover{border:none;box-shadow:none;background-color:transparent;visibility:collapse}span.message.svelte-tsbdtg{color:var(--text-muted);font-size:var(--font-ui-smaller);padding:0 1em;line-height:var(--line-height-tight)}span.messages.svelte-tsbdtg{display:flex;flex-direction:column;align-items:center}.is-mobile .spacer.svelte-tsbdtg{margin-left:auto}");
}

function get_each_context2(s, r, o) {
  const u = s.slice();
  u[30] = r[o];
  return u;
}

function create_else_block_3(s) {
  let r, o, u, g, _, b, w;
  return {
    c() {
      r = element("span");
      o = space();
      u = element("span");
      u.textContent = "All devices are even";
      g = space();
      _ = element("button");
      b = space();
      w = element("button");
      attr(r, "class", "spacer svelte-tsbdtg");
      attr(u, "class", "message even svelte-tsbdtg");
      _.disabled = true;
      attr(_, "class", "svelte-tsbdtg");
      w.disabled = true;
      attr(w, "class", "svelte-tsbdtg");
    },
    m(s, E) {
      insert(s, r, E);
      insert(s, o, E);
      insert(s, u, E);
      insert(s, g, E);
      insert(s, _, E);
      insert(s, b, E);
      insert(s, w, E);
    },
    p: noop,
    d(s) {
      if (s) {
        detach(r);
        detach(o);
        detach(u);
        detach(g);
        detach(_);
        detach(b);
        detach(w);
      }
    }
  };
}

function create_if_block2(s) {
  let r, o, u, g = !s[0] && create_if_block_12(s);
  return {
    c() {
      r = element("span");
      o = space();
      if (g) g.c();
      u = empty();
      attr(r, "class", "spacer svelte-tsbdtg");
    },
    m(s, _) {
      insert(s, r, _);
      insert(s, o, _);
      if (g) g.m(s, _);
      insert(s, u, _);
    },
    p(s, r) {
      if (!s[0]) if (g) g.p(s, r); else {
        g = create_if_block_12(s);
        g.c();
        g.m(u.parentNode, u);
      } else if (g) {
        g.d(1);
        g = null;
      }
    },
    d(s) {
      if (s) {
        detach(r);
        detach(o);
        detach(u);
      }
      if (g) g.d(s);
    }
  };
}

function create_if_block_12(s) {
  let r, o, u, g, _, b, w, E, S, L, O, D, k, C, T, I, A, x, R = ensure_array_like(s[8]), P = [];
  for (let r = 0; r < R.length; r += 1) P[r] = create_each_block2(get_each_context2(s, R, r));
  function select_block_type_1(s, r) {
    if (s[6] || s[1] && "" != s[2]) return create_if_block_42;
    return create_else_block_2;
  }
  let N = select_block_type_1(s, [ -1, -1 ]), B = N(s), F = s[1] && create_if_block_22(s);
  return {
    c() {
      r = element("span");
      o = element("span");
      u = text(s[3]);
      g = space();
      _ = element("span");
      b = text(s[4]);
      w = space();
      E = element("span");
      S = text(s[5]);
      L = space();
      O = element("select");
      D = element("option");
      D.textContent = "-";
      for (let s = 0; s < P.length; s += 1) P[s].c();
      C = space();
      B.c();
      T = space();
      if (F) F.c();
      I = empty();
      attr(o, "class", "message svelte-tsbdtg");
      attr(_, "class", "message svelte-tsbdtg");
      attr(E, "class", "message svelte-tsbdtg");
      attr(r, "class", "messages svelte-tsbdtg");
      D.__value = k = "";
      set_input_value(D, D.__value);
      if (void 0 === s[2]) add_render_callback((() => s[24].call(O)));
    },
    m(k, R) {
      insert(k, r, R);
      append(r, o);
      append(o, u);
      append(r, g);
      append(r, _);
      append(_, b);
      append(r, w);
      append(r, E);
      append(E, S);
      insert(k, L, R);
      insert(k, O, R);
      append(O, D);
      for (let s = 0; s < P.length; s += 1) if (P[s]) P[s].m(O, null);
      select_option(O, s[2], true);
      insert(k, C, R);
      B.m(k, R);
      insert(k, T, R);
      if (F) F.m(k, R);
      insert(k, I, R);
      if (!A) {
        x = listen(O, "change", s[24]);
        A = true;
      }
    },
    p(s, r) {
      if (8 & r[0]) set_data(u, s[3]);
      if (16 & r[0]) set_data(b, s[4]);
      if (32 & r[0]) set_data(S, s[5]);
      if (256 & r[0]) {
        R = ensure_array_like(s[8]);
        let o;
        for (o = 0; o < R.length; o += 1) {
          const u = get_each_context2(s, R, o);
          if (P[o]) P[o].p(u, r); else {
            P[o] = create_each_block2(u);
            P[o].c();
            P[o].m(O, null);
          }
        }
        for (;o < P.length; o += 1) P[o].d(1);
        P.length = R.length;
      }
      if (260 & r[0]) select_option(O, s[2]);
      if (N === (N = select_block_type_1(s, r)) && B) B.p(s, r); else {
        B.d(1);
        B = N(s);
        if (B) {
          B.c();
          B.m(T.parentNode, T);
        }
      }
      if (s[1]) if (F) F.p(s, r); else {
        F = create_if_block_22(s);
        F.c();
        F.m(I.parentNode, I);
      } else if (F) {
        F.d(1);
        F = null;
      }
    },
    d(s) {
      if (s) {
        detach(r);
        detach(L);
        detach(O);
        detach(C);
        detach(T);
        detach(I);
      }
      destroy_each(P, s);
      B.d(s);
      if (F) F.d(s);
      A = false;
      x();
    }
  };
}

function create_each_block2(s) {
  let r, o = s[30] + "", u, g;
  return {
    c() {
      r = element("option");
      u = text(o);
      r.__value = g = s[30];
      set_input_value(r, r.__value);
    },
    m(s, o) {
      insert(s, r, o);
      append(r, u);
    },
    p(s, _) {
      if (256 & _[0] && o !== (o = s[30] + "")) set_data(u, o);
      if (256 & _[0] && g !== (g = s[30])) {
        r.__value = g;
        set_input_value(r, r.__value);
      }
    },
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_else_block_2(s) {
  let r, o, u;
  return {
    c() {
      r = element("button");
      o = space();
      u = element("button");
      r.disabled = true;
      attr(r, "class", "svelte-tsbdtg");
      u.disabled = true;
      attr(u, "class", "svelte-tsbdtg");
    },
    m(s, g) {
      insert(s, r, g);
      insert(s, o, g);
      insert(s, u, g);
    },
    p: noop,
    d(s) {
      if (s) {
        detach(r);
        detach(o);
        detach(u);
      }
    }
  };
}

function create_if_block_42(s) {
  let r, o, u, g;
  function select_block_type_2(s, r) {
    if (s[7]) return create_if_block_5;
    return create_else_block_12;
  }
  let _ = select_block_type_2(s, [ -1, -1 ]), b = _(s);
  return {
    c() {
      b.c();
      r = space();
      o = element("button");
      o.textContent = "✓";
      attr(o, "class", "svelte-tsbdtg");
    },
    m(_, w) {
      b.m(_, w);
      insert(_, r, w);
      insert(_, o, w);
      if (!u) {
        g = listen(o, "click", s[9]);
        u = true;
      }
    },
    p(s, o) {
      if (_ === (_ = select_block_type_2(s, o)) && b) b.p(s, o); else {
        b.d(1);
        b = _(s);
        if (b) {
          b.c();
          b.m(r.parentNode, r);
        }
      }
    },
    d(s) {
      if (s) {
        detach(r);
        detach(o);
      }
      b.d(s);
      u = false;
      g();
    }
  };
}

function create_else_block_12(s) {
  let r;
  return {
    c() {
      r = element("button");
      r.disabled = true;
      attr(r, "class", "svelte-tsbdtg");
    },
    m(s, o) {
      insert(s, r, o);
    },
    p: noop,
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_if_block_5(s) {
  let r, o, u;
  return {
    c() {
      r = element("button");
      r.textContent = "🔍";
      attr(r, "class", "svelte-tsbdtg");
    },
    m(g, _) {
      insert(g, r, _);
      if (!o) {
        u = listen(r, "click", s[10]);
        o = true;
      }
    },
    p: noop,
    d(s) {
      if (s) detach(r);
      o = false;
      u();
    }
  };
}

function create_if_block_22(s) {
  let r;
  function select_block_type_3(s, r) {
    if ("" != s[2]) return create_if_block_32;
    return create_else_block2;
  }
  let o = select_block_type_3(s, [ -1, -1 ]), u = o(s);
  return {
    c() {
      u.c();
      r = empty();
    },
    m(s, o) {
      u.m(s, o);
      insert(s, r, o);
    },
    p(s, g) {
      if (o === (o = select_block_type_3(s, g)) && u) u.p(s, g); else {
        u.d(1);
        u = o(s);
        if (u) {
          u.c();
          u.m(r.parentNode, r);
        }
      }
    },
    d(s) {
      if (s) detach(r);
      u.d(s);
    }
  };
}

function create_else_block2(s) {
  let r, o, u;
  return {
    c() {
      r = element("button");
      r.textContent = "📑";
      attr(r, "class", "svelte-tsbdtg");
    },
    m(g, _) {
      insert(g, r, _);
      if (!o) {
        u = listen(r, "click", s[12]);
        o = true;
      }
    },
    p: noop,
    d(s) {
      if (s) detach(r);
      o = false;
      u();
    }
  };
}

function create_if_block_32(s) {
  let r, o, u;
  return {
    c() {
      r = element("button");
      r.textContent = "🗑️";
      attr(r, "class", "svelte-tsbdtg");
    },
    m(g, _) {
      insert(g, r, _);
      if (!o) {
        u = listen(r, "click", s[11]);
        o = true;
      }
    },
    p: noop,
    d(s) {
      if (s) detach(r);
      o = false;
      u();
    }
  };
}

function create_fragment2(s) {
  let r;
  function select_block_type(s, r) {
    if (s[8].length > 0) return create_if_block2;
    return create_else_block_3;
  }
  let o = select_block_type(s, [ -1, -1 ]), u = o(s);
  return {
    c() {
      u.c();
      r = empty();
    },
    m(s, o) {
      u.m(s, o);
      insert(s, r, o);
    },
    p(s, g) {
      if (o === (o = select_block_type(s, g)) && u) u.p(s, g); else {
        u.d(1);
        u = o(s);
        if (u) {
          u.c();
          u.m(r.parentNode, r);
        }
      }
    },
    i: noop,
    o: noop,
    d(s) {
      if (s) detach(r);
      u.d(s);
    }
  };
}

function instance2(s, r, o) {
  let {list: u = []} = r, {thisTerm: g = ""} = r, {hideNotApplicable: _ = false} = r, {selectNewest: b = 0} = r, {applyAllPluse: w = 0} = r, {applyData: E} = r, {compareData: S} = r, {deleteData: L} = r, {hidden: O} = r, {plugin: D} = r, {isMaintenanceMode: k = false} = r;
  const C = D.addOnConfigSync;
  let T = "", I = "", A = "", x = "", R = false, P = false, N = 0, B = 0, F = [];
  async function comparePlugin(s, r) {
    var o, u;
    let g = "", _ = "", b = "", w = false, E = false, S = false;
    if (!s && !r) g = ""; else if (s && !r) g = "⚠ Local only"; else if (r && !s) {
      g = "✓ Remote only";
      E = true;
    } else {
      const _ = (null !== (o = null == s ? void 0 : s.mtime) && void 0 !== o ? o : 0) - (null !== (u = null == r ? void 0 : r.mtime) && void 0 !== u ? u : 0);
      if (_ / 1e3 < -10) {
        g = "✓ Newer";
        E = true;
        w = true;
      } else if (_ / 1e3 > 10) {
        g = "⚠ Older";
        E = true;
        w = true;
      } else {
        g = "⚖️ Same old";
        E = false;
        w = true;
      }
    }
    const L = (null == s ? void 0 : s.version) || "0.0.0", O = (null == r ? void 0 : r.version) || "0.0.0";
    if ((null == s ? void 0 : s.version) || (null == r ? void 0 : r.version)) {
      const s = versionNumberString2Number(L), r = versionNumberString2Number(O);
      if (s == r) b = "⚖️ Same ver."; else if (s > r) b = `⚠ Lower ${L} > ${O}`; else if (s < r) b = `✓ Higher ${L} < ${O}`;
    }
    if (w) {
      const {canApply: o, equivalency: u, canCompare: _} = await checkEquivalency(s, r);
      return {
        canApply: o,
        freshness: g,
        equivalency: u,
        version: b,
        canCompare: _
      };
    }
    return {
      canApply: E,
      freshness: g,
      equivalency: _,
      version: b,
      canCompare: S
    };
  }
  async function checkEquivalency(s, r) {
    let o = "", u = false, g = false;
    const _ = void 0, b = [ ...new Set([ ...s.files.map((s => s.filename)), ...r.files.map((s => s.filename)) ]) ].map((o => {
      const u = s.files.find((s => s.filename == o)), g = r.files.find((s => s.filename == o));
      if (!u && !g) return 0; else if (u && !g) return 2; else if (!u && g) return 8; else if (getDocData(u.data) == getDocData(g.data)) return 4; else return 16;
    })).reduce(((s, r) => s | r), 0);
    if (4 == b) {
      o = "⚖️ Same";
      u = false;
    } else if (b <= 4) {
      o = "Same or local only";
      u = false;
    } else if (16 == b) {
      u = true;
      g = true;
      o = "≠ Different";
    } else {
      u = true;
      g = true;
      o = "≠ Different";
    }
    return {
      equivalency: o,
      canApply: u,
      canCompare: g
    };
  }
  async function performCompare(s, r) {
    var u, g, _;
    const b = await comparePlugin(s, r);
    o(6, R = b.canApply);
    o(3, I = b.freshness);
    o(4, A = b.equivalency);
    o(5, x = b.version);
    o(7, P = b.canCompare);
    if (1 != (null == s ? void 0 : s.files.length) || !(null === (_ = null === (g = null === (u = null == s ? void 0 : s.files) || void 0 === u ? void 0 : u.first()) || void 0 === g ? void 0 : g.filename) || void 0 === _ ? void 0 : _.endsWith(".json"))) o(7, P = false);
  }
  async function updateTerms(s, r, u) {
    const b = s.find((s => s.term == g));
    o(2, T = "");
    if (u) o(8, F = [ ...new Set(s.map((s => s.term))) ]); else if (_) {
      const r = [], u = [ ...new Set(s.map((s => s.term))) ];
      for (const o of u) {
        const u = s.find((s => s.term == o));
        if ((await comparePlugin(b, u)).canApply) r.push(o);
      }
      o(8, F = [ ...r ]);
    } else o(8, F = [ ...new Set(s.map((s => s.term))) ].filter((s => s != g)));
    let w = b;
    if (r) {
      for (const r of F) {
        const o = s.find((s => s.term == r));
        if (o && o.mtime && ((null == w ? void 0 : w.mtime) || 0) < o.mtime) w = o;
      }
      if (w && w.term != g) o(2, T = w.term);
    }
  }
  async function applySelected() {
    const s = u.find((s => s.term == g)), r = u.find((s => s.term == T));
    if (r && await E(r)) scheduleTask("update-plugin-list", 250, (() => C.updatePluginList(true, s.documentPath)));
  }
  async function compareSelected() {
    const s = u.find((s => s.term == g)), r = u.find((s => s.term == T));
    if (s && r && await S(s, r)) scheduleTask("update-plugin-list", 250, (() => C.updatePluginList(true, s.documentPath)));
  }
  async function deleteSelected() {
    const s = u.find((s => s.term == T));
    if (s && await L(s)) scheduleTask("update-plugin-list", 250, (() => C.reloadPluginList(true)));
  }
  async function duplicateItem() {
    const s = u.find((s => s.term == g)), r = await askString(D.app, "Duplicate", "device name", "");
    if (r) {
      if (r.contains("/")) {
        Logger('We can not use "/" to the device name', LOG_LEVEL_NOTICE);
        return;
      }
      const o = `${D.app.vault.configDir}/${s.files[0].filename}`;
      await C.storeCustomizationFiles(o, r);
      await C.updatePluginList(false, C.filenameToUnifiedKey(o, r));
    }
  }
  function select_change_handler() {
    T = select_value(this);
    o(2, T);
    o(8, F);
  }
  s.$$set = s => {
    if ("list" in s) o(13, u = s.list);
    if ("thisTerm" in s) o(14, g = s.thisTerm);
    if ("hideNotApplicable" in s) o(15, _ = s.hideNotApplicable);
    if ("selectNewest" in s) o(16, b = s.selectNewest);
    if ("applyAllPluse" in s) o(17, w = s.applyAllPluse);
    if ("applyData" in s) o(18, E = s.applyData);
    if ("compareData" in s) o(19, S = s.compareData);
    if ("deleteData" in s) o(20, L = s.deleteData);
    if ("hidden" in s) o(0, O = s.hidden);
    if ("plugin" in s) o(21, D = s.plugin);
    if ("isMaintenanceMode" in s) o(1, k = s.isMaintenanceMode);
  };
  s.$$.update = () => {
    if (4268034 & s.$$.dirty[0]) {
      const s = b != N;
      o(22, N = b);
      updateTerms(u, s, k);
    }
    if (8519685 & s.$$.dirty[0]) {
      const s = w != B;
      o(23, B = w);
      if (s && T) if (!O) applySelected();
    }
    if (24580 & s.$$.dirty[0]) {
      o(3, I = "");
      o(4, A = "");
      o(5, x = "");
      o(6, R = false);
      if ("" == T) ; else if (T == g) {
        o(3, I = "This device");
        o(6, R = false);
      } else {
        const s = void 0, r = void 0;
        performCompare(u.find((s => s.term == g)), u.find((s => s.term == T)));
      }
    }
  };
  return [ O, k, T, I, A, x, R, P, F, applySelected, compareSelected, deleteSelected, duplicateItem, u, g, _, b, w, E, S, L, D, N, B, select_change_handler ];
}

var PluginCombo = class extends SvelteComponent {
  constructor(s) {
    super();
    init2(this, s, instance2, create_fragment2, safe_not_equal, {
      list: 13,
      thisTerm: 14,
      hideNotApplicable: 15,
      selectNewest: 16,
      applyAllPluse: 17,
      applyData: 18,
      compareData: 19,
      deleteData: 20,
      hidden: 0,
      plugin: 21,
      isMaintenanceMode: 1
    }, add_css2, [ -1, -1 ]);
  }
}, PluginCombo_default = PluginCombo;

function add_css3(s) {
  append_styles(s, "svelte-rs1qzz", ".labelrow.svelte-rs1qzz.svelte-rs1qzz{margin-left:0.4em;display:flex;justify-content:flex-start;align-items:center;border-top:1px solid var(--background-modifier-border);padding:4px;flex-wrap:wrap}.filerow.svelte-rs1qzz.svelte-rs1qzz{margin-left:1.25em;display:flex;justify-content:flex-start;align-items:center;padding-right:4px;flex-wrap:wrap}.filerow.hideeven.svelte-rs1qzz.svelte-rs1qzz:has(.even),.labelrow.hideeven.svelte-rs1qzz.svelte-rs1qzz:has(.even){display:none}.title.svelte-rs1qzz.svelte-rs1qzz{color:var(--text-normal);font-size:var(--font-ui-medium);line-height:var(--line-height-tight);margin-right:auto}.filetitle.svelte-rs1qzz.svelte-rs1qzz{color:var(--text-normal);font-size:var(--font-ui-medium);line-height:var(--line-height-tight);margin-right:auto}.buttons.svelte-rs1qzz.svelte-rs1qzz{display:flex;flex-direction:row;justify-content:flex-end;margin-top:8px;flex-wrap:wrap}.buttons.svelte-rs1qzz>button.svelte-rs1qzz{margin-left:4px;width:auto}label.svelte-rs1qzz.svelte-rs1qzz{display:flex;justify-content:center;align-items:center}label.svelte-rs1qzz>span.svelte-rs1qzz{margin-right:0.25em}.is-mobile .title.svelte-rs1qzz.svelte-rs1qzz,.is-mobile .filetitle.svelte-rs1qzz.svelte-rs1qzz{width:100%}.center.svelte-rs1qzz.svelte-rs1qzz{display:flex;justify-content:center;align-items:center;min-height:3em}");
}

function get_each_context3(s, r, o) {
  const u = s.slice();
  u[29] = r[o][0];
  u[30] = r[o][1];
  return u;
}

function get_each_context_12(s, r, o) {
  const u = s.slice();
  u[33] = r[o][0];
  u[34] = r[o][1];
  return u;
}

function get_each_context_2(s, r, o) {
  const u = s.slice();
  u[29] = r[o][0];
  u[30] = r[o][1];
  return u;
}

function create_if_block_23(s) {
  let r, o, u;
  return {
    c() {
      r = element("button");
      r.textContent = "Reload";
      attr(r, "class", "svelte-rs1qzz");
    },
    m(g, _) {
      insert(g, r, _);
      if (!o) {
        u = listen(r, "click", s[20]);
        o = true;
      }
    },
    p: noop,
    d(s) {
      if (s) detach(r);
      o = false;
      u();
    }
  };
}

function create_if_block_13(s) {
  let r;
  return {
    c() {
      r = element("div");
      r.innerHTML = "<span>Updating list...</span>";
    },
    m(s, o) {
      insert(s, r, o);
    },
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_else_block3(s) {
  let r, o, u, g, _, b = ensure_array_like(Object.entries(s[7])), w = [];
  for (let r = 0; r < b.length; r += 1) w[r] = create_each_block_12(get_each_context_12(s, b, r));
  const out = s => transition_out(w[s], 1, 1, (() => {
    w[s] = null;
  }));
  let E = ensure_array_like(groupBy(filterList(s[1], [ "PLUGIN_MAIN", "PLUGIN_DATA", "PLUGIN_ETC" ]), "name")), S = [];
  for (let r = 0; r < E.length; r += 1) S[r] = create_each_block3(get_each_context3(s, E, r));
  const out_1 = s => transition_out(S[s], 1, 1, (() => {
    S[s] = null;
  }));
  return {
    c() {
      for (let s = 0; s < w.length; s += 1) w[s].c();
      r = space();
      o = element("div");
      u = element("h3");
      u.textContent = "Plugins";
      g = space();
      for (let s = 0; s < S.length; s += 1) S[s].c();
    },
    m(s, b) {
      for (let r = 0; r < w.length; r += 1) if (w[r]) w[r].m(s, b);
      insert(s, r, b);
      insert(s, o, b);
      append(o, u);
      append(o, g);
      for (let s = 0; s < S.length; s += 1) if (S[s]) S[s].m(o, null);
      _ = true;
    },
    p(s, u) {
      if (150 & u[0]) {
        b = ensure_array_like(Object.entries(s[7]));
        let o;
        for (o = 0; o < b.length; o += 1) {
          const g = get_each_context_12(s, b, o);
          if (w[o]) {
            w[o].p(g, u);
            transition_in(w[o], 1);
          } else {
            w[o] = create_each_block_12(g);
            w[o].c();
            transition_in(w[o], 1);
            w[o].m(r.parentNode, r);
          }
        }
        group_outros();
        for (o = b.length; o < w.length; o += 1) out(o);
        check_outros();
      }
      if (22 & u[0]) {
        E = ensure_array_like(groupBy(filterList(s[1], [ "PLUGIN_MAIN", "PLUGIN_DATA", "PLUGIN_ETC" ]), "name"));
        let r;
        for (r = 0; r < E.length; r += 1) {
          const g = get_each_context3(s, E, r);
          if (S[r]) {
            S[r].p(g, u);
            transition_in(S[r], 1);
          } else {
            S[r] = create_each_block3(g);
            S[r].c();
            transition_in(S[r], 1);
            S[r].m(o, null);
          }
        }
        group_outros();
        for (r = E.length; r < S.length; r += 1) out_1(r);
        check_outros();
      }
    },
    i(s) {
      if (_) return;
      for (let s = 0; s < b.length; s += 1) transition_in(w[s]);
      for (let s = 0; s < E.length; s += 1) transition_in(S[s]);
      _ = true;
    },
    o(s) {
      w = w.filter(Boolean);
      for (let s = 0; s < w.length; s += 1) transition_out(w[s]);
      S = S.filter(Boolean);
      for (let s = 0; s < S.length; s += 1) transition_out(S[s]);
      _ = false;
    },
    d(s) {
      if (s) {
        detach(r);
        detach(o);
      }
      destroy_each(w, s);
      destroy_each(S, s);
    }
  };
}

function create_if_block3(s) {
  let r;
  return {
    c() {
      r = element("div");
      r.textContent = "No Items.";
      attr(r, "class", "center svelte-rs1qzz");
    },
    m(s, o) {
      insert(s, r, o);
    },
    p: noop,
    i: noop,
    o: noop,
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_each_block_2(s) {
  let r, o, u = s[29] + "", g, _, b, w, E;
  const S = [ s[4], {
    list: s[30]
  }, {
    hidden: false
  } ];
  let L = {};
  for (let s = 0; s < S.length; s += 1) L = assign(L, S[s]);
  b = new PluginCombo_default({
    props: L
  });
  return {
    c() {
      r = element("div");
      o = element("div");
      g = text(u);
      _ = space();
      create_component(b.$$.fragment);
      attr(o, "class", "title svelte-rs1qzz");
      attr(r, "class", w = "labelrow " + (s[2] ? "hideeven" : "") + " svelte-rs1qzz");
    },
    m(s, u) {
      insert(s, r, u);
      append(r, o);
      append(o, g);
      append(r, _);
      mount_component(b, r, null);
      E = true;
    },
    p(s, o) {
      if ((!E || 2 & o[0]) && u !== (u = s[29] + "")) set_data(g, u);
      const _ = 146 & o[0] ? get_spread_update(S, [ 16 & o[0] && get_spread_object(s[4]), 130 & o[0] && {
        list: s[30]
      }, S[2] ]) : {};
      b.$set(_);
      if (!E || 4 & o[0] && w !== (w = "labelrow " + (s[2] ? "hideeven" : "") + " svelte-rs1qzz")) attr(r, "class", w);
    },
    i(s) {
      if (E) return;
      transition_in(b.$$.fragment, s);
      E = true;
    },
    o(s) {
      transition_out(b.$$.fragment, s);
      E = false;
    },
    d(s) {
      if (s) detach(r);
      destroy_component(b);
    }
  };
}

function create_each_block_12(s) {
  let r, o, u, g, _ = ensure_array_like(groupBy(filterList(s[1], [ s[33] ]), "name")), b = [];
  for (let r = 0; r < _.length; r += 1) b[r] = create_each_block_2(get_each_context_2(s, _, r));
  const out = s => transition_out(b[s], 1, 1, (() => {
    b[s] = null;
  }));
  return {
    c() {
      r = element("div");
      o = element("h3");
      o.textContent = `${s[34]}`;
      u = space();
      for (let s = 0; s < b.length; s += 1) b[s].c();
    },
    m(s, _) {
      insert(s, r, _);
      append(r, o);
      append(r, u);
      for (let s = 0; s < b.length; s += 1) if (b[s]) b[s].m(r, null);
      g = true;
    },
    p(s, o) {
      if (150 & o[0]) {
        _ = ensure_array_like(groupBy(filterList(s[1], [ s[33] ]), "name"));
        let u;
        for (u = 0; u < _.length; u += 1) {
          const g = get_each_context_2(s, _, u);
          if (b[u]) {
            b[u].p(g, o);
            transition_in(b[u], 1);
          } else {
            b[u] = create_each_block_2(g);
            b[u].c();
            transition_in(b[u], 1);
            b[u].m(r, null);
          }
        }
        group_outros();
        for (u = _.length; u < b.length; u += 1) out(u);
        check_outros();
      }
    },
    i(s) {
      if (g) return;
      for (let s = 0; s < _.length; s += 1) transition_in(b[s]);
      g = true;
    },
    o(s) {
      b = b.filter(Boolean);
      for (let s = 0; s < b.length; s += 1) transition_out(b[s]);
      g = false;
    },
    d(s) {
      if (s) detach(r);
      destroy_each(b, s);
    }
  };
}

function create_each_block3(s) {
  let r, o, u = s[29] + "", g, _, b, w, E, S, L, O, D, k, C, T, I, A, x, R, P, N;
  const B = [ s[4], {
    list: s[30]
  }, {
    hidden: true
  } ];
  let F = {};
  for (let s = 0; s < B.length; s += 1) F = assign(F, B[s]);
  b = new PluginCombo_default({
    props: F
  });
  const M = [ s[4], {
    list: filterList(s[30], [ "PLUGIN_MAIN" ])
  }, {
    hidden: false
  } ];
  let V = {};
  for (let s = 0; s < M.length; s += 1) V = assign(V, M[s]);
  D = new PluginCombo_default({
    props: V
  });
  const G = [ s[4], {
    list: filterList(s[30], [ "PLUGIN_DATA" ])
  }, {
    hidden: false
  } ];
  let j = {};
  for (let s = 0; s < G.length; s += 1) j = assign(j, G[s]);
  x = new PluginCombo_default({
    props: j
  });
  return {
    c() {
      r = element("div");
      o = element("div");
      g = text(u);
      _ = space();
      create_component(b.$$.fragment);
      E = space();
      S = element("div");
      L = element("div");
      L.textContent = "Main";
      O = space();
      create_component(D.$$.fragment);
      C = space();
      T = element("div");
      I = element("div");
      I.textContent = "Data";
      A = space();
      create_component(x.$$.fragment);
      R = space();
      attr(o, "class", "title svelte-rs1qzz");
      attr(r, "class", w = "labelrow " + (s[2] ? "hideeven" : "") + " svelte-rs1qzz");
      attr(L, "class", "filetitle svelte-rs1qzz");
      attr(S, "class", k = "filerow " + (s[2] ? "hideeven" : "") + " svelte-rs1qzz");
      attr(I, "class", "filetitle svelte-rs1qzz");
      attr(T, "class", P = "filerow " + (s[2] ? "hideeven" : "") + " svelte-rs1qzz");
    },
    m(s, u) {
      insert(s, r, u);
      append(r, o);
      append(o, g);
      append(r, _);
      mount_component(b, r, null);
      insert(s, E, u);
      insert(s, S, u);
      append(S, L);
      append(S, O);
      mount_component(D, S, null);
      insert(s, C, u);
      insert(s, T, u);
      append(T, I);
      append(T, A);
      mount_component(x, T, null);
      append(T, R);
      N = true;
    },
    p(s, o) {
      if ((!N || 2 & o[0]) && u !== (u = s[29] + "")) set_data(g, u);
      const _ = 18 & o[0] ? get_spread_update(B, [ 16 & o[0] && get_spread_object(s[4]), 2 & o[0] && {
        list: s[30]
      }, B[2] ]) : {};
      b.$set(_);
      if (!N || 4 & o[0] && w !== (w = "labelrow " + (s[2] ? "hideeven" : "") + " svelte-rs1qzz")) attr(r, "class", w);
      const E = 18 & o[0] ? get_spread_update(M, [ 16 & o[0] && get_spread_object(s[4]), 2 & o[0] && {
        list: filterList(s[30], [ "PLUGIN_MAIN" ])
      }, M[2] ]) : {};
      D.$set(E);
      if (!N || 4 & o[0] && k !== (k = "filerow " + (s[2] ? "hideeven" : "") + " svelte-rs1qzz")) attr(S, "class", k);
      const L = 18 & o[0] ? get_spread_update(G, [ 16 & o[0] && get_spread_object(s[4]), 2 & o[0] && {
        list: filterList(s[30], [ "PLUGIN_DATA" ])
      }, G[2] ]) : {};
      x.$set(L);
      if (!N || 4 & o[0] && P !== (P = "filerow " + (s[2] ? "hideeven" : "") + " svelte-rs1qzz")) attr(T, "class", P);
    },
    i(s) {
      if (N) return;
      transition_in(b.$$.fragment, s);
      transition_in(D.$$.fragment, s);
      transition_in(x.$$.fragment, s);
      N = true;
    },
    o(s) {
      transition_out(b.$$.fragment, s);
      transition_out(D.$$.fragment, s);
      transition_out(x.$$.fragment, s);
      N = false;
    },
    d(s) {
      if (s) {
        detach(r);
        detach(E);
        detach(S);
        detach(C);
        detach(T);
      }
      destroy_component(b);
      destroy_component(D);
      destroy_component(x);
    }
  };
}

function create_fragment3(s) {
  let r, o, u, g, _, b, w, E, S, L, O, D, k, C, T, I, A, x, R, P, N, B, F, M, V, G, j, q, z, U, W, H, K, Q, J = s[0] && create_if_block_23(s), Y = s[3] && create_if_block_13(s);
  const X = [ create_if_block3, create_else_block3 ], Z = [];
  function select_block_type(s, r) {
    if (0 == s[1].length) return 0;
    return 1;
  }
  P = select_block_type(s, [ -1, -1 ]);
  N = Z[P] = X[P](s);
  return {
    c() {
      r = element("div");
      o = element("div");
      u = element("h1");
      u.textContent = "Customization sync";
      g = space();
      _ = element("div");
      b = element("button");
      b.textContent = "Scan changes";
      w = space();
      E = element("button");
      E.textContent = "Sync once";
      S = space();
      L = element("button");
      L.textContent = "Refresh";
      O = space();
      if (J) J.c();
      D = space();
      k = element("button");
      k.textContent = "Select All Shiny";
      C = space();
      T = element("div");
      I = element("button");
      I.textContent = "Apply All";
      A = space();
      if (Y) Y.c();
      x = space();
      R = element("div");
      N.c();
      B = space();
      F = element("div");
      M = element("label");
      V = element("span");
      V.textContent = "Hide not applicable items";
      G = element("input");
      j = space();
      q = element("div");
      z = element("label");
      U = element("span");
      U.textContent = "Maintenance mode";
      W = element("input");
      attr(b, "class", "svelte-rs1qzz");
      attr(E, "class", "svelte-rs1qzz");
      attr(L, "class", "svelte-rs1qzz");
      attr(k, "class", "svelte-rs1qzz");
      attr(_, "class", "buttons svelte-rs1qzz");
      attr(I, "class", "svelte-rs1qzz");
      attr(T, "class", "buttons svelte-rs1qzz");
      attr(R, "class", "list");
      attr(V, "class", "svelte-rs1qzz");
      attr(G, "type", "checkbox");
      attr(M, "class", "svelte-rs1qzz");
      attr(F, "class", "buttons svelte-rs1qzz");
      attr(U, "class", "svelte-rs1qzz");
      attr(W, "type", "checkbox");
      attr(z, "class", "svelte-rs1qzz");
      attr(q, "class", "buttons svelte-rs1qzz");
    },
    m(N, X) {
      insert(N, r, X);
      append(r, o);
      append(o, u);
      append(o, g);
      append(o, _);
      append(_, b);
      append(_, w);
      append(_, E);
      append(_, S);
      append(_, L);
      append(_, O);
      if (J) J.m(_, null);
      append(_, D);
      append(_, k);
      append(o, C);
      append(o, T);
      append(T, I);
      append(r, A);
      if (Y) Y.m(r, null);
      append(r, x);
      append(r, R);
      Z[P].m(R, null);
      append(r, B);
      append(r, F);
      append(F, M);
      append(M, V);
      append(M, G);
      G.checked = s[2];
      append(r, j);
      append(r, q);
      append(q, z);
      append(z, U);
      append(z, W);
      W.checked = s[0];
      H = true;
      if (!K) {
        Q = [ listen(b, "click", s[17]), listen(E, "click", s[18]), listen(L, "click", s[19]), listen(k, "click", s[21]), listen(I, "click", s[22]), listen(G, "change", s[23]), listen(W, "change", s[24]) ];
        K = true;
      }
    },
    p(s, o) {
      if (s[0]) if (J) J.p(s, o); else {
        J = create_if_block_23(s);
        J.c();
        J.m(_, D);
      } else if (J) {
        J.d(1);
        J = null;
      }
      if (s[3]) if (Y) ; else {
        Y = create_if_block_13(s);
        Y.c();
        Y.m(r, x);
      } else if (Y) {
        Y.d(1);
        Y = null;
      }
      let u = P;
      P = select_block_type(s, o);
      if (P === u) Z[P].p(s, o); else {
        group_outros();
        transition_out(Z[u], 1, 1, (() => {
          Z[u] = null;
        }));
        check_outros();
        N = Z[P];
        if (!N) {
          N = Z[P] = X[P](s);
          N.c();
        } else N.p(s, o);
        transition_in(N, 1);
        N.m(R, null);
      }
      if (4 & o[0]) G.checked = s[2];
      if (1 & o[0]) W.checked = s[0];
    },
    i(s) {
      if (H) return;
      transition_in(N);
      H = true;
    },
    o(s) {
      transition_out(N);
      H = false;
    },
    d(s) {
      if (s) detach(r);
      if (J) J.d();
      if (Y) Y.d();
      Z[P].d();
      K = false;
      run_all(Q);
    }
  };
}

function filterList(s, r) {
  const o = void 0;
  return s.filter((s => -1 !== r.indexOf(s.category))).sort(((s, r) => `${s.category}-${s.name}`.localeCompare(`${r.category}-${r.name}`)));
}

function groupBy(s, r) {
  let o = {};
  for (const u of s) {
    const s = r in u ? u[r] : "";
    o[s] = o[s] || [];
    o[s].push(u);
  }
  for (const s in o) o[s] = o[s].sort(((s, r) => `${s.category}-${s.name}`.localeCompare(`${r.category}-${r.name}`)));
  const u = void 0;
  return Object.entries(o).sort((([s], [r]) => `${s}`.localeCompare(`${r}`)));
}

function instance3(s, r, o) {
  let u, g, _, {plugin: b} = r;
  const w = b.addOnConfigSync;
  let E = [], S = 0, L = true, O = false, D = 0, k = false;
  async function requestUpdate() {
    await w.updatePluginList(true);
  }
  async function requestReload() {
    await w.reloadPluginList(true);
  }
  pluginList.subscribe((s => {
    o(1, E = s);
  }));
  pluginIsEnumerating.subscribe((s => {
    o(3, O = s);
  }));
  onMount((async () => {
    requestUpdate();
  }));
  const C = {
    CONFIG: "Configuration",
    THEME: "Themes",
    SNIPPET: "Snippets"
  };
  async function scanAgain() {
    await w.scanAllConfigFiles(true);
    await requestUpdate();
  }
  async function replicate2() {
    await b.replicate(true);
  }
  function selectAllNewest() {
    o(13, S++, S);
  }
  function applyAll() {
    o(14, D++, D);
  }
  async function applyData(s) {
    return await w.applyData(s);
  }
  async function compareData(s, r) {
    return await w.compareUsingDisplayData(s, r);
  }
  async function deleteData(s) {
    return await w.deleteData(s);
  }
  const click_handler = () => scanAgain(), click_handler_1 = () => replicate2(), click_handler_2 = () => requestUpdate(), click_handler_3 = () => requestReload(), click_handler_4 = () => selectAllNewest(), click_handler_5 = () => applyAll();
  function input0_change_handler() {
    L = this.checked;
    o(2, L);
  }
  function input1_change_handler() {
    k = this.checked;
    o(0, k);
  }
  s.$$set = s => {
    if ("plugin" in s) o(12, b = s.plugin);
  };
  s.$$.update = () => {
    if (4096 & s.$$.dirty[0]) o(16, g = b.deviceAndVaultName);
    if (126977 & s.$$.dirty[0]) o(4, _ = {
      thisTerm: g,
      hideNotApplicable: u,
      selectNewest: S,
      applyAllPluse: D,
      applyData,
      compareData,
      deleteData,
      plugin: b,
      isMaintenanceMode: k
    });
  };
  o(15, u = true);
  return [ k, E, L, O, _, requestUpdate, requestReload, C, scanAgain, replicate2, selectAllNewest, applyAll, b, S, D, u, g, click_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_4, click_handler_5, input0_change_handler, input1_change_handler ];
}

var PluginPane = class extends SvelteComponent {
  constructor(s) {
    super();
    init2(this, s, instance3, create_fragment3, safe_not_equal, {
      plugin: 12
    }, add_css3, [ -1, -1 ]);
  }
}, PluginPane_default = PluginPane, PluginDialogModal = class extends import_obsidian.Modal {
  constructor(s, r) {
    super(s);
    this.component = null;
    this.plugin = r;
  }
  isOpened() {
    return null != this.component;
  }
  onOpen() {
    const {contentEl: s} = this;
    if (null == this.component) this.component = new PluginPane_default({
      target: s,
      props: {
        plugin: this.plugin
      }
    });
  }
  onClose() {
    if (null != this.component) {
      this.component.$destroy();
      this.component = null;
    }
  }
}, InputStringDialog = class extends import_obsidian.Modal {
  constructor(s, r, o, u, g, _) {
    super(s);
    this.result = false;
    this.isManuallyClosed = false;
    this.isPassword = false;
    this.onSubmit = _;
    this.title = r;
    this.placeholder = u;
    this.key = o;
    this.isPassword = g;
  }
  onOpen() {
    const {contentEl: s} = this;
    s.createEl("h1", {
      text: this.title
    });
    const r = s.createEl("form");
    new import_obsidian.Setting(r).setName(this.key).setClass(this.isPassword ? "password-input" : "normal-input").addText((s => s.onChange((s => {
      this.result = s;
    }))));
    new import_obsidian.Setting(r).addButton((s => s.setButtonText("Ok").setCta().onClick((() => {
      this.isManuallyClosed = true;
      this.close();
    })))).addButton((s => s.setButtonText("Cancel").setCta().onClick((() => {
      this.close();
    }))));
  }
  onClose() {
    const {contentEl: s} = this;
    s.empty();
    if (this.isManuallyClosed) this.onSubmit(this.result); else this.onSubmit(false);
  }
}, PopoverSelectString = class extends import_obsidian.FuzzySuggestModal {
  constructor(s, r, o, u, g) {
    super(s);
    this.callback = () => {};
    this.getItemsFun = () => [ "yes", "no" ];
    this.app = s;
    this.setPlaceholder((null != o ? o : "y/n) ") + r);
    if (u) this.getItemsFun = u;
    this.callback = g;
  }
  getItems() {
    return this.getItemsFun();
  }
  getItemText(s) {
    return s;
  }
  onChooseItem(s, r) {
    this.callback(s);
    this.callback = null;
  }
  onClose() {
    setTimeout((() => {
      if (null != this.callback) this.callback("");
    }), 100);
  }
}, MessageBox = class extends import_obsidian.Modal {
  constructor(s, r, o, u, g, _, b) {
    super(s.app);
    this.isManuallyClosed = false;
    this.timer = void 0;
    this.plugin = s;
    this.title = r;
    this.contentMd = o;
    this.buttons = u;
    this.onSubmit = b;
    this.defaultAction = g;
    this.timeout = _;
    if (this.timeout) this.timer = setInterval((() => {
      this.timeout--;
      if (this.timeout < 0) {
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = void 0;
        }
        this.result = g;
        this.isManuallyClosed = true;
        this.close();
      } else this.defaultButtonComponent.setButtonText(`( ${this.timeout} ) ${g}`);
    }), 1e3);
  }
  onOpen() {
    const {contentEl: s} = this;
    s.addEventListener("click", (() => {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = void 0;
      }
    }));
    s.createEl("h1", {
      text: this.title
    });
    const r = s.createDiv();
    import_obsidian.MarkdownRenderer.render(this.plugin.app, this.contentMd, r, "/", this.plugin);
    const o = new import_obsidian.Setting(s);
    o.controlEl.style.flexWrap = "wrap";
    for (const s of this.buttons) o.addButton((r => {
      r.setButtonText(s).onClick((() => {
        this.isManuallyClosed = true;
        this.result = s;
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = void 0;
        }
        this.close();
      }));
      if (s == this.defaultAction) this.defaultButtonComponent = r;
      return r;
    }));
  }
  onClose() {
    const {contentEl: s} = this;
    s.empty();
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = void 0;
    }
    if (this.isManuallyClosed) this.onSubmit(this.result); else this.onSubmit(false);
  }
};

function confirmWithMessage(s, r, o, u, g, _) {
  return new Promise((b => {
    const w = void 0;
    new MessageBox(s, r, o, u, g, _, (s => b(s))).open();
  }));
}

async function path2id(s, r) {
  const o = s.split(":"), u = o.pop(), g = normalizePath(u);
  o.push(g);
  const _ = o.join(":"), b = void 0;
  return await path2id_base(_, r);
}

function id2path(s, r) {
  const o = void 0, u = id2path_base(s, r).split(":"), g = u.pop(), _ = normalizePath(g);
  u.push(_);
  const b = void 0;
  return u.join(":");
}

function getPath2(s) {
  return id2path(s._id, s);
}

function getPathWithoutPrefix(s) {
  const r = void 0;
  return stripAllPrefixes(getPath2(s));
}

function getPathFromTFile(s) {
  return s.path;
}

var tasks = {};

function scheduleTask(s, r, o, u) {
  if (u && s in tasks) return;
  cancelTask(s);
  tasks[s] = setTimeout((async () => {
    delete tasks[s];
    await o();
  }), r);
}

function cancelTask(s) {
  if (s in tasks) {
    clearTimeout(tasks[s]);
    delete tasks[s];
  }
}

function cancelAllTasks() {
  for (const s in tasks) {
    clearTimeout(tasks[s]);
    delete tasks[s];
  }
}

var intervals = {};

function cancelAllPeriodicTask() {
  for (const s in intervals) {
    clearInterval(intervals[s]);
    delete intervals[s];
  }
}

var memos = {};

function memoObject(s, r) {
  memos[s] = r;
  return memos[s];
}

async function memoIfNotExist(s, r) {
  if (!(s in memos)) {
    const o = r(), u = o instanceof Promise ? await o : o;
    memos[s] = u;
  }
  return memos[s];
}

function retrieveMemoObject(s) {
  if (s in memos) return memos[s]; else return false;
}

function disposeMemoObject(s) {
  delete memos[s];
}

function isSensibleMargeApplicable(s) {
  if (s.endsWith(".md")) return true;
  return false;
}

function isObjectMargeApplicable(s) {
  if (s.endsWith(".canvas")) return true;
  if (s.endsWith(".json")) return true;
  return false;
}

function tryParseJSON(s, r) {
  try {
    return JSON.parse(s);
  } catch (s) {
    return r;
  }
}

var MARK_OPERATOR = "", MARK_DELETED = `${MARK_OPERATOR}__DELETED`, MARK_ISARRAY = `${MARK_OPERATOR}__ARRAY`, MARK_SWAPPED = `${MARK_OPERATOR}__SWAP`;

function unorderedArrayToObject(s) {
  return s.map((s => ({
    [s.id]: s
  }))).reduce(((s, r) => ({
    ...s,
    ...r
  })), {});
}

function objectToUnorderedArray(s) {
  const r = Object.entries(s);
  if (r.some((s => {
    var r;
    return s[0] != (null == (r = s[1]) ? void 0 : r.id);
  }))) throw new Error("Item looks like not unordered array");
  return r.map((s => s[1]));
}

function generatePatchUnorderedArray(s, r) {
  if (s.every((s => "object" == typeof s && "id" in s)) && r.every((s => "object" == typeof s && "id" in s))) {
    const o = void 0, u = void 0, g = generatePatchObj(unorderedArrayToObject(s), unorderedArrayToObject(r));
    if (Object.keys(g).length > 0) return {
      [MARK_ISARRAY]: g
    }; else return {};
  }
  return {
    [MARK_SWAPPED]: r
  };
}

function generatePatchObj(s, r) {
  const o = Object.entries(s), u = new Map(o), g = {}, _ = Object.entries(r);
  for (const [s, r] of _) if (!u.has(s)) {
    g[s] = r;
    u.delete(s);
  } else {
    const o = u.get(s);
    if (typeof o != typeof r || Array.isArray(o) !== Array.isArray(r)) g[s] = {
      [MARK_SWAPPED]: r
    }; else if ("object" == typeof o && "object" == typeof r && !Array.isArray(o) && !Array.isArray(r)) {
      const u = generatePatchObj(o, r);
      if (Object.keys(u).length > 0) g[s] = u;
    } else if ("object" == typeof o && "object" == typeof r && Array.isArray(o) && Array.isArray(r)) {
      const u = generatePatchUnorderedArray(o, r);
      if (Object.keys(u).length > 0) g[s] = u;
    } else if ("object" != typeof o && "object" != typeof r) {
      if (JSON.stringify(u.get(s)) !== JSON.stringify(r)) g[s] = r;
    } else if (JSON.stringify(u.get(s)) !== JSON.stringify(r)) g[s] = {
      [MARK_SWAPPED]: r
    };
    u.delete(s);
  }
  for (const [s] of u) g[s] = MARK_DELETED;
  return g;
}

function applyPatch(s, r) {
  const o = s, u = Object.entries(r);
  for (const [s, r] of u) {
    if (r == MARK_DELETED) {
      delete o[s];
      continue;
    }
    if ("object" == typeof r) {
      if (MARK_SWAPPED in r) {
        o[s] = r[MARK_SWAPPED];
        continue;
      }
      if (MARK_ISARRAY in r) {
        if (!(s in o)) o[s] = [];
        if (!Array.isArray(o[s])) throw new Error("Patch target type is mismatched (array to something)");
        const u = void 0, g = void 0, _ = objectToUnorderedArray(applyPatch(unorderedArrayToObject(o[s]), r[MARK_ISARRAY]));
        o[s] = [ ..._ ];
      } else {
        if (!(s in o)) {
          o[s] = r;
          continue;
        }
        o[s] = applyPatch(o[s], r);
      }
    } else o[s] = r;
  }
  return o;
}

function mergeObject(s, r) {
  const o = Object.entries(r), u = {
    ...s
  };
  if (typeof s != typeof r || Array.isArray(s) !== Array.isArray(r)) return r;
  for (const [s, r] of o) if (s in u) {
    const o = u[s];
    if (typeof r != typeof o || Array.isArray(r) !== Array.isArray(o)) u[s] = r; else if ("object" == typeof r && "object" == typeof o && !Array.isArray(r) && !Array.isArray(o)) u[s] = mergeObject(r, o); else if ("object" == typeof r && "object" == typeof o && Array.isArray(r) && Array.isArray(o)) u[s] = [ ...new Set([ ...r, ...o ]) ]; else u[s] = r;
  } else u[s] = r;
  if (Array.isArray(s) && Array.isArray(r)) return Object.values(Object.entries(u).sort().reduce(((s, [r, o]) => ({
    ...s,
    [r]: o
  })), {}));
  return Object.entries(u).sort().reduce(((s, [r, o]) => ({
    ...s,
    [r]: o
  })), {});
}

function flattenObject(s, r = []) {
  if ("object" != typeof s) return [ [ r.join("."), s ] ];
  if (Array.isArray(s)) return [ [ r.join("."), JSON.stringify(s) ] ];
  const o = Object.entries(s), u = [];
  for (const [s, g] of o) {
    const o = flattenObject(g, [ ...r, s ]);
    u.push(...o);
  }
  return u;
}

function modifyFile(s, r, o) {
  if ("string" == typeof r) return app.vault.modify(s, r, o); else return app.vault.modifyBinary(s, r, o);
}

function createFile(s, r, o) {
  if ("string" == typeof r) return app.vault.create(s, r, o); else return app.vault.createBinary(s, r, o);
}

function isValidPath(s) {
  if (import_obsidian.Platform.isDesktop) {
    if ("darwin" == process.platform) return isValidFilenameInDarwin(s);
    if ("linux" == process.platform) return isValidFilenameInLinux(s);
    return isValidFilenameInWidows(s);
  }
  if (import_obsidian.Platform.isAndroidApp) return isValidFilenameInAndroid(s);
  if (import_obsidian.Platform.isIosApp) return isValidFilenameInDarwin(s);
  Logger("Could not determine platform for checking filename", LOG_LEVEL_VERBOSE);
  return isValidFilenameInWidows(s);
}

var touchedFiles = [];

function getAbstractFileByPath(s) {
  return app.vault.getAbstractFileByPath(s);
}

function touch(s) {
  const r = s instanceof import_obsidian.TFile ? s : getAbstractFileByPath(s), o = `${r.path}-${r.stat.mtime}-${r.stat.size}`;
  touchedFiles.unshift(o);
  touchedFiles = touchedFiles.slice(0, 100);
}

function recentlyTouched(s) {
  const r = `${s.path}-${s.stat.mtime}-${s.stat.size}`;
  if (-1 == touchedFiles.indexOf(r)) return false;
  return true;
}

function clearTouched() {
  touchedFiles = [];
}

function isInternalMetadata(s) {
  return s.startsWith(ICHeader);
}

function stripInternalMetadataPrefix(s) {
  return s.substring(ICHeaderLength);
}

function isChunk(s) {
  return s.startsWith(CHeader);
}

function isPluginMetadata(s) {
  return s.startsWith(PSCHeader);
}

var askYesNo = (s, r) => new Promise((o => {
  const u = void 0;
  new PopoverSelectString(s, r, null, null, (s => o(s))).open();
})), askSelectString = (s, r, o) => {
  const getItemsFun = () => o;
  return new Promise((o => {
    const u = void 0;
    new PopoverSelectString(s, r, "", getItemsFun, (s => o(s))).open();
  }));
}, askString = (s, r, o, u, g) => new Promise((_ => {
  const b = void 0;
  new InputStringDialog(s, r, o, u, g, (s => _(s))).open();
})), PeriodicProcessor = class {
  constructor(s, r) {
    this._plugin = s;
    this._process = r;
  }
  async process() {
    try {
      await this._process();
    } catch (s) {
      Logger(s);
    }
  }
  enable(s) {
    this.disable();
    if (0 == s) return;
    this._timer = window.setInterval((() => this.process().then((() => {}))), s);
    this._plugin.registerInterval(this._timer);
  }
  disable() {
    if (void 0 !== this._timer) window.clearInterval(this._timer);
    this._timer = void 0;
  }
}, _requestToCouchDB = async (s, r, o, u, g, _, b) => {
  const w = String.fromCharCode.apply(null, (new TextEncoder).encode(`${r}:${o}`)), E = void 0, S = void 0, L = void 0, O = void 0, D = {
    url: `${s}/${g}`,
    method: b || (_ ? "PUT" : "GET"),
    headers: {
      authorization: "Basic " + window.btoa(w),
      origin: u
    },
    contentType: "application/json",
    body: _ ? JSON.stringify(_) : void 0
  };
  return await (0, import_obsidian.requestUrl)(D);
}, requestToCouchDB = async (s, r, o, u, g, _, b) => {
  const w = "_node/_local/_config" + (g ? "/" + g : "");
  return await _requestToCouchDB(s, r, o, u, w, _, b);
};

async function performRebuildDB(s, r) {
  if ("localOnly" == r) await s.addOnSetup.fetchLocalWithKeepLocal();
  if ("remoteOnly" == r) await s.addOnSetup.rebuildRemote();
  if ("rebuildBothByThisDevice" == r) await s.addOnSetup.rebuildEverything();
}

var ObsidianLiveSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(s, r) {
    super(s, r);
    this.selectedScreen = "";
    this.plugin = r;
  }
  async testConnection() {
    const s = await this.plugin.replicator.connectRemoteCouchDBWithSetting(this.plugin.settings, this.plugin.isMobile, true);
    if ("string" == typeof s) {
      this.plugin.addLog(`could not connect to ${this.plugin.settings.couchDB_URI} : ${this.plugin.settings.couchDB_DBNAME} \n(${s})`, LOG_LEVEL_NOTICE);
      return;
    }
    this.plugin.addLog(`Connected to ${s.info.db_name}`, LOG_LEVEL_NOTICE);
  }
  display() {
    const {containerEl: s} = this;
    let r = this.plugin.settings.encrypt, o = this.plugin.settings.passphrase, u = this.plugin.settings.useDynamicIterationCount;
    s.empty();
    s.createEl("h2", {
      text: "Settings for Self-hosted LiveSync."
    });
    s.addClass("sls-setting");
    s.removeClass("isWizard");
    const g = s.createDiv(""), _ = {}, addScreenElement = (s, r) => {
      if (!(s in _)) _[s] = [];
      _[s].push(r);
    };
    g.addClass("sls-setting-menu");
    g.innerHTML = "\n<label class='sls-setting-label c-100 wizardHidden'><input type='radio' name='disp' value='100' class='sls-setting-tab'><div class='sls-setting-menu-btn'>💬</div></label>\n<label class='sls-setting-label c-110'><input type='radio' name='disp' value='110' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>🧙‍♂️</div></label>\n<label class='sls-setting-label c-20 wizardHidden'><input type='radio' name='disp' value='20' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>⚙️</div></label>\n<label class='sls-setting-label c-0'><input type='radio' name='disp' value='0' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>🛰️</div></label>\n<label class='sls-setting-label c-30'><input type='radio' name='disp' value='30' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>🔁</div></label>\n<label class='sls-setting-label c-60 wizardHidden'><input type='radio' name='disp' value='60' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>🔌</div></label>\n<label class='sls-setting-label c-50 wizardHidden'><input type='radio' name='disp' value='50' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>🧰</div></label>\n<label class='sls-setting-label c-70 wizardHidden'><input type='radio' name='disp' value='70' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>🎛️</div></label>\n        ";
    const b = g.querySelectorAll(".sls-setting-label"), changeDisplay = s => {
      for (const r in _) if (r == s) _[r].forEach((s => s.removeClass("setting-collapsed"))); else _[r].forEach((s => s.addClass("setting-collapsed")));
      g.querySelectorAll(".sls-setting-label").forEach((s => {
        s.removeClass("selected");
        s.querySelector("input[type=radio]").checked = false;
      }));
      g.querySelectorAll(`.sls-setting-label.c-${s}`).forEach((s => {
        s.addClass("selected");
        s.querySelector("input[type=radio]").checked = true;
      }));
      this.selectedScreen = s;
    };
    b.forEach((s => {
      const r = s.querySelector(".sls-setting-tab");
      if (!r) return;
      r.addEventListener("change", (r => {
        b.forEach((s => s.removeClass("selected")));
        changeDisplay(r.currentTarget.value);
        s.addClass("selected");
      }));
    }));
    const w = s.createDiv(), E = w.createEl("h3", {
      text: "Updates"
    }), S = w.createEl("div", {
      text: ""
    }), L = void 0, O = "### 0.19.0\n\n#### Customization sync\n\nSince `Plugin and their settings` have been broken, so I tried to fix it, not just fix it, but fix it the way it should be.\n\nNow, we have `Customization sync`.\n\nIt is a real shame that the compatibility between these features has been broken. However, this new feature is surely useful and I believe that worth getting over the pain.\nWe can use the new feature with the same configuration. Only the menu on the command palette has been changed. The dialog can be opened by `Show customization sync dialog`.\n\nI hope you will give it a try.\n\n\n#### Minors\n\n- 0.19.1 to 0.19.14 has been moved into the updates_old.md\n- 0.19.15\n  - Fixed:\n    - Now storing files after cleaning up is correct works.\n  - Improved:\n    - Cleaning the local database up got incredibly fastened.\n      Now we can clean instead of fetching again when synchronising with the remote which has been cleaned up.\n- 0.19.16\n  - Many upgrades on this release. I have tried not to let that happen, if something got corrupted, please feel free to notify me.\n  - New feature:\n    - (Beta) ignore files handling\n      We can use `.gitignore`, `.dockerignore`, and anything you like to filter the synchronising files.\n  - Fixed:\n    - Buttons on lock-detected-dialogue now can be shown in narrow-width devices.\n  - Improved:\n    - Some constant has been flattened to be evaluated.\n    - The usage of the deprecated API of obsidian has been reduced.\n    - Now the indexedDB adapter will be enabled while the importing configuration.\n  - Misc:\n  - Compiler, framework, and dependencies have been upgraded.\n  - Due to standing for these impacts (especially in esbuild and svelte,) terser has been introduced. \n    Feel free to notify your opinion to me! I do not like to obfuscate the code too.\n- 0.19.17\n  - Fixed:\n    - Now nested ignore files could be parsed correctly.\n    - The unexpected deletion of hidden files in some cases has been corrected.\n    - Hidden file change is no longer reflected on the device which has made the change itself.\n  - Behaviour changed:\n    - From this version, the file which has `:` in its name should be ignored even if on Linux devices.\n- 0.19.18\n  - Fixed:\n    - Now the empty (or deleted) file could be conflict-resolved.\n- 0.19.19\n  - Fixed:\n    - Resolving conflicted revision has become more robust.\n    - LiveSync now try to keep local changes when fetching from the rebuilt remote database.\n      Local changes now have been kept as a revision and fetched things will be new revisions.\n    - Now, all files will be restored after performing `fetch` immediately.\n\n... To continue on to `updates_old.md`.\n", D = ~~(versionNumberString2Number("0.19.19") / 1e3), k = createSpan();
    k.addClass("sls-header-button");
    k.innerHTML = "<button> OK, I read all. </button>";
    if (D > this.plugin.settings.lastReadUpdates) {
      const s = E.appendChild(k);
      s.querySelector("button").addEventListener("click", (async () => {
        this.plugin.settings.lastReadUpdates = D;
        await this.plugin.saveSettings();
        s.remove();
      }));
    }
    import_obsidian.MarkdownRenderer.render(this.plugin.app, O, S, "/", this.plugin);
    addScreenElement("100", w);
    const isAnySyncEnabled = () => {
      if (this.plugin.settings.liveSync) return true;
      if (this.plugin.settings.periodicReplication) return true;
      if (this.plugin.settings.syncOnFileOpen) return true;
      if (this.plugin.settings.syncOnSave) return true;
      if (this.plugin.settings.syncOnStart) return true;
      if (this.plugin.settings.syncAfterMerge) return true;
      if ("CONNECTED" == this.plugin.replicator.syncStatus) return true;
      if ("PAUSED" == this.plugin.replicator.syncStatus) return true;
      return false;
    };
    let C = false;
    const T = s.createDiv();
    T.createEl("h3", {
      text: "Setup wizard"
    });
    new import_obsidian.Setting(T).setName("Discard the existing configuration and set up").addButton((r => {
      r.setButtonText("Next").onClick((async () => {
        if (JSON.stringify(this.plugin.settings) != JSON.stringify(DEFAULT_SETTINGS)) {
          this.plugin.replicator.closeReplication();
          this.plugin.settings = {
            ...DEFAULT_SETTINGS
          };
          this.plugin.saveSettings();
          Logger("Configuration has been flushed, please open it again", LOG_LEVEL_NOTICE);
          this.plugin.app.setting.close();
        } else {
          s.addClass("isWizard");
          applyDisplayEnabled();
          C = true;
          changeDisplay("0");
        }
      }));
    }));
    new import_obsidian.Setting(T).setName("Do not discard the existing configuration and set up again").addButton((r => {
      r.setButtonText("Next").onClick((async () => {
        this.plugin.settings.liveSync = false;
        this.plugin.settings.periodicReplication = false;
        this.plugin.settings.syncOnSave = false;
        this.plugin.settings.syncOnStart = false;
        this.plugin.settings.syncOnFileOpen = false;
        this.plugin.settings.syncAfterMerge = false;
        this.plugin.replicator.closeReplication();
        await this.plugin.saveSettings();
        s.addClass("isWizard");
        applyDisplayEnabled();
        C = true;
        changeDisplay("0");
      }));
    }));
    const I = void 0;
    T.createEl("div", {
      text: "To set up second or subsequent device, please use  'Copy setup URI' and 'Open setup URI'"
    }).addClass("op-warn-info");
    new import_obsidian.Setting(T).setName("Copy setup URI").addButton((s => {
      s.setButtonText("Copy setup URI").onClick((() => {
        this.plugin.app.commands.executeCommandById("obsidian-livesync:livesync-copysetupuri");
      }));
    })).addButton((s => {
      s.setButtonText("Open setup URI").onClick((() => {
        this.plugin.app.commands.executeCommandById("obsidian-livesync:livesync-opensetupuri");
      }));
    }));
    addScreenElement("110", T);
    const A = s.createDiv();
    A.createEl("h3", {
      text: "Remote Database configuration"
    });
    const x = A.createEl("div", {
      text: 'These settings are kept locked while any synchronization options are enabled. Disable these options in the "Sync Settings" tab to unlock.'
    });
    x.addClass("op-warn-info");
    x.addClass("sls-hidden");
    const applyDisplayEnabled = () => {
      if (isAnySyncEnabled()) {
        R.forEach((s => {
          s.setDisabled(true).setTooltip("Could not change this while any synchronization options are enabled.");
        }));
        x.removeClass("sls-hidden");
      } else {
        R.forEach((s => {
          s.setDisabled(false).setTooltip("");
        }));
        x.addClass("sls-hidden");
      }
      if (this.plugin.settings.liveSync) {
        J.forEach((s => {
          s.setDisabled(true).setTooltip("");
        }));
        Q.forEach((s => {
          s.setDisabled(false).setTooltip("");
        }));
      } else if (this.plugin.settings.syncOnFileOpen || this.plugin.settings.syncOnSave || this.plugin.settings.syncOnStart || this.plugin.settings.periodicReplication || this.plugin.settings.syncAfterMerge) {
        J.forEach((s => {
          s.setDisabled(false).setTooltip("");
        }));
        Q.forEach((s => {
          s.setDisabled(true).setTooltip("");
        }));
      } else {
        J.forEach((s => {
          s.setDisabled(false).setTooltip("");
        }));
        Q.forEach((s => {
          s.setDisabled(false).setTooltip("");
        }));
      }
    }, R = [];
    R.push(new import_obsidian.Setting(A).setName("URI").addText((s => s.setPlaceholder("https://........").setValue(this.plugin.settings.couchDB_URI).onChange((async s => {
      this.plugin.settings.couchDB_URI = s;
      await this.plugin.saveSettings();
    })))), new import_obsidian.Setting(A).setName("Username").setDesc("username").addText((s => s.setPlaceholder("").setValue(this.plugin.settings.couchDB_USER).onChange((async s => {
      this.plugin.settings.couchDB_USER = s;
      await this.plugin.saveSettings();
    })))), new import_obsidian.Setting(A).setName("Password").setDesc("password").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.couchDB_PASSWORD).onChange((async s => {
        this.plugin.settings.couchDB_PASSWORD = s;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "password");
    })), new import_obsidian.Setting(A).setName("Database name").addText((s => s.setPlaceholder("").setValue(this.plugin.settings.couchDB_DBNAME).onChange((async s => {
      this.plugin.settings.couchDB_DBNAME = s;
      await this.plugin.saveSettings();
    })))));
    new import_obsidian.Setting(A).setName("Test Database Connection").setDesc("Open database connection. If the remote database is not found and you have the privilege to create a database, the database will be created.").addButton((s => s.setButtonText("Test").setDisabled(false).onClick((async () => {
      await this.testConnection();
    }))));
    new import_obsidian.Setting(A).setName("Check database configuration").addButton((s => s.setButtonText("Check").setDisabled(false).onClick((async () => {
      const checkConfig = async () => {
        var s, r, o, u, g, _, b, w, E, S, L;
        try {
          if (isCloudantURI(this.plugin.settings.couchDB_URI)) {
            Logger("This feature cannot be used with IBM Cloudant.", LOG_LEVEL_NOTICE);
            return;
          }
          const O = await requestToCouchDB(this.plugin.settings.couchDB_URI, this.plugin.settings.couchDB_USER, this.plugin.settings.couchDB_PASSWORD, window.origin);
          Logger(JSON.stringify(O.json, null, 2));
          const D = O.json, k = createDiv();
          k.innerHTML = "<span></span>";
          P.replaceChildren(k);
          const addResult = (s, r) => {
            const o = createDiv();
            o.addClass("ob-btn-config-fix");
            if (r) o.addClasses(r);
            o.innerHTML = `${s}`;
            P.appendChild(o);
          }, addConfigFixButton = (s, r, o) => {
            const u = createDiv();
            u.addClass("ob-btn-config-fix");
            u.innerHTML = `<label>${s}</label><button>Fix</button>`;
            const g = P.appendChild(u);
            g.querySelector("button").addEventListener("click", (async () => {
              console.dir({
                key: r,
                value: o
              });
              const u = await requestToCouchDB(this.plugin.settings.couchDB_URI, this.plugin.settings.couchDB_USER, this.plugin.settings.couchDB_PASSWORD, void 0, r, o);
              console.dir(u);
              if (200 == u.status) {
                Logger(`${s} successfully updated`, LOG_LEVEL_NOTICE);
                P.removeChild(g);
                checkConfig();
              } else {
                Logger(`${s} failed`, LOG_LEVEL_NOTICE);
                Logger(u.text);
              }
            }));
          };
          addResult("---Notice---", [ "ob-btn-config-head" ]);
          addResult("If the server configuration is not persistent (e.g., running on docker), the values set from here will also be volatile. Once you are able to connect, please reflect the settings in the server's local.ini.", [ "ob-btn-config-info" ]);
          addResult("Your configuration is dumped to Log", [ "ob-btn-config-info" ]);
          addResult("--Config check--", [ "ob-btn-config-head" ]);
          if (!(this.plugin.settings.couchDB_USER in D.admins)) addResult("⚠ You do not have administrative privileges."); else addResult("✔ You have administrative privileges.");
          if ("true" != (null == (s = null == D ? void 0 : D.chttpd) ? void 0 : s.require_valid_user)) {
            addResult("❗ chttpd.require_valid_user looks like wrong.");
            addConfigFixButton("Set chttpd.require_valid_user = true", "chttpd/require_valid_user", "true");
          } else addResult("✔ chttpd.require_valid_user is ok.");
          if ("true" != (null == (r = null == D ? void 0 : D.chttpd_auth) ? void 0 : r.require_valid_user)) {
            addResult("❗ chttpd_auth.require_valid_user looks like wrong.");
            addConfigFixButton("Set chttpd_auth.require_valid_user = true", "chttpd_auth/require_valid_user", "true");
          } else addResult("✔ chttpd_auth.require_valid_user is ok.");
          if (!(null == D ? void 0 : D.httpd["WWW-Authenticate"])) {
            addResult("❗ httpd.WWW-Authenticate is missing");
            addConfigFixButton("Set httpd.WWW-Authenticate", "httpd/WWW-Authenticate", 'Basic realm="couchdb"');
          } else addResult("✔ httpd.WWW-Authenticate is ok.");
          if ("true" != (null == (o = null == D ? void 0 : D.httpd) ? void 0 : o.enable_cors)) {
            addResult("❗ httpd.enable_cors is wrong");
            addConfigFixButton("Set httpd.enable_cors", "httpd/enable_cors", "true");
          } else addResult("✔ httpd.enable_cors is ok.");
          if (!isCloudantURI(this.plugin.settings.couchDB_URI)) {
            if (Number(null != (g = null == (u = null == D ? void 0 : D.chttpd) ? void 0 : u.max_http_request_size) ? g : 0) < 4294967296) {
              addResult("❗ chttpd.max_http_request_size is low)");
              addConfigFixButton("Set chttpd.max_http_request_size", "chttpd/max_http_request_size", "4294967296");
            } else addResult("✔ chttpd.max_http_request_size is ok.");
            if (Number(null != (b = null == (_ = null == D ? void 0 : D.couchdb) ? void 0 : _.max_document_size) ? b : 0) < 5e7) {
              addResult("❗ couchdb.max_document_size is low)");
              addConfigFixButton("Set couchdb.max_document_size", "couchdb/max_document_size", "50000000");
            } else addResult("✔ couchdb.max_document_size is ok.");
          }
          if ("true" != (null == (w = null == D ? void 0 : D.cors) ? void 0 : w.credentials)) {
            addResult("❗ cors.credentials is wrong");
            addConfigFixButton("Set cors.credentials", "cors/credentials", "true");
          } else addResult("✔ cors.credentials is ok.");
          const C = ((null != (S = null == (E = null == D ? void 0 : D.cors) ? void 0 : E.origins) ? S : "") + "").split(",");
          if ("*" == (null == (L = null == D ? void 0 : D.cors) ? void 0 : L.origins) || -1 !== C.indexOf("app://obsidian.md") && -1 !== C.indexOf("capacitor://localhost") && -1 !== C.indexOf("http://localhost")) addResult("✔ cors.origins is ok."); else {
            addResult("❗ cors.origins is wrong");
            addConfigFixButton("Set cors.origins", "cors/origins", "app://obsidian.md,capacitor://localhost,http://localhost");
          }
          addResult("--Connection check--", [ "ob-btn-config-head" ]);
          addResult(`Current origin:${window.location.origin}`);
          const T = [ "app://obsidian.md", "capacitor://localhost", "http://localhost" ];
          for (const s of T) {
            const r = await requestToCouchDB(this.plugin.settings.couchDB_URI, this.plugin.settings.couchDB_USER, this.plugin.settings.couchDB_PASSWORD, s), o = Object.entries(r.headers).map((s => {
              s[0] = (s[0] + "").toLowerCase();
              return s;
            })).reduce(((s, [r, o]) => {
              s[r] = o;
              return s;
            }), {});
            addResult(`Origin check:${s}`);
            if ("true" != o["access-control-allow-credentials"]) addResult("❗ CORS is not allowing credential"); else addResult("✔ CORS credential OK");
            if (o["access-control-allow-origin"] != s) addResult(`❗ CORS Origin is unmatched:${origin}->${o["access-control-allow-origin"]}`); else addResult("✔ CORS origin OK");
          }
          addResult("--Done--", [ "ob-btn-config-head" ]);
          addResult("If you have some trouble with Connection-check even though all Config-check has been passed, Please check your reverse proxy's configuration.", [ "ob-btn-config-info" ]);
        } catch (s) {
          Logger("Checking configuration failed", LOG_LEVEL_NOTICE);
          Logger(s);
        }
      };
      await checkConfig();
    }))));
    const P = A.createEl("div", {
      text: ""
    });
    A.createEl("h4", {
      text: "Confidentiality"
    });
    const N = new import_obsidian.Setting(A).setName("End to End Encryption").setDesc("Encrypt contents on the remote database. If you use the plugin's synchronization feature, enabling this is recommend.").addToggle((s => s.setValue(r).onChange((async s => {
      if (C) {
        this.plugin.settings.encrypt = s;
        r = s;
        await this.plugin.saveSettings();
        updateE2EControls();
      } else {
        r = s;
        updateE2EControls();
      }
    }))));
    let B = this.plugin.settings.usePathObfuscation;
    const updateE2EControls = () => {
      N.controlEl.toggleClass("sls-item-dirty", r != this.plugin.settings.encrypt);
      if (r) {
        F.settingEl.removeClass("sls-setting-hidden");
        V.settingEl.removeClass("sls-setting-hidden");
        M.settingEl.removeClass("sls-setting-hidden");
        null == F || F.controlEl.toggleClass("sls-item-dirty", o != this.plugin.settings.passphrase);
        null == V || V.controlEl.toggleClass("sls-item-dirty", u != this.plugin.settings.useDynamicIterationCount);
        null == M || M.controlEl.toggleClass("sls-item-dirty", B != this.plugin.settings.usePathObfuscation);
        if (r != this.plugin.settings.encrypt || o != this.plugin.settings.passphrase || u != this.plugin.settings.useDynamicIterationCount || B != this.plugin.settings.usePathObfuscation) G.settingEl.removeClass("sls-setting-hidden"); else G.settingEl.addClass("sls-setting-hidden");
      } else {
        F.settingEl.addClass("sls-setting-hidden");
        V.settingEl.addClass("sls-setting-hidden");
        M.settingEl.addClass("sls-setting-hidden");
        G.settingEl.addClass("sls-setting-hidden");
      }
    }, F = new import_obsidian.Setting(A).setName("Passphrase").setDesc("Encrypting passphrase. If you change the passphrase of a existing database, overwriting the remote database is strongly recommended.").addText((s => {
      s.setPlaceholder("").setValue(o).onChange((async s => {
        if (C) {
          this.plugin.settings.passphrase = s;
          await this.plugin.saveSettings();
        } else {
          o = s;
          await this.plugin.saveSettings();
          updateE2EControls();
        }
      }));
      s.inputEl.setAttribute("type", "password");
    })), M = new import_obsidian.Setting(A).setName("Path Obfuscation").setDesc("Obfuscate paths of files. If we configured, we should rebuild the database.").addToggle((s => s.setValue(B).onChange((async s => {
      if (C) {
        this.plugin.settings.usePathObfuscation = s;
        await this.plugin.saveSettings();
      } else {
        B = s;
        await this.plugin.saveSettings();
        updateE2EControls();
      }
    })))), V = new import_obsidian.Setting(A).setName("Use dynamic iteration count (experimental)").setDesc("Balancing the encryption/decryption load against the length of the passphrase if toggled.").addToggle((s => {
      s.setValue(u).onChange((async s => {
        if (C) {
          this.plugin.settings.useDynamicIterationCount = s;
          await this.plugin.saveSettings();
        } else {
          u = s;
          await this.plugin.saveSettings();
          updateE2EControls();
        }
      }));
    })).setClass("wizardHidden"), G = new import_obsidian.Setting(A).setName("Apply").setDesc("Apply encryption settings").setClass("wizardHidden").addButton((s => s.setButtonText("Just apply").setWarning().setDisabled(false).onClick((async () => {
      await applyEncryption(false);
    })))).addButton((s => s.setButtonText("Apply and Fetch").setWarning().setDisabled(false).onClick((async () => {
      await rebuildDB("localOnly");
    })))).addButton((s => s.setButtonText("Apply and Rebuild").setWarning().setDisabled(false).onClick((async () => {
      await rebuildDB("rebuildBothByThisDevice");
    }))));
    updateE2EControls();
    const checkWorkingPassphrase = async () => {
      const s = {
        ...this.plugin.settings,
        encrypt: r,
        passphrase: o,
        useDynamicIterationCount: u
      };
      console.dir(s);
      const g = await this.plugin.replicator.connectRemoteCouchDBWithSetting(s, this.plugin.isMobile, true);
      if ("string" == typeof g) {
        Logger("Could not connect to the database.", LOG_LEVEL_NOTICE);
        return false;
      } else if (await checkSyncInfo(g.db)) return true; else {
        Logger("Failed to read remote database", LOG_LEVEL_NOTICE);
        return false;
      }
    }, applyEncryption = async s => {
      if (r && "" == o) {
        Logger("If you enable encryption, you have to set the passphrase", LOG_LEVEL_NOTICE);
        return;
      }
      if (r && !await testCrypt()) {
        Logger("WARNING! Your device would not support encryption.", LOG_LEVEL_NOTICE);
        return;
      }
      if (!await checkWorkingPassphrase() && !s) return;
      if (!r) o = "";
      this.plugin.addOnSetup.suspendAllSync();
      this.plugin.addOnSetup.suspendExtraSync();
      this.plugin.settings.encrypt = r;
      this.plugin.settings.passphrase = o;
      this.plugin.settings.useDynamicIterationCount = u;
      this.plugin.settings.usePathObfuscation = B;
      await this.plugin.saveSettings();
      updateE2EControls();
      if (s) await this.plugin.addOnSetup.rebuildRemote(); else {
        await this.plugin.markRemoteResolved();
        await this.plugin.replicate(true);
      }
    }, rebuildDB = async s => {
      if (r && "" == o) {
        Logger("If you enable encryption, you have to set the passphrase", LOG_LEVEL_NOTICE);
        return;
      }
      if (r && !await testCrypt()) {
        Logger("WARNING! Your device would not support encryption.", LOG_LEVEL_NOTICE);
        return;
      }
      if (!r) o = "";
      this.plugin.addOnSetup.suspendAllSync();
      this.plugin.addOnSetup.suspendExtraSync();
      this.plugin.settings.encrypt = r;
      this.plugin.settings.passphrase = o;
      this.plugin.settings.useDynamicIterationCount = u;
      this.plugin.settings.usePathObfuscation = B;
      Logger("All synchronization have been temporarily disabled. Please enable them after the fetching, if you need them.", LOG_LEVEL_NOTICE);
      await this.plugin.saveSettings();
      updateE2EControls();
      applyDisplayEnabled();
      this.plugin.app.setting.close();
      await delay(2e3);
      await performRebuildDB(this.plugin, s);
    };
    let j = false;
    new import_obsidian.Setting(A).setName("").setClass("wizardOnly").addButton((s => s.setButtonText("Next").setClass("mod-cta").setDisabled(false).onClick((() => {
      if (!this.plugin.settings.encrypt) this.plugin.settings.passphrase = "";
      if (isCloudantURI(this.plugin.settings.couchDB_URI)) this.plugin.settings.customChunkSize = 0; else this.plugin.settings.customChunkSize = 100;
      j = false;
      changeDisplay("30");
    }))));
    new import_obsidian.Setting(A).setName("").setClass("wizardOnly").addButton((s => s.setButtonText("Discard existing database and proceed").setDisabled(false).setWarning().onClick((() => {
      if (!this.plugin.settings.encrypt) this.plugin.settings.passphrase = "";
      if (isCloudantURI(this.plugin.settings.couchDB_URI)) this.plugin.settings.customChunkSize = 0; else this.plugin.settings.customChunkSize = 100;
      j = true;
      changeDisplay("30");
    }))));
    addScreenElement("0", A);
    const q = s.createDiv();
    q.createEl("h3", {
      text: "General Settings"
    });
    q.createEl("h4", {
      text: "Appearance"
    });
    new import_obsidian.Setting(q).setName("Show status inside the editor").setDesc("").addToggle((s => s.setValue(this.plugin.settings.showStatusOnEditor).onChange((async s => {
      this.plugin.settings.showStatusOnEditor = s;
      await this.plugin.saveSettings();
    }))));
    q.createEl("h4", {
      text: "Logging"
    });
    new import_obsidian.Setting(q).setName("Show only notifications").setDesc("Prevent logging and show only notification").addToggle((s => s.setValue(this.plugin.settings.lessInformationInLog).onChange((async s => {
      this.plugin.settings.lessInformationInLog = s;
      await this.plugin.saveSettings();
      this.display();
    }))));
    if (!this.plugin.settings.lessInformationInLog) new import_obsidian.Setting(q).setName("Verbose Log").setDesc("Show verbose log").addToggle((s => s.setValue(this.plugin.settings.showVerboseLog).onChange((async s => {
      this.plugin.settings.showVerboseLog = s;
      await this.plugin.saveSettings();
    }))));
    q.createEl("h4", {
      text: "Performance tweaks"
    });
    new import_obsidian.Setting(q).setName("Memory cache size (by total items)").setDesc("").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.hashCacheMaxCount + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r) || r < 10) r = 10;
        this.plugin.settings.hashCacheMaxCount = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    new import_obsidian.Setting(q).setName("Memory cache size (by total characters)").setDesc("(Mega chars)").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.hashCacheMaxAmount + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r) || r < 1) r = 1;
        this.plugin.settings.hashCacheMaxAmount = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    q.createEl("h4", {
      text: "Advanced Confidentiality"
    });
    const z = {
      "": "Default",
      LOCALSTORAGE: "Use a custom passphrase",
      ASK_AT_LAUNCH: "Ask an passphrase at every launch"
    };
    new import_obsidian.Setting(q).setName("Encrypting sensitive configuration items").addDropdown((s => s.addOptions(z).setValue(this.plugin.settings.configPassphraseStore).onChange((async s => {
      this.plugin.settings.configPassphraseStore = s;
      this.plugin.usedPassphrase = "";
      W.setDisabled("LOCALSTORAGE" != this.plugin.settings.configPassphraseStore);
      await this.plugin.saveSettings();
    })))).setClass("wizardHidden");
    const U = localStorage.getItem("ls-setting-passphrase") || "", W = new import_obsidian.Setting(q).setName("Passphrase of sensitive configuration items").setDesc("This passphrase will not be copied to another device. It will be set to `Default` until you configure it again.").addText((s => {
      s.setPlaceholder("").setValue(U).onChange((async s => {
        this.plugin.usedPassphrase = "";
        localStorage.setItem("ls-setting-passphrase", s);
        await this.plugin.saveSettings();
        updateE2EControls();
      }));
      s.inputEl.setAttribute("type", "password");
    })).setClass("wizardHidden");
    W.setDisabled("LOCALSTORAGE" != this.plugin.settings.configPassphraseStore);
    addScreenElement("20", q);
    const H = s.createDiv();
    H.createEl("h3", {
      text: "Sync Settings"
    });
    if ("" != this.plugin.settings.versionUpFlash) {
      const s = H.createEl("div", {
        text: this.plugin.settings.versionUpFlash
      });
      s.createEl("button", {
        text: "I got it and updated."
      }, (r => {
        r.addClass("mod-cta");
        r.addEventListener("click", (async () => {
          this.plugin.settings.versionUpFlash = "";
          await this.plugin.saveSettings();
          applyDisplayEnabled();
          s.remove();
        }));
      }));
      s.addClass("op-warn");
    }
    let K = "NONE";
    H.createEl("div", {
      text: "Please select any preset to complete wizard."
    }).addClasses([ "op-warn-info", "wizardOnly" ]);
    new import_obsidian.Setting(H).setName("Presets").setDesc("Apply preset configuration").addDropdown((s => s.addOptions({
      NONE: "",
      LIVESYNC: "LiveSync",
      PERIODIC: "Periodic w/ batch",
      DISABLE: "Disable all automatic"
    }).setValue(K).onChange((s => K = s)))).addButton((s => s.setButtonText("Apply").setDisabled(false).setCta().onClick((async () => {
      if ("" == K) {
        Logger("Select any preset.", LOG_LEVEL_NOTICE);
        return;
      }
      const s = {
        batchSave: false,
        liveSync: false,
        periodicReplication: false,
        syncOnSave: false,
        syncOnStart: false,
        syncOnFileOpen: false,
        syncAfterMerge: false
      }, r = {
        ...s,
        liveSync: true
      }, o = {
        ...s,
        batchSave: true,
        periodicReplication: true,
        syncOnSave: false,
        syncOnStart: true,
        syncOnFileOpen: true,
        syncAfterMerge: true
      };
      if ("LIVESYNC" == K) {
        this.plugin.settings = {
          ...this.plugin.settings,
          ...r
        };
        Logger("Synchronization setting configured as LiveSync.", LOG_LEVEL_NOTICE);
      } else if ("PERIODIC" == K) {
        this.plugin.settings = {
          ...this.plugin.settings,
          ...o
        };
        Logger("Synchronization setting configured as Periodic sync with batch database update.", LOG_LEVEL_NOTICE);
      } else {
        Logger("All synchronization disabled.", LOG_LEVEL_NOTICE);
        this.plugin.settings = {
          ...this.plugin.settings,
          ...s
        };
      }
      this.plugin.saveSettings();
      this.display();
      await this.plugin.realizeSettingSyncMode();
      if (C) {
        this.plugin.app.setting.close();
        await this.plugin.resetLocalDatabase();
        await this.plugin.initializeDatabase(true);
        if (j) {
          await this.plugin.markRemoteLocked();
          await this.plugin.tryResetRemoteDatabase();
          await this.plugin.markRemoteLocked();
          await this.plugin.markRemoteResolved();
        }
        await this.plugin.replicate(true);
        Logger("All done! Please set up subsequent devices with 'Copy setup URI' and 'Open setup URI'.", LOG_LEVEL_NOTICE);
        this.plugin.app.commands.executeCommandById("obsidian-livesync:livesync-copysetupuri");
      }
    }))));
    H.createEl("h4", {
      text: "Synchronization Methods"
    }).addClass("wizardHidden");
    const Q = [], J = [];
    let Y = "";
    if (this.plugin.settings.liveSync) Y = "LIVESYNC"; else if (this.plugin.settings.periodicReplication) Y = "PERIODIC";
    new import_obsidian.Setting(H).setName("Sync Mode").setClass("wizardHidden").addDropdown((s => s.addOptions({
      "": "On events",
      PERIODIC: "Periodic and On events",
      LIVESYNC: "LiveSync"
    }).setValue(Y).onChange((async s => {
      this.plugin.settings.liveSync = false;
      this.plugin.settings.periodicReplication = false;
      if ("LIVESYNC" == s) this.plugin.settings.liveSync = true; else if ("PERIODIC" == s) this.plugin.settings.periodicReplication = true;
      await this.plugin.saveSettings();
      applyDisplayEnabled();
      await this.plugin.realizeSettingSyncMode();
      this.display();
    }))));
    if (!this.plugin.settings.liveSync) {
      if (this.plugin.settings.periodicReplication) new import_obsidian.Setting(H).setName("Periodic Sync interval").setDesc("Interval (sec)").setClass("wizardHidden").addText((s => {
        s.setPlaceholder("").setValue(this.plugin.settings.periodicReplicationInterval + "").onChange((async s => {
          let r = Number(s);
          if (isNaN(r) || r > 5e3) r = 0;
          this.plugin.settings.periodicReplicationInterval = r;
          await this.plugin.saveSettings();
          applyDisplayEnabled();
        }));
        s.inputEl.setAttribute("type", "number");
      }));
      new import_obsidian.Setting(H).setName("Sync on Save").setDesc("When you save file, sync automatically").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.syncOnSave).onChange((async s => {
        this.plugin.settings.syncOnSave = s;
        await this.plugin.saveSettings();
        applyDisplayEnabled();
      }))));
      new import_obsidian.Setting(H).setName("Sync on File Open").setDesc("When you open file, sync automatically").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.syncOnFileOpen).onChange((async s => {
        this.plugin.settings.syncOnFileOpen = s;
        await this.plugin.saveSettings();
        applyDisplayEnabled();
      }))));
      new import_obsidian.Setting(H).setName("Sync on Start").setDesc("Start synchronization after launching Obsidian.").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.syncOnStart).onChange((async s => {
        this.plugin.settings.syncOnStart = s;
        await this.plugin.saveSettings();
        applyDisplayEnabled();
      }))));
      new import_obsidian.Setting(H).setName("Sync after merging file").setDesc("Sync automatically after merging files").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.syncAfterMerge).onChange((async s => {
        this.plugin.settings.syncAfterMerge = s;
        await this.plugin.saveSettings();
        applyDisplayEnabled();
      }))));
    }
    H.createEl("h4", {
      text: "Deletions propagation"
    }).addClass("wizardHidden");
    new import_obsidian.Setting(H).setName("Use the trash bin").setDesc("Do not delete files that are deleted in remote, just move to trash.").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.trashInsteadDelete).onChange((async s => {
      this.plugin.settings.trashInsteadDelete = s;
      await this.plugin.saveSettings();
    }))));
    new import_obsidian.Setting(H).setName("Keep empty folder").setDesc("Normally, a folder is deleted when it becomes empty after a synchronization. Enabling this will prevent it from getting deleted").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.doNotDeleteFolder).onChange((async s => {
      this.plugin.settings.doNotDeleteFolder = s;
      await this.plugin.saveSettings();
    }))));
    H.createEl("h4", {
      text: "Conflict resolution"
    }).addClass("wizardHidden");
    new import_obsidian.Setting(H).setName("Always overwrite with a newer file (beta)").setDesc("(Def off) Resolve conflicts by newer files automatically.").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.resolveConflictsByNewerFile).onChange((async s => {
      this.plugin.settings.resolveConflictsByNewerFile = s;
      await this.plugin.saveSettings();
    }))));
    new import_obsidian.Setting(H).setName("Postpone resolution of unopened files").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.checkConflictOnlyOnOpen).onChange((async s => {
      this.plugin.settings.checkConflictOnlyOnOpen = s;
      await this.plugin.saveSettings();
    }))));
    H.createEl("h4", {
      text: "Compatibility"
    }).addClass("wizardHidden");
    new import_obsidian.Setting(H).setName("Always resolve conflict manually").setDesc("If this switch is turned on, a merge dialog will be displayed, even if the sensible-merge is possible automatically. (Turn on to previous behavior)").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.disableMarkdownAutoMerge).onChange((async s => {
      this.plugin.settings.disableMarkdownAutoMerge = s;
      await this.plugin.saveSettings();
    }))));
    new import_obsidian.Setting(H).setName("Always reflect synchronized changes even if the note has a conflict").setDesc("Turn on to previous behavior").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.writeDocumentsIfConflicted).onChange((async s => {
      this.plugin.settings.writeDocumentsIfConflicted = s;
      await this.plugin.saveSettings();
    }))));
    H.createEl("h4", {
      text: "Hidden files"
    }).addClass("wizardHidden");
    const X = "🔁 : Enabled", Z = "⏹️ : Disabled", ee = void 0, te = void 0, ne = void 0;
    new import_obsidian.Setting(H).setName("Hidden file synchronization").setClass("wizardHidden").settingEl.createDiv("").innerText = this.plugin.settings.syncInternalFiles ? X : Z;
    if (this.plugin.settings.syncInternalFiles) new import_obsidian.Setting(H).setName("Disable Hidden files sync").setClass("wizardHidden").addButton((s => {
      s.setButtonText("Disable").onClick((async () => {
        this.plugin.settings.syncInternalFiles = false;
        await this.plugin.saveSettings();
        this.display();
      }));
    })); else new import_obsidian.Setting(H).setName("Enable Hidden files sync").setClass("wizardHidden").addButton((s => {
      s.setButtonText("Merge").onClick((async () => {
        this.plugin.app.setting.close();
        await this.plugin.addOnSetup.configureHiddenFileSync("MERGE");
      }));
    })).addButton((s => {
      s.setButtonText("Fetch").onClick((async () => {
        this.plugin.app.setting.close();
        await this.plugin.addOnSetup.configureHiddenFileSync("FETCH");
      }));
    })).addButton((s => {
      s.setButtonText("Overwrite").onClick((async () => {
        this.plugin.app.setting.close();
        await this.plugin.addOnSetup.configureHiddenFileSync("OVERWRITE");
      }));
    }));
    new import_obsidian.Setting(H).setName("Scan for hidden files before replication").setDesc("This configuration will be ignored if monitoring changes is enabled.").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.syncInternalFilesBeforeReplication).onChange((async s => {
      this.plugin.settings.syncInternalFilesBeforeReplication = s;
      await this.plugin.saveSettings();
    }))));
    new import_obsidian.Setting(H).setName("Scan hidden files periodically").setDesc("Seconds, 0 to disable. This configuration will be ignored if monitoring changes is enabled.").setClass("wizardHidden").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.syncInternalFilesInterval + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r) || r < 10) r = 10;
        this.plugin.settings.syncInternalFilesInterval = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    let ie = null;
    const se = "\\/node_modules\\/, \\/\\.git\\/, \\/obsidian-livesync\\/", re = se + ",\\/workspace$ ,\\/workspace.json$";
    new import_obsidian.Setting(H).setName("Skip patterns").setDesc("Regular expression, If you use hidden file sync between desktop and mobile, adding `workspace$` is recommended.").setClass("wizardHidden").addTextArea((s => {
      s.setValue(this.plugin.settings.syncInternalFilesIgnorePatterns).setPlaceholder("\\/node_modules\\/, \\/\\.git\\/").onChange((async s => {
        this.plugin.settings.syncInternalFilesIgnorePatterns = s;
        await this.plugin.saveSettings();
      }));
      ie = s;
      return s;
    }));
    new import_obsidian.Setting(H).setName("Restore the skip pattern to default").setClass("wizardHidden").addButton((s => {
      s.setButtonText("Default").onClick((async () => {
        ie.setValue(se);
        this.plugin.settings.syncInternalFilesIgnorePatterns = se;
        await this.plugin.saveSettings();
      }));
    })).addButton((s => {
      s.setButtonText("Cross-platform").onClick((async () => {
        ie.setValue(re);
        this.plugin.settings.syncInternalFilesIgnorePatterns = re;
        await this.plugin.saveSettings();
      }));
    }));
    H.createEl("h4", {
      text: "Performance tweaks"
    }).addClass("wizardHidden");
    new import_obsidian.Setting(H).setName("Batch database update").setDesc("Reducing the frequency with which on-disk changes are reflected into the DB").setClass("wizardHidden").addToggle((s => s.setValue(this.plugin.settings.batchSave).onChange((async s => {
      this.plugin.settings.batchSave = s;
      await this.plugin.saveSettings();
    }))));
    new import_obsidian.Setting(H).setName("Enhance chunk size").setDesc("Enhance chunk size for binary files (0.1MBytes). This cannot be increased when using IBM Cloudant.").setClass("wizardHidden").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.customChunkSize + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r) || r < 1) r = 1;
        this.plugin.settings.customChunkSize = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    new import_obsidian.Setting(H).setName("Fetch chunks on demand").setDesc("(ex. Read chunks online) If this option is enabled, LiveSync reads chunks online directly instead of replicating them locally. Increasing Custom chunk size is recommended.").setClass("wizardHidden").addToggle((s => {
      s.setValue(this.plugin.settings.readChunksOnline).onChange((async s => {
        this.plugin.settings.readChunksOnline = s;
        await this.plugin.saveSettings();
      }));
      return s;
    }));
    H.createEl("h4", {
      text: (0, import_obsidian.sanitizeHTMLToDom)("Synchronization target filters")
    }).addClass("wizardHidden");
    new import_obsidian.Setting(H).setName("Regular expression to ignore files").setDesc("If this is set, any changes to local and remote files that match this will be skipped.").setClass("wizardHidden").addTextArea((s => {
      s.setValue(this.plugin.settings.syncIgnoreRegEx).setPlaceholder("\\.pdf$").onChange((async s => {
        let r = false;
        try {
          new RegExp(s);
          r = true;
        } catch (s) {}
        if (r || "" == s.trim()) {
          this.plugin.settings.syncIgnoreRegEx = s;
          await this.plugin.saveSettings();
        }
      }));
      return s;
    }));
    new import_obsidian.Setting(H).setName("Regular expression for restricting synchronization targets").setDesc("If this is set, changes to local and remote files that only match this will be processed.").setClass("wizardHidden").addTextArea((s => {
      s.setValue(this.plugin.settings.syncOnlyRegEx).setPlaceholder("\\.md$|\\.txt").onChange((async s => {
        let r = false;
        try {
          new RegExp(s);
          r = true;
        } catch (s) {}
        if (r || "" == s.trim()) {
          this.plugin.settings.syncOnlyRegEx = s;
          await this.plugin.saveSettings();
        }
      }));
      return s;
    }));
    new import_obsidian.Setting(H).setName("(Beta) Use ignore files").setDesc("If this is set, changes to local files which are matched by the ignore files will be skipped. Remote changes are determined using local ignore files.").setClass("wizardHidden").addToggle((s => {
      s.setValue(this.plugin.settings.useIgnoreFiles).onChange((async s => {
        this.plugin.settings.useIgnoreFiles = s;
        await this.plugin.saveSettings();
        this.display();
      }));
      return s;
    }));
    if (this.plugin.settings.useIgnoreFiles) new import_obsidian.Setting(H).setName("Ignore files").setDesc("We can use multiple ignore files, e.g.) `.gitignore, .dockerignore`").setClass("wizardHidden").addTextArea((s => {
      s.setValue(this.plugin.settings.ignoreFiles).setPlaceholder(".gitignore, .dockerignore").onChange((async s => {
        this.plugin.settings.ignoreFiles = s;
        await this.plugin.saveSettings();
      }));
      return s;
    }));
    H.createEl("h4", {
      text: (0, import_obsidian.sanitizeHTMLToDom)("Advanced settings")
    }).addClass("wizardHidden");
    H.createEl("div", {
      text: "If you reached the payload size limit when using IBM Cloudant, please decrease batch size and batch limit to a lower value."
    }).addClass("wizardHidden");
    new import_obsidian.Setting(H).setName("Batch size").setDesc("Number of change feed items to process at a time. Defaults to 50.").setClass("wizardHidden").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.batch_size + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r) || r < 10) r = 10;
        this.plugin.settings.batch_size = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    new import_obsidian.Setting(H).setName("Batch limit").setDesc("Number of batches to process at a time. Defaults to 40. This along with batch size controls how many docs are kept in memory at a time.").setClass("wizardHidden").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.batches_limit + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r) || r < 10) r = 10;
        this.plugin.settings.batches_limit = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    new import_obsidian.Setting(H).setName("Use timeouts instead of heartbeats").setDesc("If this option is enabled, PouchDB will hold the connection open for 60 seconds, and if no change arrives in that time, close and reopen the socket, instead of holding it open indefinitely. Useful when a proxy limits request duration but can increase resource usage.").setClass("wizardHidden").addToggle((s => {
      s.setValue(this.plugin.settings.useTimeouts).onChange((async s => {
        this.plugin.settings.useTimeouts = s;
        await this.plugin.saveSettings();
      }));
      return s;
    }));
    new import_obsidian.Setting(H).setName("Batch size of on-demand fetching").setDesc("").setClass("wizardHidden").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.concurrencyOfReadChunksOnline + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r) || r < 10) r = 10;
        this.plugin.settings.concurrencyOfReadChunksOnline = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    new import_obsidian.Setting(H).setName("The delay for consecutive on-demand fetches").setDesc("").setClass("wizardHidden").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.minimumIntervalOfReadChunksOnline + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r) || r < 10) r = 10;
        this.plugin.settings.minimumIntervalOfReadChunksOnline = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    addScreenElement("30", H);
    const ae = s.createDiv();
    ae.createEl("h3", {
      text: "Hatch"
    });
    new import_obsidian.Setting(ae).setName("Make report to inform the issue").addButton((s => s.setButtonText("Make report").setDisabled(false).onClick((async () => {
      let s = {};
      const r = "𝑅𝐸𝐷𝐴𝐶𝑇𝐸𝐷";
      try {
        const o = await requestToCouchDB(this.plugin.settings.couchDB_URI, this.plugin.settings.couchDB_USER, this.plugin.settings.couchDB_PASSWORD, window.origin);
        Logger(JSON.stringify(o.json, null, 2));
        s = o.json;
        s["couch_httpd_auth"].secret = r;
        s["couch_httpd_auth"].authentication_db = r;
        s["couch_httpd_auth"].authentication_redirect = r;
        s["couchdb"].uuid = r;
        s["admins"] = r;
      } catch (r) {
        s = "Requesting information to the remote CouchDB has been failed. If you are using IBM Cloudant, it is the normal behaviour.";
      }
      const o = JSON.parse(JSON.stringify(this.plugin.settings));
      o.couchDB_DBNAME = r;
      o.couchDB_PASSWORD = r;
      o.couchDB_URI = isCloudantURI(o.couchDB_URI) ? "cloudant" : "self-hosted";
      o.couchDB_USER = r;
      o.passphrase = r;
      o.encryptedPassphrase = r;
      o.encryptedCouchDBConnection = r;
      const u = `----remote config----\n${(0, import_obsidian.stringifyYaml)(s)}\n---- Plug-in config ---\n${(0, 
      import_obsidian.stringifyYaml)(o)}`;
      console.log(u);
      await navigator.clipboard.writeText(u);
      Logger("Information has been copied to clipboard", LOG_LEVEL_NOTICE);
    }))));
    if (this.plugin.replicator.remoteLockedAndDeviceNotAccepted) {
      const s = ae.createEl("div", {
        text: "To prevent unwanted vault corruption, the remote database has been locked for synchronization, and this device was not marked as 'resolved'. it caused by some operations like this. re-initialized. Local database initialization should be required. please back your vault up, reset local database, and press 'Mark this device as resolved'. "
      });
      s.createEl("button", {
        text: "I'm ready, mark this device 'resolved'"
      }, (r => {
        r.addClass("mod-warning");
        r.addEventListener("click", (async () => {
          await this.plugin.markRemoteResolved();
          s.remove();
        }));
      }));
      s.addClass("op-warn");
    } else if (this.plugin.replicator.remoteLocked) {
      const s = ae.createEl("div", {
        text: "To prevent unwanted vault corruption, the remote database has been locked for synchronization. (This device is marked 'resolved') When all your devices are marked 'resolved', unlock the database."
      });
      s.createEl("button", {
        text: "I'm ready, unlock the database"
      }, (r => {
        r.addClass("mod-warning");
        r.addEventListener("click", (async () => {
          await this.plugin.markRemoteUnlocked();
          s.remove();
        }));
      }));
      s.addClass("op-warn");
    }
    const oe = void 0;
    ae.createEl("div", {
      text: "To stop the boot up sequence for fixing problems on databases, you can put redflag.md on top of your vault (Rebooting obsidian is required)."
    }).addClass("op-warn-info");
    new import_obsidian.Setting(ae).setName("Verify and repair all files").setDesc("Verify and repair all files and update database without restoring").addButton((s => s.setButtonText("Verify and repair").setDisabled(false).setWarning().onClick((async () => {
      const s = Semaphore(10), r = this.app.vault.getFiles();
      let o = 0;
      const u = r.map((u => (async u => {
        const g = await s.acquire(1, "verifyAndRepair");
        try {
          Logger(`UPDATE DATABASE ${u.path}`);
          await this.plugin.updateIntoDB(u, false, null, true);
          o++;
          Logger(`${o}/${r.length}\n${u.path}`, LOG_LEVEL_NOTICE, "verify");
        } catch (s) {
          o++;
          Logger("Error while verifyAndRepair", LOG_LEVEL_NOTICE);
          Logger(s);
        } finally {
          g();
        }
      })(u)));
      await Promise.all(u);
      Logger("done", LOG_LEVEL_NOTICE, "verify");
    }))));
    new import_obsidian.Setting(ae).setName("Check and convert non-path-obfuscated files").setDesc("").addButton((s => s.setButtonText("Perform").setDisabled(false).setWarning().onClick((async () => {
      var s, r, o;
      for await (const u of this.plugin.localDatabase.findAllDocNames()) if (!u.startsWith("f:")) {
        const g = await this.plugin.path2id(u), _ = await this.plugin.localDatabase.getRaw(u);
        if (!_) continue;
        if ("newnote" != _.type && "plain" != _.type) continue;
        if (null != (s = null == _ ? void 0 : _.deleted) ? s : false) continue;
        const b = {
          ..._
        };
        b._id = g;
        b.path = u;
        delete b._rev;
        try {
          const s = await this.plugin.localDatabase.getRaw(g, {
            revs_info: true
          });
          null == (r = s._revs_info) || r.shift();
          const w = null == (o = s._revs_info) ? void 0 : o.shift();
          if (w) b._rev = w.rev; else b._rev = "1-" + `00000000000000000000000000000000${~~(1e9 * Math.random())}${~~(1e9 * Math.random())}${~~(1e9 * Math.random())}${~~(1e9 * Math.random())}`.slice(-32);
          const E = await this.plugin.localDatabase.putRaw(b, {
            force: true
          });
          if (E.ok) {
            Logger(`${u} has been converted as conflicted document`, LOG_LEVEL_NOTICE);
            _._deleted = true;
            if ((await this.plugin.localDatabase.putRaw(_)).ok) Logger(`Old ${u} has been deleted`, LOG_LEVEL_NOTICE);
            await this.plugin.showIfConflicted(u);
          } else {
            Logger(`Converting ${u} Failed!`, LOG_LEVEL_NOTICE);
            Logger(E, LOG_LEVEL_VERBOSE);
          }
        } catch (s) {
          if (404 == (null == s ? void 0 : s.status)) {
            if ((await this.plugin.localDatabase.putRaw(b)).ok) {
              Logger(`${u} has been converted`, LOG_LEVEL_NOTICE);
              _._deleted = true;
              if ((await this.plugin.localDatabase.putRaw(_)).ok) Logger(`Old ${u} has been deleted`, LOG_LEVEL_NOTICE);
            }
          } else {
            Logger(`Something went wrong on converting ${u}`, LOG_LEVEL_NOTICE);
            Logger(s, LOG_LEVEL_VERBOSE);
          }
        }
      }
      Logger("Converting finished", LOG_LEVEL_NOTICE);
    }))));
    new import_obsidian.Setting(ae).setName("Suspend file watching").setDesc("Stop watching for file change.").addToggle((s => s.setValue(this.plugin.settings.suspendFileWatching).onChange((async s => {
      this.plugin.settings.suspendFileWatching = s;
      await this.plugin.saveSettings();
      scheduleTask("configReload", 250, (async () => {
        if ("yes" == await askYesNo(this.app, "Do you want to restart and reload Obsidian now?")) this.app.commands.executeCommandById("app:reload");
      }));
    }))));
    new import_obsidian.Setting(ae).setName("Suspend database reflecting").setDesc("Stop reflecting database changes to storage files.").addToggle((s => s.setValue(this.plugin.settings.suspendParseReplicationResult).onChange((async s => {
      this.plugin.settings.suspendParseReplicationResult = s;
      await this.plugin.saveSettings();
      scheduleTask("configReload", 250, (async () => {
        if ("yes" == await askYesNo(this.app, "Do you want to restart and reload Obsidian now?")) this.app.commands.executeCommandById("app:reload");
      }));
    }))));
    new import_obsidian.Setting(ae).setName("Write logs into the file").setDesc("Warning! This will have a serious impact on performance. And the logs will not be synchronised under the default name. Please be careful with logs; they often contain your confidential information.").addToggle((s => s.setValue(this.plugin.settings.writeLogToTheFile).onChange((async s => {
      this.plugin.settings.writeLogToTheFile = s;
      await this.plugin.saveSettings();
    }))));
    new import_obsidian.Setting(ae).setName("Do not pace synchronization").setDesc("If this toggle enabled, synchronisation will not be paced by queued entries. If synchronisation has been deadlocked, please make this enabled once.").addToggle((s => s.setValue(this.plugin.settings.doNotPaceReplication).onChange((async s => {
      this.plugin.settings.doNotPaceReplication = s;
      await this.plugin.saveSettings();
    }))));
    ae.createEl("h4", {
      text: (0, import_obsidian.sanitizeHTMLToDom)("Compatibility"),
      cls: "wizardHidden"
    });
    new import_obsidian.Setting(ae).setName("Do not keep metadata of deleted files.").setClass("wizardHidden").addToggle((s => {
      s.setValue(this.plugin.settings.deleteMetadataOfDeletedFiles).onChange((async s => {
        this.plugin.settings.deleteMetadataOfDeletedFiles = s;
        await this.plugin.saveSettings();
        this.display();
      }));
    }));
    if (this.plugin.settings.deleteMetadataOfDeletedFiles) new import_obsidian.Setting(ae).setName("Delete old metadata of deleted files on start-up").setClass("wizardHidden").setDesc("(Days passed, 0 to disable automatic-deletion)").addText((s => {
      s.setPlaceholder("").setValue(this.plugin.settings.automaticallyDeleteMetadataOfDeletedFiles + "").onChange((async s => {
        let r = Number(s);
        if (isNaN(r)) r = 0;
        this.plugin.settings.automaticallyDeleteMetadataOfDeletedFiles = r;
        await this.plugin.saveSettings();
      }));
      s.inputEl.setAttribute("type", "number");
    }));
    new import_obsidian.Setting(ae).setName("Use an old adapter for compatibility").setDesc("This option is not compatible with a database made by older versions. Changing this configuration will fetch the remote database again.").setClass("wizardHidden").addToggle((s => s.setValue(!this.plugin.settings.useIndexedDBAdapter).onChange((async s => {
      this.plugin.settings.useIndexedDBAdapter = !s;
      await this.plugin.saveSettings();
      await rebuildDB("localOnly");
    }))));
    new import_obsidian.Setting(ae).setName("Scan changes on customization sync").setDesc("Do not use internal API").addToggle((s => s.setValue(!this.plugin.settings.watchInternalFileChanges).onChange((async s => {
      this.plugin.settings.watchInternalFileChanges = !s;
      await this.plugin.saveSettings();
    }))));
    let le = this.plugin.settings.additionalSuffixOfDatabaseName + "";
    new import_obsidian.Setting(ae).setName("Database suffix").setDesc("LiveSync could not treat multiple vaults which have same name, please add some suffix from here.").addText((s => {
      s.setPlaceholder("").setValue(le).onChange((s => {
        le = s;
      }));
    })).addButton((s => {
      s.setButtonText("Change").onClick((async () => {
        if (this.plugin.settings.additionalSuffixOfDatabaseName == le) {
          Logger("Suffix was not changed.", LOG_LEVEL_NOTICE);
          return;
        }
        this.plugin.settings.additionalSuffixOfDatabaseName = le;
        await this.plugin.saveSettings();
        Logger("Suffix has been changed. Reopening database...", LOG_LEVEL_NOTICE);
        await this.plugin.initializeDatabase();
      }));
    }));
    new import_obsidian.Setting(ae).setName("The Hash algorithm for chunk IDs").setDesc("xxhash64 is the current default.").setClass("wizardHidden").addDropdown((s => s.addOptions({
      "": "Old Algorithm",
      xxhash32: "xxhash32 (Fast)",
      xxhash64: "xxhash64 (Fastest)"
    }).setValue(this.plugin.settings.hashAlg).onChange((async s => {
      this.plugin.settings.hashAlg = s;
      await this.plugin.saveSettings();
    })))).setClass("wizardHidden");
    new import_obsidian.Setting(ae).setName("Fetch database with previous behaviour").setDesc("").addToggle((s => s.setValue(this.plugin.settings.doNotSuspendOnFetching).onChange((async s => {
      this.plugin.settings.doNotSuspendOnFetching = s;
      await this.plugin.saveSettings();
    }))));
    addScreenElement("50", ae);
    const ce = s.createDiv();
    ce.createEl("h3", {
      text: "Customization sync (beta)"
    });
    const ue = new import_obsidian.Setting(ce).setName("Device name").setDesc("Unique name between all synchronized devices").addText((s => {
      s.setPlaceholder("desktop").setValue(this.plugin.deviceAndVaultName).onChange((async s => {
        this.plugin.deviceAndVaultName = s;
        await this.plugin.saveSettings();
      }));
    })), updateDisabledOfDeviceAndVaultName = () => {
      ue.setDisabled(this.plugin.settings.usePluginSync);
    };
    updateDisabledOfDeviceAndVaultName();
    new import_obsidian.Setting(ce).setName("Enable customization sync").addToggle((s => s.setValue(this.plugin.settings.usePluginSync).onChange((async r => {
      if (r && "" == this.plugin.deviceAndVaultName.trim()) {
        Logger("We have to configure `Device name` to use this feature.", LOG_LEVEL_NOTICE);
        s.setValue(false);
        return false;
      }
      this.plugin.settings.usePluginSync = r;
      this.display();
      await this.plugin.saveSettings();
    }))));
    if (this.plugin.settings.usePluginSync) {
      new import_obsidian.Setting(ce).setName("Scan customization automatically").setDesc("Scan customization before replicating.").addToggle((s => s.setValue(this.plugin.settings.autoSweepPlugins).onChange((async s => {
        this.plugin.settings.autoSweepPlugins = s;
        updateDisabledOfDeviceAndVaultName();
        await this.plugin.saveSettings();
      }))));
      new import_obsidian.Setting(ce).setName("Scan customization periodically").setDesc("Scan customization every 1 minute. This configuration will be ignored if monitoring changes of hidden files has been enabled.").addToggle((s => s.setValue(this.plugin.settings.autoSweepPluginsPeriodic).onChange((async s => {
        this.plugin.settings.autoSweepPluginsPeriodic = s;
        updateDisabledOfDeviceAndVaultName();
        await this.plugin.saveSettings();
      }))));
      new import_obsidian.Setting(ce).setName("Notify customized").setDesc("Notify when other device has newly customized.").addToggle((s => s.setValue(this.plugin.settings.notifyPluginOrSettingUpdated).onChange((async s => {
        this.plugin.settings.notifyPluginOrSettingUpdated = s;
        await this.plugin.saveSettings();
      }))));
      new import_obsidian.Setting(ce).setName("Open").setDesc("Open the dialog").addButton((s => {
        s.setButtonText("Open").setDisabled(false).onClick((() => {
          this.plugin.addOnConfigSync.showPluginSyncModal();
        }));
      }));
    }
    updateDisabledOfDeviceAndVaultName();
    addScreenElement("60", ce);
    const de = s.createDiv();
    de.createEl("h3", {
      text: "Maintain databases"
    });
    de.createEl("h4", {
      text: "The remote database"
    });
    new import_obsidian.Setting(de).setName("Lock remote database").setDesc("Lock remote database to prevent synchronization with other devices.").addButton((s => s.setButtonText("Lock").setDisabled(false).setWarning().onClick((async () => {
      await this.plugin.markRemoteLocked();
    }))));
    new import_obsidian.Setting(de).setName("Overwrite remote database").setDesc("Overwrite remote database with local DB and passphrase.").addButton((s => s.setButtonText("Send").setWarning().setDisabled(false).onClick((async () => {
      await rebuildDB("remoteOnly");
    }))));
    de.createEl("h4", {
      text: "The local database"
    });
    new import_obsidian.Setting(de).setName("Fetch rebuilt DB").setDesc("Restore or reconstruct local database from remote database.").addButton((s => s.setButtonText("Fetch").setWarning().setDisabled(false).onClick((async () => {
      await rebuildDB("localOnly");
    }))));
    new import_obsidian.Setting(de).setName("Discard local database to reset or uninstall Self-hosted LiveSync").addButton((s => s.setButtonText("Discard").setWarning().setDisabled(false).onClick((async () => {
      await this.plugin.resetLocalDatabase();
      await this.plugin.initializeDatabase();
    }))));
    de.createEl("h4", {
      text: "Both databases"
    });
    new import_obsidian.Setting(de).setName("(Beta2) Clean up databases").setDesc("Delete unused chunks to shrink the database. This feature requires disabling 'Use an old adapter for compatibility'").addButton((s => s.setButtonText("DryRun").setDisabled(false).onClick((async () => {
      await this.plugin.dryRunGC();
    })))).addButton((s => s.setButtonText("Perform cleaning").setDisabled(false).setWarning().onClick((async () => {
      this.plugin.app.setting.close();
      await this.plugin.dbGC();
    }))));
    new import_obsidian.Setting(de).setName("Rebuild everything").setDesc("Rebuild local and remote database with local files.").addButton((s => s.setButtonText("Rebuild").setWarning().setDisabled(false).onClick((async () => {
      await rebuildDB("rebuildBothByThisDevice");
    }))));
    applyDisplayEnabled();
    addScreenElement("70", de);
    applyDisplayEnabled();
    if ("" == this.selectedScreen) if (D != this.plugin.settings.lastReadUpdates) if (JSON.stringify(this.plugin.settings) != JSON.stringify(DEFAULT_SETTINGS)) changeDisplay("100"); else changeDisplay("110"); else if (isAnySyncEnabled()) changeDisplay("20"); else changeDisplay("110"); else changeDisplay(this.selectedScreen);
  }
}, DocumentHistoryModal = class extends import_obsidian.Modal {
  constructor(s, r, o, u, g) {
    super(s);
    this.showDiff = false;
    this.revs_info = [];
    this.currentText = "";
    this.currentDeleted = false;
    this.plugin = r;
    this.file = o instanceof import_obsidian.TFile ? getPathFromTFile(o) : o;
    this.id = u;
    this.initialRev = g;
    if (!o) this.file = this.plugin.id2path(u, null);
    if ("1" == localStorage.getItem("ols-history-highlightdiff")) this.showDiff = true;
  }
  async loadFile(s) {
    if (!this.id) this.id = await this.plugin.path2id(this.file);
    const r = this.plugin.localDatabase;
    try {
      const o = await r.localDatabase.get(this.id, {
        revs_info: true
      });
      this.revs_info = o._revs_info.filter((s => "available" == (null == s ? void 0 : s.status)));
      this.range.max = "" + (this.revs_info.length - 1);
      this.range.value = this.range.max;
      this.fileInfo.setText(`${this.file} / ${this.revs_info.length} revisions`);
      await this.loadRevs(s);
    } catch (s) {
      if (isErrorOfMissingDoc(s)) {
        this.range.max = "0";
        this.range.value = "";
        this.range.disabled = true;
        this.showDiff;
        this.contentView.setText("History of this file was not recorded.");
      } else {
        this.contentView.setText("Error occurred.");
        Logger(s, LOG_LEVEL_VERBOSE);
      }
    }
  }
  async loadRevs(s) {
    if (0 == this.revs_info.length) return;
    if (s) {
      const r = this.revs_info.findIndex((r => r.rev == s));
      if (r >= 0) this.range.value = "" + (this.revs_info.length - 1 - r);
    }
    const r = this.revs_info.length - 1 - this.range.value / 1, o = this.revs_info[r];
    await this.showExactRev(o.rev);
  }
  async showExactRev(s) {
    const r = this.plugin.localDatabase, o = await r.getDBEntry(this.file, {
      rev: s
    }, false, false, true);
    this.currentText = "";
    this.currentDeleted = false;
    if (false === o) {
      this.currentDeleted = true;
      this.info.innerHTML = "";
      this.contentView.innerHTML = `Could not read this revision<br>(${s})`;
    } else {
      this.currentDoc = o;
      this.info.innerHTML = `Modified:${new Date(o.mtime).toLocaleString()}`;
      let s = "";
      const u = "plain" == o.datatype ? getDocData(o.data) : base64ToString(o.data);
      this.currentDeleted = o.deleted;
      this.currentText = u;
      if (this.showDiff) {
        const o = this.revs_info.length - 1 - (this.range.value / 1 - 1);
        if (o >= 0 && o < this.revs_info.length) {
          const g = this.revs_info[o].rev, _ = await r.getDBEntry(this.file, {
            rev: g
          }, false, false, true);
          if (false != _) {
            const r = new import_diff_match_patch.diff_match_patch, o = "plain" == _.datatype ? getDocData(_.data) : base64ToString(_.data), g = r.diff_main(o, u);
            r.diff_cleanupSemantic(g);
            for (const r of g) {
              const o = r[0], u = r[1];
              if (o == import_diff_match_patch.DIFF_DELETE) s += "<span class='history-deleted'>" + escapeStringToHTML(u) + "</span>"; else if (o == import_diff_match_patch.DIFF_EQUAL) s += "<span class='history-normal'>" + escapeStringToHTML(u) + "</span>"; else if (o == import_diff_match_patch.DIFF_INSERT) s += "<span class='history-added'>" + escapeStringToHTML(u) + "</span>";
            }
            s = s.replace(/\n/g, "<br>");
          } else s = escapeStringToHTML(u);
        } else s = escapeStringToHTML(u);
      } else s = escapeStringToHTML(u);
      this.contentView.innerHTML = (this.currentDeleted ? "(At this revision, the file has been deleted)\n" : "") + s;
    }
  }
  onOpen() {
    const {contentEl: s} = this;
    s.empty();
    s.createEl("h2", {
      text: "Document History"
    });
    this.fileInfo = s.createDiv("");
    this.fileInfo.addClass("op-info");
    const r = s.createDiv("");
    r.addClass("op-flex");
    r.createEl("input", {
      type: "range"
    }, (s => {
      this.range = s;
      s.addEventListener("change", (s => {
        this.loadRevs();
      }));
      s.addEventListener("input", (s => {
        this.loadRevs();
      }));
    }));
    s.createDiv("", (s => {
      s.createEl("label", {}, (s => {
        s.appendChild(createEl("input", {
          type: "checkbox"
        }, (s => {
          if (this.showDiff) s.checked = true;
          s.addEventListener("input", (r => {
            this.showDiff = s.checked;
            localStorage.setItem("ols-history-highlightdiff", true == this.showDiff ? "1" : "");
            this.loadRevs();
          }));
        })));
        s.appendText("Highlight diff");
      }));
    })).addClass("op-info");
    this.info = s.createDiv("");
    this.info.addClass("op-info");
    this.loadFile(this.initialRev);
    const o = s.createDiv({
      text: "Loading old revisions..."
    });
    this.contentView = o;
    o.addClass("op-scrollable");
    o.addClass("op-pre");
    const u = s.createDiv("");
    u.createEl("button", {
      text: "Copy to clipboard"
    }, (s => {
      s.addClass("mod-cta");
      s.addEventListener("click", (async () => {
        await navigator.clipboard.writeText(this.currentText);
        Logger("Old content copied to clipboard", LOG_LEVEL_NOTICE);
      }));
    }));
    async function focusFile(s) {
      const r = app.vault.getFiles().find((r => r.path === s));
      if (r) {
        const s = app.workspace.getLeaf(false);
        await s.openFile(r);
      } else Logger("The file could not view on the editor", LOG_LEVEL_NOTICE);
    }
    u.createEl("button", {
      text: "Back to this revision"
    }, (s => {
      s.addClass("mod-cta");
      s.addEventListener("click", (async () => {
        var s, r;
        const o = stripPrefix(this.file);
        if (!isValidPath(o)) Logger("Path is not valid to write content.", LOG_LEVEL_INFO);
        if ("plain" == (null == (s = this.currentDoc) ? void 0 : s.datatype)) {
          await this.app.vault.adapter.write(o, getDocData(this.currentDoc.data));
          await focusFile(o);
          this.close();
        } else if ("newnote" == (null == (r = this.currentDoc) ? void 0 : r.datatype)) {
          await this.app.vault.adapter.writeBinary(o, base64ToArrayBuffer(this.currentDoc.data));
          await focusFile(o);
          this.close();
        } else Logger("Could not parse entry", LOG_LEVEL_NOTICE);
      }));
    }));
  }
  onClose() {
    const {contentEl: s} = this;
    s.empty();
  }
}, StorageEventManager = class {}, StorageEventManagerObsidian = class extends StorageEventManager {
  constructor(s) {
    super();
    this.queuedFilesStore = getGlobalStore("queuedFiles", {
      queuedItems: [],
      fileEventItems: []
    });
    this.watchedFileEventQueue = [];
    this.plugin = s;
    this.watchVaultChange = this.watchVaultChange.bind(this);
    this.watchVaultCreate = this.watchVaultCreate.bind(this);
    this.watchVaultDelete = this.watchVaultDelete.bind(this);
    this.watchVaultRename = this.watchVaultRename.bind(this);
    this.watchVaultRawEvents = this.watchVaultRawEvents.bind(this);
    s.registerEvent(s.app.vault.on("modify", this.watchVaultChange));
    s.registerEvent(s.app.vault.on("delete", this.watchVaultDelete));
    s.registerEvent(s.app.vault.on("rename", this.watchVaultRename));
    s.registerEvent(s.app.vault.on("create", this.watchVaultCreate));
    s.registerEvent(s.app.vault.on("raw", this.watchVaultRawEvents));
  }
  watchVaultCreate(s, r) {
    this.appendWatchEvent([ {
      type: "CREATE",
      file: s
    } ], r);
  }
  watchVaultChange(s, r) {
    this.appendWatchEvent([ {
      type: "CHANGED",
      file: s
    } ], r);
  }
  watchVaultDelete(s, r) {
    this.appendWatchEvent([ {
      type: "DELETE",
      file: s
    } ], r);
  }
  watchVaultRename(s, r, o) {
    if (s instanceof import_obsidian.TFile) this.appendWatchEvent([ {
      type: "DELETE",
      file: {
        path: r,
        mtime: s.stat.mtime,
        ctime: s.stat.ctime,
        size: s.stat.size,
        deleted: true
      }
    }, {
      type: "CREATE",
      file: s
    } ], o);
  }
  watchVaultRawEvents(s) {
    if (this.plugin.settings.useIgnoreFiles && this.plugin.ignoreFiles.some((r => s.endsWith(r.trim())))) this.plugin.isTargetFile(s).then((() => this._watchVaultRawEvents(s))); else this._watchVaultRawEvents(s);
  }
  _watchVaultRawEvents(s) {
    if (!this.plugin.settings.syncInternalFiles && !this.plugin.settings.usePluginSync) return;
    if (!this.plugin.settings.watchInternalFileChanges) return;
    if (!s.startsWith(this.plugin.app.vault.configDir)) return;
    const r = void 0;
    if (this.plugin.settings.syncInternalFilesIgnorePatterns.replace(/\n| /g, "").split(",").filter((s => s)).map((s => new RegExp(s, "i"))).some((r => s.match(r)))) return;
    this.appendWatchEvent([ {
      type: "INTERNAL",
      file: {
        path: s,
        mtime: 0,
        ctime: 0,
        size: 0
      }
    } ], null);
  }
  async appendWatchEvent(s, r) {
    let o = false;
    for (const u of s) {
      if (shouldBeIgnored(u.file.path)) continue;
      const s = [ 0, 0, 0, 0, 0, 0 ].map((s => `${Math.floor(1e5 * Math.random())}`)).join("-"), g = u.type, _ = u.file, b = u.oldPath;
      if (_ instanceof import_obsidian.TFolder) continue;
      if (!await this.plugin.isTargetFile(_.path)) continue;
      if (this.plugin.settings.suspendFileWatching) continue;
      let w;
      if (_ instanceof import_obsidian.TFile && ("CREATE" == g || "CHANGED" == g)) {
        if (recentlyTouched(_)) continue;
        if (!isPlainText(_.name)) w = await this.plugin.app.vault.readBinary(_); else {
          w = await this.plugin.app.vault.cachedRead(_);
          if (!w) w = await this.plugin.app.vault.read(_);
        }
      }
      if ("DELETE" == g || "RENAME" == g) o = true;
      if (this.plugin.settings.batchSave && !this.plugin.settings.liveSync) {
        let s = this.watchedFileEventQueue.length;
        e: for (;s >= 0; ) {
          s--;
          if (s < 0) break e;
          if (this.watchedFileEventQueue[s].args.file.path != _.path) continue e;
          if (this.watchedFileEventQueue[s].type != g) break e;
          this.watchedFileEventQueue.remove(this.watchedFileEventQueue[s]);
          this.queuedFilesStore.apply((s => ({
            ...s,
            fileEventItems: this.watchedFileEventQueue
          })));
        }
      }
      const E = _ instanceof import_obsidian.TFile ? {
        ctime: _.stat.ctime,
        mtime: _.stat.mtime,
        file: _,
        path: _.path,
        size: _.stat.size
      } : _;
      this.watchedFileEventQueue.push({
        type: g,
        args: {
          file: E,
          oldPath: b,
          cache: w,
          ctx: r
        },
        key: s
      });
    }
    this.queuedFilesStore.apply((s => ({
      ...s,
      fileEventItems: this.watchedFileEventQueue
    })));
    this.plugin.procFileEvent(o);
  }
  fetchEvent() {
    if (0 == this.watchedFileEventQueue.length) return false;
    const s = this.watchedFileEventQueue.shift();
    this.queuedFilesStore.apply((s => ({
      ...s,
      fileEventItems: this.watchedFileEventQueue
    })));
    return s;
  }
  cancelRelativeEvent(s) {
    this.watchedFileEventQueue = [ ...this.watchedFileEventQueue ].filter((r => r.key != s.key));
    this.queuedFilesStore.apply((s => ({
      ...s,
      fileEventItems: this.watchedFileEventQueue
    })));
  }
  getQueueLength() {
    return this.watchedFileEventQueue.length;
  }
}, t = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 2, 127, 127, 0, 96, 3, 127, 127, 127, 1, 127, 3, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 23, 3, 3, 109, 101, 109, 2, 0, 5, 120, 120, 104, 51, 50, 0, 0, 5, 120, 120, 104, 54, 52, 0, 1, 10, 152, 9, 2, 242, 2, 1, 4, 127, 32, 0, 32, 1, 106, 33, 3, 32, 1, 32, 1, 65, 16, 79, 4, 127, 32, 3, 65, 16, 107, 33, 6, 32, 2, 65, 168, 136, 141, 161, 2, 106, 33, 1, 32, 2, 65, 137, 235, 208, 208, 7, 107, 33, 4, 32, 2, 65, 207, 140, 162, 142, 6, 106, 33, 5, 3, 64, 32, 1, 32, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 1, 32, 4, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 2, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 5, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 6, 32, 0, 65, 4, 106, 34, 0, 79, 13, 0, 11, 32, 2, 65, 12, 119, 32, 5, 65, 18, 119, 106, 32, 4, 65, 7, 119, 106, 32, 1, 65, 1, 119, 106, 5, 32, 2, 65, 177, 207, 217, 178, 1, 106, 11, 106, 33, 2, 3, 64, 32, 3, 32, 0, 65, 4, 106, 79, 4, 64, 32, 2, 32, 0, 40, 2, 0, 65, 189, 220, 202, 149, 124, 108, 106, 65, 17, 119, 65, 175, 214, 211, 190, 2, 108, 33, 2, 32, 0, 65, 4, 106, 33, 0, 12, 1, 11, 11, 3, 64, 32, 0, 32, 3, 73, 4, 64, 32, 2, 32, 0, 45, 0, 0, 65, 177, 207, 217, 178, 1, 108, 106, 65, 11, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 0, 65, 1, 106, 33, 0, 12, 1, 11, 11, 32, 2, 32, 2, 65, 15, 118, 115, 65, 247, 148, 175, 175, 120, 108, 34, 0, 65, 13, 118, 32, 0, 115, 65, 189, 220, 202, 149, 124, 108, 34, 0, 65, 16, 118, 32, 0, 115, 11, 161, 6, 2, 4, 126, 3, 127, 32, 0, 65, 4, 106, 53, 2, 0, 32, 0, 53, 2, 0, 66, 32, 134, 132, 33, 2, 32, 1, 32, 0, 65, 8, 106, 34, 6, 106, 33, 7, 32, 1, 65, 32, 79, 4, 126, 32, 7, 65, 32, 107, 33, 8, 32, 2, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 33, 3, 32, 2, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 33, 4, 32, 2, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 33, 5, 3, 64, 32, 3, 32, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 3, 32, 4, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 4, 32, 2, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 5, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 5, 32, 8, 32, 6, 65, 8, 106, 34, 6, 79, 13, 0, 11, 32, 2, 66, 12, 137, 32, 5, 66, 18, 137, 124, 32, 4, 66, 7, 137, 124, 32, 3, 66, 1, 137, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 2, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 1, 173, 124, 33, 2, 3, 64, 32, 7, 32, 6, 65, 8, 106, 79, 4, 64, 32, 2, 32, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 27, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 33, 2, 32, 6, 65, 8, 106, 33, 6, 12, 1, 11, 11, 32, 6, 65, 4, 106, 32, 7, 77, 4, 64, 32, 2, 32, 6, 53, 2, 0, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 23, 137, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 124, 33, 2, 32, 6, 65, 4, 106, 33, 6, 11, 3, 64, 32, 6, 32, 7, 73, 4, 64, 32, 2, 32, 6, 49, 0, 0, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 126, 133, 66, 11, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 6, 65, 1, 106, 33, 6, 12, 1, 11, 11, 32, 0, 32, 2, 32, 2, 66, 33, 136, 133, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 34, 2, 66, 29, 136, 32, 2, 133, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 126, 34, 2, 66, 32, 136, 32, 2, 133, 34, 2, 66, 32, 136, 62, 2, 0, 32, 0, 65, 4, 106, 32, 2, 62, 2, 0, 11 ]), e;

function n(s, r, o) {
  if (r.buffer.byteLength < s.byteLength + o) {
    const u = Math.ceil((s.byteLength + o - r.buffer.byteLength) / 65536);
    r.grow(u);
  }
  new Uint8Array(r.buffer, o).set(s);
}

async function xxhash_wasm_default() {
  const {instance: {exports: {mem: s, xxh32: r, xxh64: o}}} = await WebAssembly.instantiate(t);
  function h2(o) {
    let u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return n(o, s, 0), r(0, o.byteLength, u) >>> 0;
  }
  function c(r) {
    let u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, g = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    n(r, s, 8);
    const _ = new DataView(s.buffer);
    return _.setUint32(0, u, true), _.setUint32(4, g, true), o(0, r.byteLength), _;
  }
  return {
    h32: function(s) {
      let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      e || (e = new TextEncoder);
      const o = void 0;
      return h2(e.encode(s), r).toString(16);
    },
    h32Raw: h2,
    h64: function(s) {
      let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
      e || (e = new TextEncoder);
      const u = void 0, g = c(e.encode(s), r, o), _ = void 0;
      return g.getUint32(0, true).toString(16) + g.getUint32(4, true).toString(16);
    },
    h64Raw: function(s) {
      let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
      return new Uint8Array(c(s, r, o).buffer, 0, 8);
    }
  };
}

var t2 = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 48, 8, 96, 3, 127, 127, 127, 0, 96, 3, 127, 127, 127, 1, 127, 96, 2, 127, 127, 0, 96, 2, 127, 126, 0, 96, 1, 127, 1, 127, 96, 1, 127, 1, 126, 96, 3, 127, 127, 126, 1, 126, 96, 3, 126, 127, 127, 1, 126, 3, 11, 10, 1, 1, 2, 0, 4, 6, 7, 3, 0, 5, 5, 3, 1, 0, 1, 7, 85, 9, 3, 109, 101, 109, 2, 0, 5, 120, 120, 104, 51, 50, 0, 0, 6, 105, 110, 105, 116, 51, 50, 0, 2, 8, 117, 112, 100, 97, 116, 101, 51, 50, 0, 3, 8, 100, 105, 103, 101, 115, 116, 51, 50, 0, 4, 5, 120, 120, 104, 54, 52, 0, 5, 6, 105, 110, 105, 116, 54, 52, 0, 7, 8, 117, 112, 100, 97, 116, 101, 54, 52, 0, 8, 8, 100, 105, 103, 101, 115, 116, 54, 52, 0, 9, 10, 211, 23, 10, 242, 1, 1, 4, 127, 32, 0, 32, 1, 106, 33, 3, 32, 1, 65, 16, 79, 4, 127, 32, 3, 65, 16, 107, 33, 6, 32, 2, 65, 168, 136, 141, 161, 2, 106, 33, 3, 32, 2, 65, 247, 148, 175, 175, 120, 106, 33, 4, 32, 2, 65, 177, 243, 221, 241, 121, 107, 33, 5, 3, 64, 32, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 3, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 4, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 2, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 5, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 0, 65, 4, 106, 34, 0, 32, 6, 77, 13, 0, 11, 32, 2, 65, 12, 119, 32, 5, 65, 18, 119, 106, 32, 4, 65, 7, 119, 106, 32, 3, 65, 1, 119, 106, 5, 32, 2, 65, 177, 207, 217, 178, 1, 106, 11, 32, 1, 106, 32, 0, 32, 1, 65, 15, 113, 16, 1, 11, 146, 1, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 1, 65, 4, 106, 32, 2, 75, 69, 4, 64, 32, 1, 40, 2, 0, 65, 189, 220, 202, 149, 124, 108, 32, 0, 106, 65, 17, 119, 65, 175, 214, 211, 190, 2, 108, 33, 0, 32, 1, 65, 4, 106, 33, 1, 12, 1, 11, 11, 3, 64, 32, 1, 32, 2, 79, 69, 4, 64, 32, 1, 45, 0, 0, 65, 177, 207, 217, 178, 1, 108, 32, 0, 106, 65, 11, 119, 65, 177, 243, 221, 241, 121, 108, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 65, 15, 118, 32, 0, 115, 65, 247, 148, 175, 175, 120, 108, 34, 0, 32, 0, 65, 13, 118, 115, 65, 189, 220, 202, 149, 124, 108, 34, 0, 32, 0, 65, 16, 118, 115, 11, 63, 0, 32, 0, 65, 8, 106, 32, 1, 65, 168, 136, 141, 161, 2, 106, 54, 2, 0, 32, 0, 65, 12, 106, 32, 1, 65, 247, 148, 175, 175, 120, 106, 54, 2, 0, 32, 0, 65, 16, 106, 32, 1, 54, 2, 0, 32, 0, 65, 20, 106, 32, 1, 65, 177, 243, 221, 241, 121, 107, 54, 2, 0, 11, 211, 4, 1, 6, 127, 32, 1, 32, 2, 106, 33, 6, 32, 0, 65, 24, 106, 33, 5, 32, 0, 65, 40, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 40, 2, 0, 32, 2, 106, 54, 2, 0, 32, 0, 65, 4, 106, 34, 4, 32, 4, 40, 2, 0, 32, 2, 65, 16, 79, 32, 0, 40, 2, 0, 65, 16, 79, 114, 114, 54, 2, 0, 32, 2, 32, 3, 106, 65, 16, 73, 4, 64, 32, 3, 32, 5, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 5, 106, 32, 1, 65, 16, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 40, 2, 0, 32, 5, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 3, 32, 4, 54, 2, 0, 32, 0, 65, 12, 106, 34, 3, 40, 2, 0, 32, 5, 65, 4, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 3, 32, 4, 54, 2, 0, 32, 0, 65, 16, 106, 34, 3, 40, 2, 0, 32, 5, 65, 8, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 3, 32, 4, 54, 2, 0, 32, 0, 65, 20, 106, 34, 3, 40, 2, 0, 32, 5, 65, 12, 106, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 3, 32, 4, 54, 2, 0, 32, 0, 65, 40, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 32, 6, 65, 16, 107, 77, 4, 64, 32, 6, 65, 16, 107, 33, 8, 32, 0, 65, 8, 106, 40, 2, 0, 33, 2, 32, 0, 65, 12, 106, 40, 2, 0, 33, 3, 32, 0, 65, 16, 106, 40, 2, 0, 33, 4, 32, 0, 65, 20, 106, 40, 2, 0, 33, 7, 3, 64, 32, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 2, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 3, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 3, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 4, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 1, 65, 4, 106, 34, 1, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 32, 7, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 7, 32, 1, 65, 4, 106, 34, 1, 32, 8, 77, 13, 0, 11, 32, 0, 65, 8, 106, 32, 2, 54, 2, 0, 32, 0, 65, 12, 106, 32, 3, 54, 2, 0, 32, 0, 65, 16, 106, 32, 4, 54, 2, 0, 32, 0, 65, 20, 106, 32, 7, 54, 2, 0, 11, 32, 1, 32, 6, 73, 4, 64, 32, 5, 32, 1, 32, 6, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 40, 106, 32, 1, 54, 2, 0, 11, 11, 97, 1, 1, 127, 32, 0, 65, 16, 106, 40, 2, 0, 33, 1, 32, 0, 65, 4, 106, 40, 2, 0, 4, 127, 32, 1, 65, 12, 119, 32, 0, 65, 20, 106, 40, 2, 0, 65, 18, 119, 106, 32, 0, 65, 12, 106, 40, 2, 0, 65, 7, 119, 106, 32, 0, 65, 8, 106, 40, 2, 0, 65, 1, 119, 106, 5, 32, 1, 65, 177, 207, 217, 178, 1, 106, 11, 32, 0, 40, 2, 0, 106, 32, 0, 65, 24, 106, 32, 0, 65, 40, 106, 40, 2, 0, 16, 1, 11, 157, 4, 2, 1, 127, 3, 126, 32, 0, 32, 1, 106, 33, 3, 32, 1, 65, 32, 79, 4, 126, 32, 3, 65, 32, 107, 33, 3, 32, 2, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 124, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 124, 33, 4, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 124, 33, 5, 32, 2, 66, 0, 124, 33, 6, 32, 2, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 125, 33, 2, 3, 64, 32, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 4, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 4, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 5, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 5, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 6, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 0, 65, 8, 106, 34, 0, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 2, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 0, 65, 8, 106, 34, 0, 32, 3, 77, 13, 0, 11, 32, 6, 66, 12, 137, 32, 2, 66, 18, 137, 124, 32, 5, 66, 7, 137, 124, 32, 4, 66, 1, 137, 124, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 6, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 5, 32, 2, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 1, 173, 124, 32, 0, 32, 1, 65, 31, 113, 16, 6, 11, 137, 2, 0, 32, 1, 32, 2, 106, 33, 2, 3, 64, 32, 1, 65, 8, 106, 32, 2, 77, 4, 64, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 32, 0, 133, 66, 27, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 33, 0, 32, 1, 65, 8, 106, 33, 1, 12, 1, 11, 11, 32, 1, 65, 4, 106, 32, 2, 77, 4, 64, 32, 1, 53, 2, 0, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 32, 0, 133, 66, 23, 137, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 124, 33, 0, 32, 1, 65, 4, 106, 33, 1, 11, 3, 64, 32, 1, 32, 2, 73, 4, 64, 32, 1, 49, 0, 0, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 126, 32, 0, 133, 66, 11, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 33, 136, 32, 0, 133, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 34, 0, 32, 0, 66, 29, 136, 133, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 126, 34, 0, 32, 0, 66, 32, 136, 133, 11, 88, 0, 32, 0, 65, 8, 106, 32, 1, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 124, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 124, 55, 3, 0, 32, 0, 65, 16, 106, 32, 1, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 124, 55, 3, 0, 32, 0, 65, 24, 106, 32, 1, 55, 3, 0, 32, 0, 65, 32, 106, 32, 1, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 125, 55, 3, 0, 11, 132, 5, 2, 3, 127, 4, 126, 32, 1, 32, 2, 106, 33, 5, 32, 0, 65, 40, 106, 33, 4, 32, 0, 65, 200, 0, 106, 40, 2, 0, 33, 3, 32, 0, 32, 0, 41, 3, 0, 32, 2, 173, 124, 55, 3, 0, 32, 2, 32, 3, 106, 65, 32, 73, 4, 64, 32, 3, 32, 4, 106, 32, 1, 32, 2, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 2, 32, 3, 106, 54, 2, 0, 15, 11, 32, 3, 4, 64, 32, 3, 32, 4, 106, 32, 1, 65, 32, 32, 3, 107, 34, 2, 252, 10, 0, 0, 32, 0, 65, 8, 106, 34, 3, 41, 3, 0, 32, 4, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 3, 32, 6, 55, 3, 0, 32, 0, 65, 16, 106, 34, 3, 41, 3, 0, 32, 4, 65, 8, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 3, 32, 6, 55, 3, 0, 32, 0, 65, 24, 106, 34, 3, 41, 3, 0, 32, 4, 65, 16, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 3, 32, 6, 55, 3, 0, 32, 0, 65, 32, 106, 34, 3, 41, 3, 0, 32, 4, 65, 24, 106, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 3, 32, 6, 55, 3, 0, 32, 0, 65, 200, 0, 106, 65, 0, 54, 2, 0, 32, 1, 32, 2, 106, 33, 1, 11, 32, 1, 65, 32, 106, 32, 5, 77, 4, 64, 32, 5, 65, 32, 107, 33, 2, 32, 0, 65, 8, 106, 41, 3, 0, 33, 6, 32, 0, 65, 16, 106, 41, 3, 0, 33, 7, 32, 0, 65, 24, 106, 41, 3, 0, 33, 8, 32, 0, 65, 32, 106, 41, 3, 0, 33, 9, 3, 64, 32, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 6, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 6, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 7, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 7, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 8, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 8, 32, 1, 65, 8, 106, 34, 1, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 32, 9, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 9, 32, 1, 65, 8, 106, 34, 1, 32, 2, 77, 13, 0, 11, 32, 0, 65, 8, 106, 32, 6, 55, 3, 0, 32, 0, 65, 16, 106, 32, 7, 55, 3, 0, 32, 0, 65, 24, 106, 32, 8, 55, 3, 0, 32, 0, 65, 32, 106, 32, 9, 55, 3, 0, 11, 32, 1, 32, 5, 73, 4, 64, 32, 4, 32, 1, 32, 5, 32, 1, 107, 34, 1, 252, 10, 0, 0, 32, 0, 65, 200, 0, 106, 32, 1, 54, 2, 0, 11, 11, 200, 2, 1, 5, 126, 32, 0, 65, 24, 106, 41, 3, 0, 33, 1, 32, 0, 41, 3, 0, 34, 2, 66, 32, 90, 4, 126, 32, 0, 65, 8, 106, 41, 3, 0, 34, 3, 66, 1, 137, 32, 0, 65, 16, 106, 41, 3, 0, 34, 4, 66, 7, 137, 124, 32, 1, 66, 12, 137, 32, 0, 65, 32, 106, 41, 3, 0, 34, 5, 66, 18, 137, 124, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 1, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 0, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 227, 220, 202, 149, 252, 206, 242, 245, 133, 127, 124, 5, 32, 1, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 2, 124, 32, 0, 65, 40, 106, 32, 2, 66, 31, 131, 167, 16, 6, 11 ]);

async function e2() {
  const {instance: {exports: {mem: s, xxh32: r, xxh64: o, init32: u, update32: g, digest32: _, init64: b, update64: w, digest64: E}}} = await WebAssembly.instantiate(t2);
  let S = new Uint8Array(s.buffer);
  function c(r, o) {
    if (s.buffer.byteLength < r + o) {
      const u = Math.ceil((r + o - s.buffer.byteLength) / 65536);
      s.grow(u), S = new Uint8Array(s.buffer);
    }
  }
  function l(s, r, o, u, g, _) {
    c(s);
    const b = new Uint8Array(s);
    return S.set(b), o(0, r), b.set(S.slice(0, s)), {
      update(r) {
        let o;
        return S.set(b), "string" == typeof r ? (c(3 * r.length, s), o = O.encodeInto(r, S.subarray(s)).written) : (c(r.byteLength, s), 
        S.set(r, s), o = r.byteLength), u(0, s, o), b.set(S.slice(0, s)), this;
      },
      digest: () => (S.set(b), _(g(0)))
    };
  }
  function d(s) {
    return s >>> 0;
  }
  const L = BigInt(2) ** BigInt(64) - BigInt(1);
  function y(s) {
    return s & L;
  }
  const O = new TextEncoder, D = BigInt(0);
  function p(s) {
    let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return c(3 * s.length, 0), d(r(0, O.encodeInto(s, S).written, o));
  }
  function v(s) {
    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : D;
    return c(3 * s.length, 0), y(o(0, O.encodeInto(s, S).written, r));
  }
  return {
    h32: p,
    h32ToString(s) {
      return p(s, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0).toString(16).padStart(8, "0");
    },
    h32Raw(s) {
      let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      return c(s.byteLength, 0), S.set(s), d(r(0, s.byteLength, o));
    },
    create32() {
      return l(48, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, u, g, _, d);
    },
    h64: v,
    h64ToString(s) {
      return v(s, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : D).toString(16).padStart(16, "0");
    },
    h64Raw(s) {
      let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : D;
      return c(s.byteLength, 0), S.set(s), y(o(0, s.byteLength, r));
    },
    create64() {
      return l(88, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : D, b, w, E, y);
    }
  };
}

async function putDBEntry(s, r, o) {
  var u;
  const g = s.id2path(r._id, r);
  if (!s.isTargetFile(g)) return false;
  const _ = stripAllPrefixes(g), b = [];
  let w = 0, E = 0, S = 0;
  const L = void 0, O = MAX_DOC_SIZE_BIN * Math.max(s.settings.customChunkSize, 1);
  let D = false, k = 0;
  const C = s.settings.passphrase, T = s.h32Raw((new TextEncoder).encode(C)), I = s.settings.minimumChunkSize;
  if (!o && shouldSplitAsPlainText(g)) D = true;
  const A = [], x = splitPieces2(r.data, O, D, I, 0), R = new Map;
  let P = true;
  for (const r of x()) {
    w++;
    let o = "", u = "";
    const g = s.hashCaches.revGet(r);
    if (g) {
      u = "";
      o = g;
      S++;
      k++;
      R.set(o, r);
    } else {
      if ("" === s.settings.hashAlg) if (s.settings.encrypt) u = "+" + (s.h32Raw((new TextEncoder).encode(r)) ^ T ^ r.length).toString(36); else u = (s.h32Raw((new TextEncoder).encode(r)) ^ r.length).toString(36); else if ("xxhash64" == s.settings.hashAlg && s.xxhash64) if (s.settings.encrypt) u = "+" + s.xxhash64(`${r}-${C}-${r.length}`).toString(36); else u = s.xxhash64(`${r}-${r.length}`).toString(36); else if (s.settings.encrypt) u = "+" + s.xxhash32(`${r}-${C}-${r.length}`).toString(36); else u = s.xxhash32(`${r}-${r.length}`).toString(36);
      o = "h:" + u;
    }
    if (R.has(o)) {
      if (R.get(o) != r) {
        Logger(`Hash collided! If possible, please report the following string:${o}=>\nA:--${R.get(o)}--\nB:--${r}--`, LOG_LEVEL_NOTICE);
        Logger(`This document could not be saved:${_}`, LOG_LEVEL_NOTICE);
        P = false;
      }
    } else R.set(o, r);
    b.push(o);
  }
  const N = [ ...R.keys() ];
  do {
    const r = N.splice(0, 100);
    if (r.length > 0) {
      const o = await s.localDatabase.allDocs({
        keys: [ ...r ],
        include_docs: true
      });
      for (const s of o.rows) if ("error" in s && "not_found" == s.error) {
        const r = R.get(s.key);
        if ("undefined" == typeof r) {
          Logger("Saving chunk error: Missing data:" + s.key);
          console.log(r);
          P = false;
          continue;
        }
        const o = {
          _id: s.key,
          data: r,
          type: "leaf"
        };
        A.push(o);
      } else if ("error" in s) {
        Logger("Saving chunk error: " + s.error);
        P = false;
      } else {
        const r = s.doc;
        if ("leaf" == r.type && r.data == R.get(s.key)) S++; else if ("leaf" == r.type) {
          Logger(`Hash collided on saving! If possible, please report the following string\nA:--${R.get(s.key)}--\nB:--${r.data}--`, LOG_LEVEL_NOTICE);
          Logger(`This document could not be saved:${_}`, LOG_LEVEL_NOTICE);
          P = false;
        }
      }
    }
  } while (N.length > 0);
  if (A.length > 0) try {
    const r = await s.localDatabase.bulkDocs(A);
    for (const o of r) if ("ok" in o) {
      const r = o.id, u = R.get(r);
      if ("undefined" == typeof u) {
        P = false;
        Logger(`Save failed.: ${_} (${o.id} rev:${o.rev})`, LOG_LEVEL_NOTICE);
        continue;
      }
      s.hashCaches.set(r, u);
      E++;
    } else if (409 == (null == o ? void 0 : o.status)) S++; else {
      Logger(`Save failed..: ${_} (${o.id} rev:${o.rev})`, LOG_LEVEL_NOTICE);
      Logger(o);
      P = false;
    }
  } catch (s) {
    Logger("Chunk save failed:", LOG_LEVEL_NOTICE);
    Logger(s, LOG_LEVEL_NOTICE);
    P = false;
  }
  if (P) {
    Logger(`Content saved:${_} ,chunks: ${w} (new:${E}, skip:${S}, cache:${k})`);
    const o = {
      children: b,
      _id: r._id,
      path: r.path,
      ctime: r.ctime,
      mtime: r.mtime,
      size: r.size,
      type: r.datatype
    };
    return null != (u = await runWithLock("file:" + g, false, (async () => {
      try {
        const r = await s.localDatabase.get(o._id);
        if (!r.type || "notes" == r.type || "newnote" == r.type || "plain" == r.type) o._rev = r._rev;
      } catch (s) {
        if (isErrorOfMissingDoc(s)) ; else throw s;
      }
      const u = await s.localDatabase.put(o, {
        force: true
      });
      if ("undefined" != typeof s.corruptedEntries[r._id]) delete s.corruptedEntries[r._id];
      if (u.ok) return u; else return false;
    }))) ? u : false;
  } else {
    Logger(`note could not saved:${_}`);
    return false;
  }
}

async function getDBEntryMeta(s, r, o, u = false) {
  if (!s.isTargetFile(r)) return false;
  const g = await s.path2id(r);
  try {
    let _ = null;
    if (o) _ = await s.localDatabase.get(g, o); else _ = await s.localDatabase.get(g);
    const b = "deleted" in _ ? _.deleted : void 0;
    if (!u && b) return false;
    if (_.type && "leaf" == _.type) return false;
    if (!_.type || _.type && "notes" == _.type || "newnote" == _.type || "plain" == _.type) {
      const s = _;
      let o = [], u = "plain";
      if ("newnote" == _.type || "plain" == _.type) {
        o = _.children;
        u = _.type;
      }
      const g = void 0;
      return {
        data: "",
        _id: s._id,
        path: r,
        ctime: s.ctime,
        mtime: s.mtime,
        size: s.size,
        _rev: _._rev,
        _conflicts: _._conflicts,
        children: o,
        datatype: u,
        deleted: b,
        type: u
      };
    }
  } catch (s) {
    if (isErrorOfMissingDoc(s)) return false;
    throw s;
  }
  return false;
}

async function getDBEntryFromMeta(s, r, o, u = false, g = true, _ = false) {
  const b = s.id2path(r._id, r);
  if (!s.isTargetFile(b)) return false;
  const w = stripAllPrefixes(b), E = "deleted" in r ? r.deleted : void 0;
  if (!r.type || r.type && "notes" == r.type) {
    const o = r, g = {
      data: o.data,
      path: o.path,
      _id: o._id,
      ctime: o.ctime,
      mtime: o.mtime,
      size: o.size,
      _rev: r._rev,
      _conflicts: r._conflicts,
      children: [],
      datatype: "newnote",
      deleted: E,
      type: "newnote"
    };
    if ("undefined" != typeof s.corruptedEntries[g._id]) delete s.corruptedEntries[g._id];
    if (u) {
      Logger("Simple doc");
      Logger(g);
    }
    return g;
  }
  if ("newnote" == r.type || "plain" == r.type) try {
    if (u) {
      Logger("Enhanced doc");
      Logger(r);
    }
    let _ = [];
    const b = Math.min(10, Math.ceil(r.children.length / 10)) + 1, S = s.settings.doNotPaceReplication ? () => {} : await globalConcurrencyController.acquire(b);
    try {
      if (s.settings.readChunksOnline) {
        const u = await s.collectChunks(r.children, false, g);
        if (u) for (const g of u) if (g && "leaf" == g.type) _.push(g.data); else {
          if (!o) {
            Logger(`Chunks of ${w} (${r._id}) are not valid.`, LOG_LEVEL_NOTICE);
            s.corruptedEntries[r._id] = r;
          }
          return false;
        } else {
          if (o) Logger(`Could not retrieve chunks of ${w} (${r._id}). we have to `, LOG_LEVEL_NOTICE);
          return false;
        }
      } else try {
        if (g) {
          _ = await Promise.all(r.children.map((r => s.getDBLeaf(r, g))));
          if (u) {
            Logger("Chunks:");
            Logger(_);
          }
        } else {
          const o = await s.localDatabase.allDocs({
            keys: r.children,
            include_docs: true
          });
          if (o.rows.some((s => "error" in s))) {
            const s = o.rows.filter((s => "error" in s)).map((s => s.key)).join(", ");
            Logger(`Could not retrieve chunks of ${w}(${r._id}). Chunks are missing:${s}`, LOG_LEVEL_NOTICE);
            return false;
          }
          if (o.rows.some((s => s.doc && "leaf" != s.doc.type))) {
            const s = o.rows.filter((s => s.doc && "leaf" != s.doc.type)).map((s => s.id)).join(", ");
            Logger(`Could not retrieve chunks of ${w}(${r._id}). corrupted chunks::${s}`, LOG_LEVEL_NOTICE);
            return false;
          }
          _ = o.rows.map((s => s.doc.data));
        }
      } catch (o) {
        Logger(`Something went wrong on reading chunks of ${w}(${r._id}) from database, see verbose info for detail.`, LOG_LEVEL_NOTICE);
        Logger(o, LOG_LEVEL_VERBOSE);
        s.corruptedEntries[r._id] = r;
        return false;
      }
    } finally {
      S();
    }
    const L = void 0, O = {
      data: _,
      path: r.path,
      _id: r._id,
      ctime: r.ctime,
      mtime: r.mtime,
      size: r.size,
      _rev: r._rev,
      children: r.children,
      datatype: r.type,
      _conflicts: r._conflicts,
      deleted: E,
      type: r.type
    };
    if (u) {
      Logger("therefore:");
      Logger(O);
    }
    if ("undefined" != typeof s.corruptedEntries[O._id]) delete s.corruptedEntries[O._id];
    return O;
  } catch (s) {
    if (isErrorOfMissingDoc(s)) {
      Logger(`Missing document content!, could not read ${w}(${r._id}) from database.`, LOG_LEVEL_NOTICE);
      return false;
    }
    Logger(`Something went wrong on reading ${w}(${r._id}) from database:`, LOG_LEVEL_NOTICE);
    Logger(s);
  }
  return false;
}

async function getDBEntry(s, r, o, u = false, g = true, _ = false) {
  const b = await getDBEntryMeta(s, r, o, _);
  if (b) return await getDBEntryFromMeta(s, b, o, u, g, _); else return false;
}

async function deleteDBEntry(s, r, o) {
  var u;
  if (!s.isTargetFile(r)) return false;
  const g = await s.path2id(r);
  try {
    return null != (u = await runWithLock("file:" + r, false, (async () => {
      let u = null;
      if (o) u = await s.localDatabase.get(g, o); else u = await s.localDatabase.get(g);
      const _ = o && "" != ("rev" in o ? o.rev : "");
      if (u.type && "leaf" == u.type) return false;
      if (!u.type || u.type && "notes" == u.type) {
        u._deleted = true;
        const o = await s.localDatabase.put(u);
        Logger(`Entry removed:${r} (${u._id}-${o.rev})`);
        if ("undefined" != typeof s.corruptedEntries[u._id]) delete s.corruptedEntries[u._id];
        return true;
      }
      if ("newnote" == u.type || "plain" == u.type) {
        if (_) u._deleted = true; else {
          u.deleted = true;
          u.mtime = Date.now();
          if (s.settings.deleteMetadataOfDeletedFiles) u._deleted = true;
        }
        const o = await s.localDatabase.put(u);
        Logger(`Entry removed:${r} (${u._id}-${o.rev})`);
        if ("undefined" != typeof s.corruptedEntries[u._id]) delete s.corruptedEntries[u._id];
        return true;
      } else return false;
    }))) ? u : false;
  } catch (s) {
    if (isErrorOfMissingDoc(s)) return false;
    throw s;
  }
}

async function deleteDBEntryPrefix(s, r) {
  let o = 0, u = 0;
  const g = [];
  do {
    const _ = await s.localDatabase.allDocs({
      include_docs: false,
      skip: o,
      limit: 100,
      conflicts: true
    });
    u = _.rows.length;
    if (u > 0) for (const o of _.rows) {
      const u = s.id2path(o.id, o.doc);
      if (u.startsWith(r)) {
        if (s.isTargetFile(u)) g.push(o.id);
      } else if (!o.id.startsWith("h:")) ;
    }
    o += u;
  } while (0 != u);
  let _ = 0, b = 0;
  for (const r of g) try {
    await runWithLock("file:" + r, false, (async () => {
      const o = await s.localDatabase.get(r);
      if ("newnote" == o.type || "plain" == o.type) {
        o.deleted = true;
        if (s.settings.deleteMetadataOfDeletedFiles) o._deleted = true;
        o.mtime = Date.now();
      } else o._deleted = true;
      await s.localDatabase.put(o);
    }));
    _++;
  } catch (s) {
    if (isErrorOfMissingDoc(s)) b++; else throw s;
  }
  Logger(`deleteDBEntryPrefix:deleted ${_} items, skipped ${b}`);
  return true;
}

async function ensureDatabaseIsCompatible(s, r, o, u) {
  const g = {
    _id: MILSTONE_DOCID,
    type: "milestoneinfo",
    created: new Date / 1,
    locked: false,
    accepted_nodes: [ o ],
    node_chunk_info: {
      [o]: u
    }
  }, _ = {
    ...g,
    ...await resolveWithIgnoreKnownError(s.get(MILSTONE_DOCID), g)
  };
  _.node_chunk_info = {
    ...g.node_chunk_info,
    ..._.node_chunk_info
  };
  const b = void 0;
  if (_.node_chunk_info[o].min != u.min || _.node_chunk_info[o].max != u.max || "undefined" == typeof _._rev) {
    _.node_chunk_info[o].min = u.min;
    _.node_chunk_info[o].max = u.max;
    await s.put(_);
  }
  let w = u.min, E = u.max;
  for (const s of _.accepted_nodes) {
    if (s == o) continue;
    if (s in _.node_chunk_info) {
      const r = _.node_chunk_info[s];
      w = Math.max(r.min, w);
      E = Math.min(r.max, E);
    } else {
      w = 0;
      E = 0;
    }
  }
  if (E < w) if (!r.ignoreVersionCheck) return "INCOMPATIBLE";
  if (_.locked) {
    if (-1 == _.accepted_nodes.indexOf(o)) {
      if (_.cleaned) return "NODE_CLEANED";
      return "NODE_LOCKED";
    }
    return "LOCKED";
  }
  return "OK";
}

var LiveSyncLocalDB = class {
  constructor(s, r) {
    this.isReady = false;
    this.xxhash64 = false;
    this.hashCaches = new LRUCache(10, 1e3);
    this.corruptedEntries = {};
    this.changeHandler = null;
    this.chunkVersion = -1;
    this.maxChunkVersion = -1;
    this.minChunkVersion = -1;
    this.needScanning = false;
    this.collectThrottleTimeout = null;
    this.collectThrottleQueuedIds = [];
    this.chunkCollectedCallbacks = {};
    this.auth = {
      username: "",
      password: ""
    };
    this.dbname = s;
    this.env = r;
    this.refreshSettings();
  }
  onunload() {
    var s, r;
    this.env.beforeOnUnload(this);
    null == (s = this.changeHandler) || s.cancel();
    null == (r = this.changeHandler) || r.removeAllListeners();
    this.localDatabase.removeAllListeners();
  }
  refreshSettings() {
    const s = this.env.getSettings();
    this.settings = s;
    this.hashCaches = new LRUCache(s.hashCacheMaxCount, s.hashCacheMaxAmount);
  }
  id2path(s, r, o) {
    return this.env.id2path(s, r, o);
  }
  async path2id(s, r) {
    return await this.env.path2id(s, r);
  }
  async close() {
    var s, r;
    Logger("Database closed (by close)");
    this.isReady = false;
    null == (s = this.changeHandler) || s.cancel();
    null == (r = this.changeHandler) || r.removeAllListeners();
    if (null != this.localDatabase) await this.localDatabase.close();
    this.env.onClose(this);
  }
  async initializeDatabase() {
    var s, r;
    await this.prepareHashFunctions();
    if (null != this.localDatabase) await this.localDatabase.close();
    null == (s = this.changeHandler) || s.cancel();
    null == (r = this.changeHandler) || r.removeAllListeners();
    this.localDatabase = null;
    this.localDatabase = this.env.createPouchDBInstance(this.dbname + "-livesync-v2", {
      auto_compaction: false,
      revs_limit: 100,
      deterministic_revs: true
    });
    await this.env.onInitializeDatabase(this);
    Logger("Opening Database...");
    Logger("Database info", LOG_LEVEL_VERBOSE);
    Logger(await this.localDatabase.info(), LOG_LEVEL_VERBOSE);
    this.localDatabase.on("close", (() => {
      var s;
      Logger("Database closed.");
      this.isReady = false;
      this.localDatabase.removeAllListeners();
      null == (s = this.env.getReplicator()) || s.closeReplication();
    }));
    const o = this.localDatabase.changes({
      since: "now",
      live: true,
      filter: s => "leaf" == s.type
    }).on("change", (s => {
      if (s.deleted) return;
      sendSignal(`leaf-${s.id}`);
    }));
    this.changeHandler = o;
    this.isReady = true;
    Logger("Database is now ready.");
    return true;
  }
  async prepareHashFunctions() {
    if (null != this.h32) return;
    try {
      const {h32ToString: s, h32Raw: r, h32: o, h64: u} = await e2();
      this.xxhash64 = u;
      this.xxhash32 = o;
      this.h32 = s;
      this.h32Raw = r;
      Logger("Newer xxhash has been initialised", LOG_LEVEL_VERBOSE);
    } catch (s) {
      Logger("Could not initialise xxhash v1", LOG_LEVEL_VERBOSE);
      this.xxhash64 = false;
      const {h32: r, h32Raw: o} = await xxhash_wasm_default();
      this.h32 = r;
      this.h32Raw = o;
      this.xxhash32 = s => o(writeString(s));
      Logger(s);
    }
  }
  async getDBLeafWithTimeout(s, r) {
    const o = Date.now(), u = this.hashCaches.revGet(s);
    if (u) return u;
    try {
      const r = await this.localDatabase.get(s);
      if ("leaf" == r.type) {
        this.hashCaches.set(s, r.data);
        return r.data;
      }
      throw new Error(`Corrupted chunk has been detected: ${s}`);
    } catch (u) {
      if (isErrorOfMissingDoc(u)) {
        if (r < o) throw new Error("Could not read chunk: Timed out: ${id}");
        await waitForSignal(`leaf-${s}`, 5e3);
        return this.getDBLeafWithTimeout(s, r);
      } else {
        Logger("Something went wrong while retrieving chunks");
        throw u;
      }
    }
  }
  getDBLeaf(s, r) {
    return this.getDBLeafWithTimeout(s, r ? Date.now() + LEAF_WAIT_TIMEOUT : 0);
  }
  async getDBEntryMeta(s, r, o = false) {
    return getDBEntryMeta(this, s, r, o);
  }
  async getDBEntry(s, r, o = false, u = true, g = false) {
    return getDBEntry(this, s, r, o, u, g);
  }
  async deleteDBEntry(s, r) {
    return deleteDBEntry(this, s, r);
  }
  async deleteDBEntryPrefix(s) {
    return deleteDBEntryPrefix(this, s);
  }
  async putDBEntry(s, r) {
    return putDBEntry(this, s, r);
  }
  async resetDatabase() {
    var s, r;
    null == (s = this.changeHandler) || s.cancel();
    null == (r = this.changeHandler) || r.removeAllListeners();
    this.env.getReplicator().closeReplication();
    await this.env.onResetDatabase(this);
    Logger("Database closed for reset Database.");
    this.isReady = false;
    await this.localDatabase.destroy();
    this.localDatabase = null;
    await this.initializeDatabase();
    Logger("Local Database Reset", LOG_LEVEL_NOTICE);
  }
  async sanCheck(s) {
    if ("plain" == s.type || "newnote" == s.type) {
      const r = s.children;
      Logger(`sancheck:checking:${s._id} : ${r.length}`, LOG_LEVEL_VERBOSE);
      try {
        const o = void 0;
        if ((await this.localDatabase.allDocs({
          keys: [ ...r ]
        })).rows.some((s => "error" in s))) {
          this.corruptedEntries[s._id] = s;
          Logger(`sancheck:corrupted:${s._id} : ${r.length}`, LOG_LEVEL_VERBOSE);
          return false;
        }
        return true;
      } catch (s) {
        Logger(s);
      }
    }
    return false;
  }
  isVersionUpgradable(s) {
    if (this.maxChunkVersion < 0) return false;
    if (this.minChunkVersion < 0) return false;
    if (this.maxChunkVersion > 0 && this.maxChunkVersion < s) return false;
    if (this.minChunkVersion > 0 && this.minChunkVersion > s) return false;
    return true;
  }
  isTargetFile(s) {
    const r = s.startsWith("i:") ? s.substring(2) : s;
    if (r.startsWith("ix:")) return true;
    if (r.startsWith("ps:")) return true;
    if (r.includes(":")) return false;
    if (this.settings.syncOnlyRegEx) {
      const s = new RegExp(this.settings.syncOnlyRegEx);
      if (!r.match(s)) return false;
    }
    if (this.settings.syncIgnoreRegEx) {
      const s = new RegExp(this.settings.syncIgnoreRegEx);
      if (r.match(s)) return false;
    }
    return true;
  }
  chunkCollected(s) {
    const r = s._id;
    if ("undefined" != typeof this.chunkCollectedCallbacks[r]) {
      for (const o of this.chunkCollectedCallbacks[r].ok) o(s);
      delete this.chunkCollectedCallbacks[r];
    } else Logger(`Collected handler of ${r} is missing, it might be error but perhaps it already timed out.`, LOG_LEVEL_VERBOSE);
  }
  async collectChunks(s, r = false, o) {
    const u = await this.collectChunksWithCache(s), g = void 0;
    if (0 == u.filter((s => !s.chunk)).map((s => s.id)).length) return u.map((s => s.chunk));
    const _ = s.map((s => new Promise(((r, o) => {
      if ("undefined" == typeof this.chunkCollectedCallbacks[s]) this.chunkCollectedCallbacks[s] = {
        ok: [],
        failed: () => {
          delete this.chunkCollectedCallbacks[s];
          o(new Error("Failed to collect one of chunks"));
        }
      };
      this.chunkCollectedCallbacks[s].ok.push((s => {
        r(s);
      }));
    }))));
    this.collectThrottleQueuedIds = [ ...new Set([ ...this.collectThrottleQueuedIds, ...s ]) ];
    this.execCollect();
    const b = void 0;
    return await Promise.all(_);
  }
  execCollect() {
    runWithLock("execCollect", true, (async () => {
      do {
        const s = this.settings.minimumIntervalOfReadChunksOnline, r = Date.now(), o = this.collectThrottleQueuedIds.splice(0, this.settings.concurrencyOfReadChunksOnline);
        if (0 == o.length) return;
        try {
          const s = await this.collectChunksInternal(o, false);
          if (s) {
            this.collectThrottleQueuedIds = this.collectThrottleQueuedIds.filter((r => !s.some((s => s._id == r))));
            for (const r of s) this.chunkCollected(r);
          } else {
            Logger("Could not retrieve chunks", LOG_LEVEL_NOTICE);
            for (const s of o) if (s in this.chunkCollectedCallbacks) this.chunkCollectedCallbacks[s].failed();
          }
        } catch (s) {
          Logger("Exception raised while retrieving chunks", LOG_LEVEL_NOTICE);
          Logger(s, LOG_LEVEL_VERBOSE);
          for (const s of o) if (s in this.chunkCollectedCallbacks) this.chunkCollectedCallbacks[s].failed();
        }
        const u = void 0, g = s - (Date.now() - r);
        if (0 == this.collectThrottleQueuedIds.length) return;
        await delay(g < 0 ? 0 : g);
      } while (this.collectThrottleQueuedIds.length > 0);
    })).then((() => {}));
  }
  async collectChunksInternal(s, r = false) {
    const o = await this.collectChunksWithCache(s), u = o.filter((s => !s.chunk)).map((s => s.id));
    if (0 == u.length) return o.map((s => s.chunk));
    const g = await this.env.getReplicator().fetchRemoteChunks(u, r);
    if (false == g) return false;
    const _ = g.length;
    g.forEach((s => this.hashCaches.set(s._id, s.data)));
    await this.localDatabase.bulkDocs(g, {
      new_edits: false
    });
    let b = 0;
    function findChunk(s) {
      if (!g) throw Error("Chunk collecting error");
      const r = b;
      for (let o = 0; o < _; o++) {
        const u = (r + o) % _;
        b = o;
        if (g[u]._id == s) return g[u];
      }
      throw Error("Chunk collecting error");
    }
    return o.map((s => !s.chunk ? findChunk(s.id) : s.chunk));
  }
  async* findEntries(s, r, o) {
    const u = 100;
    let g = s, _ = this.localDatabase.allDocs({
      limit: u,
      startkey: g,
      endkey: r,
      include_docs: true,
      ...o
    });
    do {
      const s = await _;
      if (0 === s.rows.length) break;
      g = `${s.rows[s.rows.length - 1].id}􏿿`;
      _ = this.localDatabase.allDocs({
        limit: u,
        startkey: g,
        endkey: r,
        include_docs: true,
        ...o
      });
      for (const r of s.rows) {
        const s = r.doc;
        if (!("type" in s)) continue;
        if ("newnote" == s.type || "plain" == s.type) yield s;
      }
    } while ("" != g);
  }
  async* findAllDocs(s) {
    const r = this.findEntries("", "h:", null != s ? s : {}), o = this.findEntries("h:􏿿", "", null != s ? s : {});
    for await (const s of r) yield s;
    for await (const s of o) yield s;
  }
  async* findEntryNames(s, r, o) {
    const u = 100;
    let g = s, _ = this.localDatabase.allDocs({
      limit: u,
      startkey: g,
      endkey: r,
      ...o
    });
    do {
      const s = await _;
      if (0 == s.rows.length) {
        g = "";
        break;
      }
      g = `${s.rows[s.rows.length - 1].key}􏿿`;
      _ = this.localDatabase.allDocs({
        limit: u,
        startkey: g,
        endkey: r,
        ...o
      });
      for (const r of s.rows) yield r.id;
    } while ("" != g);
  }
  async* findAllDocNames(s) {
    const r = [ this.findEntryNames("", "h:", null != s ? s : {}), this.findEntryNames("h:􏿿", "i:", null != s ? s : {}), this.findEntryNames("i:􏿿", "ix:", null != s ? s : {}), this.findEntryNames("ix:􏿿", "ps:", null != s ? s : {}), this.findEntryNames("ps:􏿿", "", null != s ? s : {}) ];
    for (const s of r) for await (const r of s) {
      if (r.startsWith("_")) continue;
      if (r == VERSIONINFO_DOCID) continue;
      yield r;
    }
  }
  async* findAllNormalDocs(s) {
    const r = [ this.findEntries("", "h:", null != s ? s : {}), this.findEntries("h:􏿿", "i:", null != s ? s : {}), this.findEntries("i:􏿿", "ix:", null != s ? s : {}), this.findEntries("ix:􏿿", "ps:", null != s ? s : {}), this.findEntries("ps:􏿿", "", null != s ? s : {}) ];
    for (const s of r) for await (const r of s) {
      if (r._id.startsWith("_")) continue;
      if ("newnote" != r.type && "plain" != r.type) continue;
      yield r;
    }
  }
  getRaw(s, r) {
    return this.localDatabase.get(s, r || {});
  }
  removeRaw(s, r, o) {
    return this.localDatabase.remove(s, r, o || {});
  }
  putRaw(s, r) {
    return this.localDatabase.put(s, r || {});
  }
  allDocsRaw(s) {
    return this.localDatabase.allDocs(s);
  }
  bulkDocsRaw(s, r) {
    return this.localDatabase.bulkDocs(s, r || {});
  }
  async collectChunksWithCache(s) {
    const r = s.map((s => this.hashCaches.has(s) ? {
      id: s,
      chunk: this.hashCaches.get(s)
    } : {
      id: s,
      chunk: false
    })), o = r.filter((s => false === s.chunk));
    if (o.length > 0) {
      const s = await this.localDatabase.allDocs({
        keys: o.map((s => s.id)),
        include_docs: true
      }), u = s.rows.filter((s => !("error" in s))).map((s => s.doc)), g = s.rows.filter((s => "error" in s)).map((s => s.key)), _ = void 0, b = (await this.localDatabase.allDocs({
        keys: g.map((s => `_local/${s}`)),
        include_docs: true
      })).rows.filter((s => !("error" in s))).map((s => ({
        ...s.doc,
        _id: s.id.substring(7)
      }))), w = [ ...u, ...b ].reduce(((s, r) => ({
        ...s,
        [r._id]: r.data
      })), {});
      for (const s of u) this.hashCaches.set(s._id, s.data);
      const E = void 0;
      return r.map((s => ({
        id: s.id,
        chunk: false !== s.chunk ? s.chunk : s.id in w ? w[s.id] : false
      }))).map((s => ({
        id: s.id,
        chunk: false !== s.chunk ? {
          _id: s.id,
          data: s.chunk,
          type: "leaf"
        } : false
      })));
    } else return r.map((s => ({
      id: s.id,
      chunk: {
        _id: s.id,
        data: s.chunk,
        type: "leaf"
      }
    })));
  }
}, currentVersionRange = {
  min: 0,
  max: 2,
  current: 2
};

async function* genReplication(s, r) {
  const o = [];
  let locker = () => Promise.resolve(), unlock = () => {
    locker = () => new Promise((s => unlock = s));
  };
  unlock();
  const push = function(s) {
    o.push(s);
    unlock();
  };
  s.on("complete", (s => push([ "complete", s ])));
  s.on("change", (s => push([ "change", s ])));
  s.on("active", (() => push([ "active" ])));
  s.on("denied", (s => push([ "denied", s ])));
  s.on("error", (s => push([ "error", s ])));
  s.on("paused", (s => push([ "paused", s ])));
  s.then((() => push([ "finally" ]))).catch((() => push([ "finally" ])));
  try {
    e: for (;;) {
      const s = o.shift();
      if (s) {
        yield s;
        if ("finally" == s[0]) break;
        continue;
      } else {
        const dx = async () => {
          await locker();
          return true;
        };
        for (;;) {
          const timeout = async () => {
            await delay(100);
            return false;
          }, s = void 0;
          if (await Promise.race([ dx(), timeout() ])) continue e;
          if (r.aborted) break e;
        }
      }
    }
  } finally {
    s.cancel();
  }
}

var LiveSyncDBReplicator = class {
  constructor(s) {
    this.syncStatus = "NOT_CONNECTED";
    this.docArrived = 0;
    this.docSent = 0;
    this.lastSyncPullSeq = 0;
    this.maxPullSeq = 0;
    this.lastSyncPushSeq = 0;
    this.maxPushSeq = 0;
    this.originalSetting = null;
    this.nodeid = "";
    this.remoteLocked = false;
    this.remoteCleaned = false;
    this.remoteLockedAndDeviceNotAccepted = false;
    this.updateInfo = () => {
      this.env.replicationStat.set({
        sent: this.docSent,
        arrived: this.docArrived,
        maxPullSeq: this.maxPullSeq,
        maxPushSeq: this.maxPushSeq,
        lastSyncPullSeq: this.lastSyncPullSeq,
        lastSyncPushSeq: this.lastSyncPushSeq,
        syncStatus: this.syncStatus
      });
    };
    this.env = s;
    this.initializeDatabaseForReplication();
    this.env.getDatabase().on("close", (() => {
      this.closeReplication();
    }));
  }
  async initializeDatabaseForReplication() {
    const s = this.env.getDatabase();
    try {
      const r = await resolveWithIgnoreKnownError(s.get(NODEINFO_DOCID), {
        _id: NODEINFO_DOCID,
        type: "nodeinfo",
        nodeid: "",
        v20220607: true
      });
      if ("" == r.nodeid) {
        r.nodeid = Math.random().toString(36).slice(-10);
        await s.put(r);
      }
      this.nodeid = r.nodeid;
      await putDesignDocuments(s);
    } catch (s) {
      Logger(s);
      return false;
    }
  }
  async migrate(s, r) {
    Logger(`Database updated from ${s} to ${r}`, LOG_LEVEL_NOTICE);
    return true;
  }
  terminateSync() {
    if (!this.controller) return;
    this.controller.abort();
    this.controller = null;
  }
  async openReplication(s, r, o, u = false) {
    await this.initializeDatabaseForReplication();
    if (r) this.openContinuousReplication(s, o, false); else return this.openOneShotReplication(s, o, false, "sync", u);
  }
  replicationActivated(s) {
    this.syncStatus = "CONNECTED";
    this.updateInfo();
    Logger("Replication activated", s ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "sync");
  }
  async replicationChangeDetected(s, r, o, u) {
    try {
      if ("pull" == s.direction) {
        await this.env.processReplication(s.change.docs);
        this.docArrived += s.change.docs.length;
      } else this.docSent += s.change.docs.length;
      if (r) {
        const s = this.maxPullSeq, r = this.maxPushSeq, g = this.lastSyncPullSeq, _ = this.lastSyncPushSeq, b = 0 == _ ? "" : _ >= r ? " (LIVE)" : ` (${r - _})`, w = 0 == g ? "" : g >= s ? " (LIVE)" : ` (${s - g})`;
        Logger(`↑${this.docSent - o}${b} ↓${this.docArrived - u}${w}`, LOG_LEVEL_NOTICE, "sync");
      }
      this.updateInfo();
    } catch (s) {
      Logger("Replication callback error", LOG_LEVEL_NOTICE, "sync");
      Logger(s, LOG_LEVEL_NOTICE);
    }
  }
  replicationCompleted(s) {
    this.syncStatus = "COMPLETED";
    this.updateInfo();
    Logger("Replication completed", s ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, s ? "sync" : "");
    this.terminateSync();
  }
  replicationDenied(s) {
    this.syncStatus = "ERRORED";
    this.updateInfo();
    this.terminateSync();
    Logger("Replication denied", LOG_LEVEL_NOTICE, "sync");
    Logger(s);
  }
  replicationErrored(s) {
    this.syncStatus = "ERRORED";
    this.terminateSync();
    this.updateInfo();
    Logger("Replication error", LOG_LEVEL_NOTICE, "sync");
    Logger(s);
  }
  replicationPaused() {
    this.syncStatus = "PAUSED";
    this.updateInfo();
    Logger("Replication paused", LOG_LEVEL_VERBOSE, "sync");
  }
  async processSync(s, r, o, u, g, _, b = true) {
    const w = new AbortController;
    if (this.controller) this.controller.abort();
    this.controller = w;
    const E = genReplication(s, w.signal);
    try {
      for await (const [s, b] of E) {
        const w = await globalConcurrencyController.tryAcquire(1, REPLICATION_BUSY_TIMEOUT);
        if (false === w) {
          Logger("Replication stopped for busy.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "sync");
          return "FAILED";
        }
        w();
        switch (s) {
         case "change":
          if ("direction" in b) {
            if ("pull" == b.direction) this.lastSyncPullSeq = Number(`${b.change.last_seq}`.split("-")[0]); else this.lastSyncPushSeq = Number(`${b.change.last_seq}`.split("-")[0]);
            await this.replicationChangeDetected(b, r, o, u);
          } else if ("pullOnly" == g) {
            this.lastSyncPullSeq = Number(`${b.last_seq}`.split("-")[0]);
            await this.replicationChangeDetected({
              direction: "pull",
              change: b
            }, r, o, u);
          } else if ("pushOnly" == g) {
            this.lastSyncPushSeq = Number(`${b.last_seq}`.split("-")[0]);
            this.updateInfo();
            await this.replicationChangeDetected({
              direction: "push",
              change: b
            }, r, o, u);
          }
          if (_) if (this.docSent - o + (this.docArrived - u) > 2 * this.originalSetting.batch_size) return "NEED_RESURRECT";
          break;

         case "complete":
          this.replicationCompleted(r);
          return "DONE";

         case "active":
          this.replicationActivated(r);
          break;

         case "denied":
          this.replicationDenied(b);
          return "FAILED";

         case "error":
          this.replicationErrored(b);
          Logger("Replication stopped.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "sync");
          if (this.env.getLastPostFailedBySize()) {
            if (b && 413 == (null == b ? void 0 : b.status)) {
              Logger("Self-hosted LiveSync has detected some remote-database-incompatible chunks that exist in the local database. It means synchronization with the server had been no longer possible.\n\nThe problem may be caused by chunks that were created with the faulty version or by switching platforms of the database.\nTo solve the circumstance, configure the remote database correctly or we have to rebuild both local and remote databases.", LOG_LEVEL_NOTICE);
              return;
            }
            return "NEED_RETRY";
          } else {
            Logger("Replication error", LOG_LEVEL_NOTICE, "sync");
            Logger(b);
          }
          return "FAILED";

         case "paused":
          this.replicationPaused();
          break;

         case "finally":
          break;

         default:
          Logger(`Unexpected synchronization status:${JSON.stringify(b)}`);
        }
      }
      if (b) return "DONE";
      return "CANCELLED";
    } catch (s) {
      Logger("Unexpected synchronization exception");
      Logger(s, LOG_LEVEL_VERBOSE);
    } finally {
      this.terminateSync();
      this.controller = null;
    }
  }
  async openOneShotReplication(s, r, o, u, g = false) {
    if (null != this.controller) {
      Logger("Replication is already in progress.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "sync");
      return false;
    }
    const _ = this.env.getDatabase();
    Logger(`OneShot Sync begin... (${u})`);
    const b = await this.checkReplicationConnectivity(s, false, o, r, g);
    if (false === b) {
      Logger("Could not connect to server.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "sync");
      return false;
    }
    this.maxPullSeq = Number(`${b.info.update_seq}`.split("-")[0]);
    this.maxPushSeq = Number(`${(await _.info()).update_seq}`.split("-")[0]);
    if (r) Logger("Looking for the point last synchronized point.", LOG_LEVEL_NOTICE, "sync");
    const {db: w, syncOptionBase: E} = b;
    this.syncStatus = "STARTED";
    this.updateInfo();
    const S = this.docArrived, L = this.docSent;
    if (!o) this.originalSetting = s;
    this.terminateSync();
    let O;
    if ("sync" == u) O = _.sync(w, {
      checkpoint: "target",
      ...E
    }); else if ("pullOnly" == u) O = _.replicate.from(w, {
      checkpoint: "target",
      ...E,
      ...s.readChunksOnline ? {
        filter: "replicate/pull"
      } : {}
    }); else if ("pushOnly" == u) O = _.replicate.to(w, {
      checkpoint: "target",
      ...E,
      ...s.readChunksOnline ? {
        filter: "replicate/push"
      } : {}
    });
    const D = await this.processSync(O, r, L, S, u, o, false);
    if ("DONE" == D) return true;
    if ("CANCELLED" == D) return false;
    if ("FAILED" == D) return false;
    if ("NEED_RESURRECT" == D) {
      this.terminateSync();
      return await this.openOneShotReplication(this.originalSetting, r, false, u, g);
    }
    if ("NEED_RETRY" == D) {
      const o = JSON.parse(JSON.stringify(s));
      o.batch_size = Math.ceil(o.batch_size / 2) + 2;
      o.batches_limit = Math.ceil(o.batches_limit / 2) + 2;
      if (o.batch_size <= 5 && o.batches_limit <= 5) {
        Logger("We can't replicate more lower value.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
        return false;
      } else {
        Logger(`Retry with lower batch size:${o.batch_size}/${o.batches_limit}`, r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
        return await this.openOneShotReplication(o, r, true, u, g);
      }
    }
    return false;
  }
  replicateAllToServer(s, r) {
    return this.openOneShotReplication(s, null != r ? r : false, false, "pushOnly");
  }
  replicateAllFromServer(s, r) {
    return this.openOneShotReplication(s, r, false, "pullOnly");
  }
  async checkReplicationConnectivity(s, r, o, u, g = false) {
    if ("" != s.versionUpFlash) {
      Logger("Open settings and check message, please.", LOG_LEVEL_NOTICE);
      return false;
    }
    const _ = s.couchDB_URI + ("" == s.couchDB_DBNAME ? "" : "/" + s.couchDB_DBNAME);
    if (null != this.controller) {
      Logger("Another replication running.");
      return false;
    }
    const b = await this.connectRemoteCouchDBWithSetting(s, this.env.getIsMobile(), true);
    if ("string" == typeof b) {
      Logger(`Could not connect to ${_}: ${b}`, u ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
      return false;
    }
    if (!o) {
      await putDesignDocuments(b.db);
      if (!await checkRemoteVersion(b.db, this.migrate.bind(this), VER)) {
        Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL_NOTICE);
        return false;
      }
      this.remoteCleaned = false;
      this.remoteLocked = false;
      this.remoteLockedAndDeviceNotAccepted = false;
      const r = await ensureDatabaseIsCompatible(b.db, s, this.nodeid, currentVersionRange);
      if ("INCOMPATIBLE" == r) {
        Logger("The remote database has no compatibility with the running version. Please upgrade the plugin.", LOG_LEVEL_NOTICE);
        return false;
      } else if ("NODE_LOCKED" == r) {
        Logger("The remote database has been rebuilt or corrupted since we have synchronized last time. Fetch rebuilt DB, explicit unlocking or chunk clean-up is required.", LOG_LEVEL_NOTICE);
        this.remoteLockedAndDeviceNotAccepted = true;
        this.remoteLocked = true;
        return false;
      } else if ("LOCKED" == r) this.remoteLocked = true; else if ("NODE_CLEANED" == r) if (g) this.remoteLocked = true; else {
        Logger("The remote database has been cleaned up. Fetch rebuilt DB, explicit unlocking or chunk clean-up is required.", LOG_LEVEL_NOTICE);
        this.remoteLockedAndDeviceNotAccepted = true;
        this.remoteLocked = true;
        this.remoteCleaned = true;
        return false;
      }
    }
    const w = {
      batches_limit: s.batches_limit,
      batch_size: s.batch_size
    };
    if (s.readChunksOnline) {
      w.push = {
        filter: "replicate/push"
      };
      w.pull = {
        filter: "replicate/pull"
      };
    }
    const E = r ? {
      live: true,
      retry: true,
      heartbeat: s.useTimeouts ? false : 3e4,
      ...w
    } : {
      ...w
    };
    return {
      db: b.db,
      info: b.info,
      syncOptionBase: w,
      syncOption: E
    };
  }
  async openContinuousReplication(s, r, o) {
    if (null != this.controller) {
      Logger("Replication is already in progress.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
      return;
    }
    const u = this.env.getDatabase();
    Logger("Before LiveSync, start OneShot once...");
    if (await this.openOneShotReplication(s, r, false, "pullOnly")) {
      Logger("LiveSync begin...");
      const g = await this.checkReplicationConnectivity(s, true, true, r);
      if (false === g) {
        Logger("Could not connect to server.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
        return false;
      }
      if (r) Logger("Looking for the point last synchronized point.", LOG_LEVEL_NOTICE, "sync");
      const {db: _, syncOption: b} = g;
      this.syncStatus = "STARTED";
      this.maxPullSeq = Number(`${g.info.update_seq}`.split("-")[0]);
      this.maxPushSeq = Number(`${(await u.info()).update_seq}`.split("-")[0]);
      this.updateInfo();
      const w = this.docArrived, E = this.docSent;
      if (!o) this.originalSetting = s;
      this.terminateSync();
      const S = u.sync(_, {
        ...b,
        pull: {
          checkpoint: "target"
        },
        push: {
          checkpoint: "source"
        }
      }), L = "sync", O = await this.processSync(S, r, E, w, L, o);
      if ("DONE" == O) return true;
      if ("FAILED" == O) return false;
      if ("NEED_RESURRECT" == O) {
        this.terminateSync();
        return await this.openContinuousReplication(this.originalSetting, r, false);
      }
      if ("NEED_RETRY" == O) {
        const o = JSON.parse(JSON.stringify(s));
        o.batch_size = Math.ceil(o.batch_size / 2) + 2;
        o.batches_limit = Math.ceil(o.batches_limit / 2) + 2;
        if (o.batch_size <= 5 && o.batches_limit <= 5) {
          Logger("We can't replicate more lower value.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
          return false;
        } else {
          Logger(`Retry with lower batch size:${o.batch_size}/${o.batches_limit}`, r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
          return await this.openContinuousReplication(o, r, true);
        }
      }
    }
  }
  closeReplication() {
    if (!this.controller) return;
    this.controller.abort();
    this.controller = null;
    this.syncStatus = "CLOSED";
    Logger("Replication closed");
    this.updateInfo();
  }
  async tryResetRemoteDatabase(s) {
    this.closeReplication();
    const r = await this.connectRemoteCouchDBWithSetting(s, this.env.getIsMobile(), true);
    if ("string" == typeof r) return;
    try {
      await r.db.destroy();
      Logger("Remote Database Destroyed", LOG_LEVEL_NOTICE);
      await this.tryCreateRemoteDatabase(s);
    } catch (s) {
      Logger("Something happened on Remote Database Destroy:", LOG_LEVEL_NOTICE);
      Logger(s, LOG_LEVEL_NOTICE);
    }
  }
  async tryCreateRemoteDatabase(s) {
    this.closeReplication();
    const r = void 0;
    if ("string" == typeof await this.connectRemoteCouchDBWithSetting(s, this.env.getIsMobile(), true)) return;
    Logger("Remote Database Created or Connected", LOG_LEVEL_NOTICE);
  }
  async markRemoteLocked(s, r, o) {
    const u = s.couchDB_URI + ("" == s.couchDB_DBNAME ? "" : "/" + s.couchDB_DBNAME), g = await this.connectRemoteCouchDBWithSetting(s, this.env.getIsMobile(), true);
    if ("string" == typeof g) {
      Logger(`could not connect to ${u}:${g}`, LOG_LEVEL_NOTICE);
      return;
    }
    if (!await checkRemoteVersion(g.db, this.migrate.bind(this), VER)) {
      Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL_NOTICE);
      return;
    }
    const _ = {
      _id: MILSTONE_DOCID,
      type: "milestoneinfo",
      created: new Date / 1,
      locked: r,
      cleaned: o,
      accepted_nodes: [ this.nodeid ],
      node_chunk_info: {
        [this.nodeid]: currentVersionRange
      }
    }, b = {
      ..._,
      ...await resolveWithIgnoreKnownError(g.db.get(MILSTONE_DOCID), _)
    };
    b.node_chunk_info = {
      ..._.node_chunk_info,
      ...b.node_chunk_info
    };
    b.accepted_nodes = [ this.nodeid ];
    b.locked = r;
    b.cleaned = b.cleaned || o;
    if (r) Logger("Lock remote database to prevent data corruption", LOG_LEVEL_NOTICE); else Logger("Unlock remote database to prevent data corruption", LOG_LEVEL_NOTICE);
    await g.db.put(b);
  }
  async markRemoteResolved(s) {
    const r = s.couchDB_URI + ("" == s.couchDB_DBNAME ? "" : "/" + s.couchDB_DBNAME), o = await this.connectRemoteCouchDBWithSetting(s, this.env.getIsMobile(), true);
    if ("string" == typeof o) {
      Logger(`could not connect to ${r}:${o}`, LOG_LEVEL_NOTICE);
      return;
    }
    if (!await checkRemoteVersion(o.db, this.migrate.bind(this), VER)) {
      Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL_NOTICE);
      return;
    }
    const u = {
      _id: MILSTONE_DOCID,
      type: "milestoneinfo",
      created: new Date / 1,
      locked: false,
      accepted_nodes: [ this.nodeid ],
      node_chunk_info: {
        [this.nodeid]: currentVersionRange
      }
    }, g = {
      ...u,
      ...await resolveWithIgnoreKnownError(o.db.get(MILSTONE_DOCID), u)
    };
    g.node_chunk_info = {
      ...u.node_chunk_info,
      ...g.node_chunk_info
    };
    g.accepted_nodes = Array.from(new Set([ ...g.accepted_nodes, this.nodeid ]));
    Logger("Mark this device as 'resolved'.", LOG_LEVEL_NOTICE);
    await o.db.put(g);
  }
  connectRemoteCouchDBWithSetting(s, r, o, u) {
    if (s.encrypt && "" == s.passphrase && !s.permitEmptyPassphrase) return "Empty passphrases cannot be used without explicit permission";
    return this.env.connectRemoteCouchDB(s.couchDB_URI + ("" == s.couchDB_DBNAME ? "" : "/" + s.couchDB_DBNAME), {
      username: s.couchDB_USER,
      password: s.couchDB_PASSWORD
    }, s.disableRequestURI || r, s.encrypt ? s.passphrase : s.encrypt, s.useDynamicIterationCount, o, u);
  }
  async fetchRemoteChunks(s, r) {
    const o = await this.connectRemoteCouchDBWithSetting(this.env.getSettings(), this.env.getIsMobile(), false, true);
    if ("string" == typeof o) {
      Logger(`Could not connect to server.${o} `, r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "fetch");
      return false;
    }
    const u = await o.db.allDocs({
      keys: s,
      include_docs: true
    });
    if (u.rows.some((s => "error" in s))) {
      Logger("Some chunks are not exists both on remote and local database.", r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "fetch");
      return false;
    }
    const g = void 0;
    return u.rows.map((s => s.doc));
  }
}, instanceOfAny = (s, r) => r.some((r => s instanceof r)), idbProxyableTypes, cursorAdvanceMethods;

function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [ IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction ]);
}

function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [ IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey ]);
}

var cursorRequestMap = new WeakMap, transactionDoneMap = new WeakMap, transactionStoreNamesMap = new WeakMap, transformCache = new WeakMap, reverseTransformCache = new WeakMap;

function promisifyRequest(s) {
  const r = new Promise(((r, o) => {
    const unlisten = () => {
      s.removeEventListener("success", success);
      s.removeEventListener("error", error);
    }, success = () => {
      r(wrap(s.result));
      unlisten();
    }, error = () => {
      o(s.error);
      unlisten();
    };
    s.addEventListener("success", success);
    s.addEventListener("error", error);
  }));
  r.then((r => {
    if (r instanceof IDBCursor) cursorRequestMap.set(r, s);
  })).catch((() => {}));
  reverseTransformCache.set(r, s);
  return r;
}

function cacheDonePromiseForTransaction(s) {
  if (transactionDoneMap.has(s)) return;
  const r = new Promise(((r, o) => {
    const unlisten = () => {
      s.removeEventListener("complete", complete);
      s.removeEventListener("error", error);
      s.removeEventListener("abort", error);
    }, complete = () => {
      r();
      unlisten();
    }, error = () => {
      o(s.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    s.addEventListener("complete", complete);
    s.addEventListener("error", error);
    s.addEventListener("abort", error);
  }));
  transactionDoneMap.set(s, r);
}

var idbProxyTraps = {
  get(s, r, o) {
    if (s instanceof IDBTransaction) {
      if ("done" === r) return transactionDoneMap.get(s);
      if ("objectStoreNames" === r) return s.objectStoreNames || transactionStoreNamesMap.get(s);
      if ("store" === r) return o.objectStoreNames[1] ? void 0 : o.objectStore(o.objectStoreNames[0]);
    }
    return wrap(s[r]);
  },
  set(s, r, o) {
    s[r] = o;
    return true;
  },
  has(s, r) {
    if (s instanceof IDBTransaction && ("done" === r || "store" === r)) return true;
    return r in s;
  }
};

function replaceTraps(s) {
  idbProxyTraps = s(idbProxyTraps);
}

function wrapFunction(s) {
  if (s === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) return function(r, ...o) {
    const u = s.call(unwrap(this), r, ...o);
    transactionStoreNamesMap.set(u, r.sort ? r.sort() : [ r ]);
    return wrap(u);
  };
  if (getCursorAdvanceMethods().includes(s)) return function(...r) {
    s.apply(unwrap(this), r);
    return wrap(cursorRequestMap.get(this));
  };
  return function(...r) {
    return wrap(s.apply(unwrap(this), r));
  };
}

function transformCachableValue(s) {
  if ("function" == typeof s) return wrapFunction(s);
  if (s instanceof IDBTransaction) cacheDonePromiseForTransaction(s);
  if (instanceOfAny(s, getIdbProxyableTypes())) return new Proxy(s, idbProxyTraps);
  return s;
}

function wrap(s) {
  if (s instanceof IDBRequest) return promisifyRequest(s);
  if (transformCache.has(s)) return transformCache.get(s);
  const r = transformCachableValue(s);
  if (r !== s) {
    transformCache.set(s, r);
    reverseTransformCache.set(r, s);
  }
  return r;
}

var unwrap = s => reverseTransformCache.get(s);

function openDB(s, r, {blocked: o, upgrade: u, blocking: g, terminated: _} = {}) {
  const b = indexedDB.open(s, r), w = wrap(b);
  if (u) b.addEventListener("upgradeneeded", (s => {
    u(wrap(b.result), s.oldVersion, s.newVersion, wrap(b.transaction), s);
  }));
  if (o) b.addEventListener("blocked", (s => o(s.oldVersion, s.newVersion, s)));
  w.then((s => {
    if (_) s.addEventListener("close", (() => _()));
    if (g) s.addEventListener("versionchange", (s => g(s.oldVersion, s.newVersion, s)));
  })).catch((() => {}));
  return w;
}

function deleteDB(s, {blocked: r} = {}) {
  const o = indexedDB.deleteDatabase(s);
  if (r) o.addEventListener("blocked", (s => r(s.oldVersion, s)));
  return wrap(o).then((() => {}));
}

var readMethods = [ "get", "getKey", "getAll", "getAllKeys", "count" ], writeMethods = [ "put", "add", "delete", "clear" ], cachedMethods = new Map;

function getMethod(s, r) {
  if (!(s instanceof IDBDatabase && !(r in s) && "string" == typeof r)) return;
  if (cachedMethods.get(r)) return cachedMethods.get(r);
  const o = r.replace(/FromIndex$/, ""), u = r !== o, g = writeMethods.includes(o);
  if (!(o in (u ? IDBIndex : IDBObjectStore).prototype) || !(g || readMethods.includes(o))) return;
  const method = async function(s, ...r) {
    const _ = this.transaction(s, g ? "readwrite" : "readonly");
    let b = _.store;
    if (u) b = b.index(r.shift());
    return (await Promise.all([ b[o](...r), g && _.done ]))[0];
  };
  cachedMethods.set(r, method);
  return method;
}

replaceTraps((s => ({
  ...s,
  get: (r, o, u) => getMethod(r, o) || s.get(r, o, u),
  has: (r, o) => !!getMethod(r, o) || s.has(r, o)
})));

var databaseCache = {}, OpenKeyValueDatabase = async s => {
  if (s in databaseCache) {
    databaseCache[s].close();
    delete databaseCache[s];
  }
  const r = s, o = openDB(s, 1, {
    upgrade(s) {
      s.createObjectStore(r);
    }
  });
  let u = null;
  u = await o;
  databaseCache[s] = u;
  return {
    get: s => u.get(r, s),
    set: (s, o) => u.put(r, o, s),
    del: s => u.delete(r, s),
    clear: () => u.clear(r),
    keys: (s, o) => u.getAllKeys(r, s, o),
    close() {
      delete databaseCache[s];
      return u.close();
    },
    async destroy() {
      delete databaseCache[s];
      u.close();
      await deleteDB(s);
    }
  };
}, HiddenFileSync = class extends LiveSyncCommands {
  constructor() {
    super(...arguments);
    this.periodicInternalFileScanProcessor = new PeriodicProcessor(this.plugin, (async () => this.settings.syncInternalFiles && this.localDatabase.isReady && await this.syncInternalFilesAndDatabase("push", false)));
    this.confirmPopup = null;
    this.procInternalFiles = [];
    this.recentProcessedInternalFiles = [];
  }
  get kvDB() {
    return this.plugin.kvDB;
  }
  ensureDirectoryEx(s) {
    return this.plugin.ensureDirectoryEx(s);
  }
  getConflictedDoc(s, r) {
    return this.plugin.getConflictedDoc(s, r);
  }
  onunload() {
    var s;
    null == (s = this.periodicInternalFileScanProcessor) || s.disable();
  }
  onload() {
    this.plugin.addCommand({
      id: "livesync-scaninternal",
      name: "Sync hidden files",
      callback: () => {
        this.syncInternalFilesAndDatabase("safe", true);
      }
    });
  }
  async onInitializeDatabase(s) {
    if (this.settings.syncInternalFiles) try {
      Logger("Synchronizing hidden files...");
      await this.syncInternalFilesAndDatabase("push", s);
      Logger("Synchronizing hidden files done");
    } catch (s) {
      Logger("Synchronizing hidden files failed");
      Logger(s, LOG_LEVEL_VERBOSE);
    }
  }
  async beforeReplicate(s) {
    if (this.localDatabase.isReady && this.settings.syncInternalFiles && this.settings.syncInternalFilesBeforeReplication && !this.settings.watchInternalFileChanges) await this.syncInternalFilesAndDatabase("push", s);
  }
  async onResume() {
    var s;
    null == (s = this.periodicInternalFileScanProcessor) || s.disable();
    if (this.plugin.suspended) return;
    if (this.settings.syncInternalFiles) await this.syncInternalFilesAndDatabase("safe", false);
    this.periodicInternalFileScanProcessor.enable(this.settings.syncInternalFiles && this.settings.syncInternalFilesInterval ? 1e3 * this.settings.syncInternalFilesInterval : 0);
  }
  parseReplicationResultItem(s) {
    return false;
  }
  realizeSettingSyncMode() {
    var s;
    null == (s = this.periodicInternalFileScanProcessor) || s.disable();
    if (this.plugin.suspended) return;
    if (!this.plugin.isReady) return;
    this.periodicInternalFileScanProcessor.enable(this.settings.syncInternalFiles && this.settings.syncInternalFilesInterval ? 1e3 * this.settings.syncInternalFilesInterval : 0);
    return;
  }
  async execInternalFile() {
    await runWithLock("execInternal", false, (async () => {
      const s = [ ...this.procInternalFiles ];
      this.procInternalFiles = [];
      Logger(`Applying hidden ${s.length} files change...`);
      await this.syncInternalFilesAndDatabase("pull", false, false, s);
      Logger(`Applying hidden ${s.length} files changed`);
    }));
  }
  procInternalFile(s) {
    this.procInternalFiles.push(s);
    scheduleTask("procInternal", 500, (async () => {
      await this.execInternalFile();
    }));
  }
  async watchVaultRawEventsAsync(s) {
    if (!this.settings.syncInternalFiles) return;
    const r = await this.app.vault.adapter.stat(s);
    if (r && "file" != r.type) return;
    const o = ~~((r && r.mtime || 0) / 1e3), u = `${s}-${o}`;
    if (this.recentProcessedInternalFiles.contains(u)) return;
    this.recentProcessedInternalFiles = [ u, ...this.recentProcessedInternalFiles ].slice(0, 100);
    const g = addPrefix(s, ICHeader), _ = await this.localDatabase.getDBEntryMeta(g), b = void 0;
    if (~~((_ && _.mtime || 0) / 1e3) == o) return;
    if (0 == o) await this.deleteInternalFileOnDatabase(s); else await this.storeInternalFileToDatabase({
      path: s,
      ...r
    });
  }
  async resolveConflictOnInternalFiles() {
    const s = this.localDatabase.findEntries(ICHeader, ICHeaderEnd, {
      conflicts: true
    });
    for await (const r of s) {
      if (!("_conflicts" in r)) continue;
      if (isInternalMetadata(r._id)) await this.resolveConflictOnInternalFile(r.path);
    }
  }
  async resolveConflictOnInternalFile(s) {
    var r, o;
    try {
      const u = await this.path2id(s, ICHeader), g = await this.localDatabase.getRaw(u, {
        conflicts: true
      });
      if (!("_conflicts" in g)) return false;
      if (0 == g._conflicts.length) return false;
      Logger(`Hidden file conflicted:${s}`);
      const _ = g._conflicts.sort(((s, r) => Number(s.split("-")[0]) - Number(r.split("-")[0]))), b = g._rev, w = _[0];
      if (s.endsWith(".json")) {
        const E = _[0], S = Number(E.split("-")[0]), L = void 0, O = null != (o = null == (r = (await this.localDatabase.getRaw(u, {
          revs_info: true
        }))._revs_info.filter((s => "available" == s.status && Number(s.rev.split("-")[0]) < S)).first()) ? void 0 : r.rev) ? o : "", D = await this.plugin.mergeObject(s, O, g._rev, E);
        if (D) {
          Logger(`Object merge:${s}`, LOG_LEVEL_INFO);
          const r = stripAllPrefixes(s), o = void 0;
          if (!await this.app.vault.adapter.exists(r)) await this.ensureDirectoryEx(r);
          await this.app.vault.adapter.write(r, D);
          const g = await this.app.vault.adapter.stat(r);
          await this.storeInternalFileToDatabase({
            path: r,
            ...g
          });
          await this.extractInternalFileFromDatabase(r);
          await this.localDatabase.removeRaw(u, w);
          return this.resolveConflictOnInternalFile(s);
        } else Logger("Object merge is not applicable.", LOG_LEVEL_VERBOSE);
        const k = await this.localDatabase.getDBEntry(s, {
          rev: b
        }), C = await this.localDatabase.getDBEntry(s, {
          rev: w
        });
        if (false != k && false != C) {
          if (await this.showJSONMergeDialogAndMerge(k, C)) {
            await delay(200);
            return this.resolveConflictOnInternalFile(s);
          }
          return false;
        }
      }
      const E = await this.localDatabase.getRaw(u, {
        rev: w
      }), S = "mtime" in g && g.mtime || 0, L = void 0, O = S < ("mtime" in E && E.mtime || 0) ? b : w;
      await this.localDatabase.removeRaw(u, O);
      Logger(`Older one has been deleted:${s}`);
      return this.resolveConflictOnInternalFile(s);
    } catch (r) {
      Logger(`Failed to resolve conflict (Hidden): ${s}`);
      Logger(r, LOG_LEVEL_VERBOSE);
      return false;
    }
  }
  async syncInternalFilesAndDatabase(s, r, o = false, u = false) {
    await this.resolveConflictOnInternalFiles();
    const g = r ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO;
    Logger("Scanning hidden files.", g, "sync_internal");
    const _ = this.settings.syncInternalFilesIgnorePatterns.replace(/\n| /g, "").split(",").filter((s => s)).map((s => new RegExp(s, "i")));
    if (!o) o = await this.scanInternalFiles();
    const b = (await this.localDatabase.allDocsRaw({
      startkey: ICHeader,
      endkey: ICHeaderEnd,
      include_docs: true
    })).rows.map((s => s.doc)).filter((s => !s.deleted)), w = void 0, E = [ ...new Set([ ...o.map((s => normalizePath(s.path))), ...b.map((s => stripAllPrefixes(this.getPath(s)))) ]) ].filter((s => !u || u && -1 !== u.indexOf(s)));
    function compareMTime(s, r) {
      const o = void 0, u = void 0, g = void 0;
      return ~~(s / 1e3) - ~~(r / 1e3);
    }
    const S = E.length;
    let L = 0, O = 0;
    const D = {}, countUpdatedFolder = s => {
      const r = s.split("/");
      let o = r.shift(), u = "";
      O++;
      for (;o; ) {
        u += ("" != u ? "/" : "") + o;
        u = normalizePath(u);
        if (!(u in D)) D[u] = 0;
        D[u]++;
        o = r.shift();
      }
    };
    let k = {};
    k = await this.kvDB.get("diff-caches-internal") || {};
    const C = o.reduce(((s, r) => {
      s[r.path] = r;
      return s;
    }), {}), T = b.reduce(((s, r) => {
      s[stripAllPrefixes(this.getPath(r))] = r;
      return s;
    }), {}), I = Parallels();
    for (const r of E) {
      L++;
      if (L % 100 == 0) Logger(`Hidden file: ${L}/${S}`, g, "sync_internal");
      if (!r) continue;
      if (_.some((s => r.match(s)))) continue;
      if (await this.plugin.isIgnoredByIgnoreFiles(r)) continue;
      const o = r in C ? C[r] : void 0, u = r in T ? T[r] : void 0, b = r in k ? k[r] : {
        storageMtime: 0,
        docMtime: 0
      };
      await I.wait(5);
      const proc = async (o, u) => {
        if (o && u) {
          if ("pullForce" != s && "pushForce" != s && u.mtime == b.docMtime && o.mtime == b.storageMtime) return;
          const g = compareMTime(o.mtime, u.mtime);
          if (g > 0 || "pushForce" == s) await this.storeInternalFileToDatabase(o);
          if (g < 0 || "pullForce" == s) if (!await this.extractInternalFileFromDatabase(r)) return;
          b.docMtime = u.mtime;
          b.storageMtime = o.mtime;
          k[r] = b;
          countUpdatedFolder(r);
        } else if (!o && u) {
          if ("push" == s || "pushForce" == s) {
            if (u.deleted) return;
            await this.deleteInternalFileOnDatabase(r, false);
          } else if ("pull" == s || "pullForce" == s) {
            if (await this.extractInternalFileFromDatabase(r)) countUpdatedFolder(r);
          } else if ("safe" == s) {
            if (u.deleted) return;
            if (await this.extractInternalFileFromDatabase(r)) countUpdatedFolder(r);
          }
        } else if (o && !u) await this.storeInternalFileToDatabase(o); else throw new Error("Invalid state on hidden file sync");
      };
      I.add(proc(o, u));
    }
    await I.all();
    await this.kvDB.set("diff-caches-internal", k);
    if (("pull" == s || "pullForce" == s) && 0 != O) {
      const s = normalizePath(this.app.vault.configDir);
      if (s in D) {
        let r = D[s];
        try {
          const s = Object.values(this.app.plugins.manifests), o = this.app.plugins.enabledPlugins, u = s.filter((s => o.has(s.id)));
          for (const s of u) if (s.dir in D) {
            r -= D[s.dir];
            const o = s.id, u = s.name, g = createFragment((s => {
              s.createEl("span", null, (s => {
                s.appendText(`Files in ${u} has been updated, Press `);
                s.appendChild(s.createEl("a", null, (s => {
                  s.text = "HERE";
                  s.addEventListener("click", (async () => {
                    Logger(`Unloading plugin: ${u}`, LOG_LEVEL_NOTICE, "plugin-reload-" + o);
                    await this.app.plugins.unloadPlugin(o);
                    await this.app.plugins.loadPlugin(o);
                    Logger(`Plugin reloaded: ${u}`, LOG_LEVEL_NOTICE, "plugin-reload-" + o);
                  }));
                })));
                s.appendText(` to reload ${u}, or press elsewhere to dismiss this message.`);
              }));
            })), _ = "popupUpdated-" + o;
            scheduleTask(_, 1e3, (async () => {
              var s;
              const r = await memoIfNotExist(_, (() => new import_obsidian.Notice(g, 0))), o = void 0;
              if (!(null == (s = null == r ? void 0 : r.noticeEl) ? void 0 : s.isShown())) memoObject(_, new import_obsidian.Notice(g, 0));
              scheduleTask(_ + "-close", 2e4, (() => {
                var s;
                const r = retrieveMemoObject(_);
                if (!r) return;
                if (null == (s = null == r ? void 0 : r.noticeEl) ? void 0 : s.isShown()) r.hide();
                disposeMemoObject(_);
              }));
            }));
          }
        } catch (s) {
          Logger("Error on checking plugin status.");
          Logger(s, LOG_LEVEL_VERBOSE);
        }
        if (0 != r) {
          const r = createFragment((s => {
            s.createEl("span", null, (s => {
              s.appendText("Hidden files have been synchronized, Press ");
              s.appendChild(s.createEl("a", null, (s => {
                s.text = "HERE";
                s.addEventListener("click", (() => {
                  this.app.commands.executeCommandById("app:reload");
                }));
              })));
              s.appendText(" to reload obsidian, or press elsewhere to dismiss this message.");
            }));
          }));
          scheduleTask("popupUpdated-" + s, 1e3, (() => {
            var o, u;
            const g = void 0;
            if (!(null == (u = null == (o = this.confirmPopup) ? void 0 : o.noticeEl) ? void 0 : u.isShown())) this.confirmPopup = new import_obsidian.Notice(r, 0);
            scheduleTask("popupClose" + s, 2e4, (() => {
              var s;
              null == (s = this.confirmPopup) || s.hide();
              this.confirmPopup = null;
            }));
          }));
        }
      }
    }
    Logger(`Hidden files scanned: ${O} files had been modified`, g, "sync_internal");
  }
  async storeInternalFileToDatabase(s, r = false) {
    if (await this.plugin.isIgnoredByIgnoreFiles(s.path)) return;
    const o = await this.path2id(s.path, ICHeader), u = addPrefix(s.path, ICHeader), g = await this.app.vault.adapter.readBinary(s.path);
    let _;
    try {
      _ = await arrayBufferToBase64(g);
    } catch (r) {
      Logger(`The file ${s.path} could not be encoded`);
      Logger(r, LOG_LEVEL_VERBOSE);
      return false;
    }
    const b = s.mtime;
    return await runWithLock("file-" + u, false, (async () => {
      try {
        const g = await this.localDatabase.getDBEntry(u, null, false, false);
        let w;
        if (false === g) w = {
          _id: o,
          path: u,
          data: _,
          mtime: b,
          ctime: b,
          datatype: "newnote",
          size: s.size,
          children: [],
          deleted: false,
          type: "newnote"
        }; else {
          if (isDocContentSame(g.data, _) && !r) return;
          w = {
            ...g,
            data: _,
            mtime: b,
            size: s.size,
            datatype: "newnote",
            children: [],
            deleted: false,
            type: "newnote"
          };
        }
        const E = await this.localDatabase.putDBEntry(w, true);
        Logger(`STORAGE --\x3e DB:${s.path}: (hidden) Done`);
        return E;
      } catch (r) {
        Logger(`STORAGE --\x3e DB:${s.path}: (hidden) Failed`);
        Logger(r, LOG_LEVEL_VERBOSE);
        return false;
      }
    }));
  }
  async deleteInternalFileOnDatabase(s, r = false) {
    const o = await this.path2id(s, ICHeader), u = addPrefix(s, ICHeader), g = (new Date).getTime();
    if (await this.plugin.isIgnoredByIgnoreFiles(s)) return;
    await runWithLock("file-" + u, false, (async () => {
      try {
        const r = await this.localDatabase.getDBEntryMeta(u, null, true);
        let _;
        if (false === r) _ = {
          _id: o,
          path: u,
          mtime: g,
          ctime: g,
          size: 0,
          children: [],
          deleted: true,
          type: "newnote"
        }; else {
          if (r.deleted) {
            Logger(`STORAGE -x> DB:${s}: (hidden) already deleted`);
            return;
          }
          _ = {
            ...r,
            mtime: g,
            size: 0,
            children: [],
            deleted: true,
            type: "newnote"
          };
        }
        await this.localDatabase.putRaw(_);
        Logger(`STORAGE -x> DB:${s}: (hidden) Done`);
      } catch (r) {
        Logger(`STORAGE -x> DB:${s}: (hidden) Failed`);
        Logger(r, LOG_LEVEL_VERBOSE);
        return false;
      }
    }));
  }
  async extractInternalFileFromDatabase(s, r = false) {
    const o = await this.app.vault.adapter.exists(s), u = addPrefix(s, ICHeader);
    if (await this.plugin.isIgnoredByIgnoreFiles(s)) return;
    return await runWithLock("file-" + u, false, (async () => {
      var g;
      try {
        const _ = await this.localDatabase.getDBEntry(u, {
          conflicts: true
        }, false, true);
        if (false === _) throw new Error(`File not found on database.:${s}`);
        if (null == (g = null == _ ? void 0 : _._conflicts) ? void 0 : g.length) {
          Logger(`Hidden file ${s} has conflicted revisions, to keep in safe, writing to storage has been prevented`, LOG_LEVEL_INFO);
          return;
        }
        const b = void 0;
        if ("deleted" in _ ? _.deleted : false) {
          if (!o) Logger(`STORAGE <x- DB:${s}: deleted (hidden) Deleted on DB, but the file is  already not found on storage.`); else {
            Logger(`STORAGE <x- DB:${s}: deleted (hidden).`);
            await this.app.vault.adapter.remove(s);
            try {
              await this.app.vault.adapter.reconcileInternalFile(s);
            } catch (s) {
              Logger("Failed to call internal API(reconcileInternalFile)", LOG_LEVEL_VERBOSE);
              Logger(s, LOG_LEVEL_VERBOSE);
            }
          }
          return true;
        }
        if (!o) {
          await this.ensureDirectoryEx(s);
          await this.app.vault.adapter.writeBinary(s, base64ToArrayBuffer(_.data), {
            mtime: _.mtime,
            ctime: _.ctime
          });
          try {
            await this.app.vault.adapter.reconcileInternalFile(s);
          } catch (s) {
            Logger("Failed to call internal API(reconcileInternalFile)", LOG_LEVEL_VERBOSE);
            Logger(s, LOG_LEVEL_VERBOSE);
          }
          Logger(`STORAGE <-- DB:${s}: written (hidden,new${r ? ", force" : ""})`);
          return true;
        } else {
          const o = await this.app.vault.adapter.readBinary(s), u = void 0;
          if (isDocContentSame(await arrayBufferToBase64(o), _.data) && !r) return true;
          await this.app.vault.adapter.writeBinary(s, base64ToArrayBuffer(_.data), {
            mtime: _.mtime,
            ctime: _.ctime
          });
          try {
            await this.app.vault.adapter.reconcileInternalFile(s);
          } catch (s) {
            Logger("Failed to call internal API(reconcileInternalFile)", LOG_LEVEL_VERBOSE);
            Logger(s, LOG_LEVEL_VERBOSE);
          }
          Logger(`STORAGE <-- DB:${s}: written (hidden, overwrite${r ? ", force" : ""})`);
          return true;
        }
      } catch (o) {
        Logger(`STORAGE <-- DB:${s}: written (hidden, overwrite${r ? ", force" : ""}) Failed`);
        Logger(o, LOG_LEVEL_VERBOSE);
        return false;
      }
    }));
  }
  showJSONMergeDialogAndMerge(s, r) {
    return runWithLock("conflict:merge-data", false, (() => new Promise((o => {
      Logger("Opening data-merging dialog", LOG_LEVEL_VERBOSE);
      const u = [ s, r ], g = stripAllPrefixes(s.path), _ = void 0;
      new JsonResolveModal(this.app, g, [ s, r ], (async (s, r) => {
        try {
          const _ = g;
          let b = false;
          if (!r && !s) {
            Logger(`Skipped merging: ${_}`);
            o(false);
            return;
          }
          if (r || s) for (const r of u) if (r._rev != s) if (await this.localDatabase.deleteDBEntry(this.getPath(r), {
            rev: r._rev
          })) {
            Logger(`Conflicted revision has been deleted: ${_}`);
            b = true;
          }
          if (!s && r) {
            const s = void 0;
            if (!await this.app.vault.adapter.exists(_)) await this.ensureDirectoryEx(_);
            await this.app.vault.adapter.write(_, r);
            const o = await this.app.vault.adapter.stat(_);
            await this.storeInternalFileToDatabase({
              path: _,
              ...o
            }, true);
            try {
              await this.app.vault.adapter.reconcileInternalFile(_);
            } catch (s) {
              Logger("Failed to call internal API(reconcileInternalFile)", LOG_LEVEL_VERBOSE);
              Logger(s, LOG_LEVEL_VERBOSE);
            }
            Logger(`STORAGE <-- DB:${_}: written (hidden,merged)`);
          }
          if (b) {
            await this.extractInternalFileFromDatabase(_, false);
            Logger(`STORAGE --\x3e DB:${_}: extracted (hidden,merged)`);
          }
          o(true);
        } catch (s) {
          Logger("Could not merge conflicted json");
          Logger(s, LOG_LEVEL_VERBOSE);
          o(false);
        }
      })).open();
    }))));
  }
  async scanInternalFiles() {
    const s = this.settings.syncInternalFilesIgnorePatterns.replace(/\n| /g, "").split(",").filter((s => s)).map((s => new RegExp(s, "i"))), r = void 0, o = this.app.vault.getRoot().path, u = void 0, g = (await this.getFiles(o, [], null, s)).filter((s => s.startsWith("."))).filter((s => !s.startsWith(".trash"))).map((async s => ({
      path: s,
      stat: await this.app.vault.adapter.stat(s)
    }))), _ = [];
    for (const s of g) {
      const r = await s;
      if (await this.plugin.isIgnoredByIgnoreFiles(r.path)) continue;
      _.push({
        ...r,
        ...r.stat
      });
    }
    return _;
  }
  async getFiles(s, r, o, u) {
    const g = await this.app.vault.adapter.list(s), _ = [ ...g.files.filter((s => !r.some((r => s.endsWith(r))))).filter((s => !o || o.some((r => s.match(r))))).filter((s => !u || u.every((r => !s.match(r))))) ];
    let b = [];
    for (const s of _) if (!await this.plugin.isIgnoredByIgnoreFiles(s)) b.push(s);
    e: for (const s of g.folders) {
      for (const o of r) if (s.endsWith(o)) continue e;
      if (u && u.some((r => s.match(r)))) continue e;
      if (await this.plugin.isIgnoredByIgnoreFiles(s)) continue e;
      b = b.concat(await this.getFiles(s, r, o, u));
    }
    return b;
  }
}, SetupLiveSync = class extends LiveSyncCommands {
  onunload() {}
  onload() {
    this.plugin.registerObsidianProtocolHandler("setuplivesync", (async s => await this.setupWizard(s.settings)));
    this.plugin.addCommand({
      id: "livesync-copysetupuri",
      name: "Copy the setup URI",
      callback: this.command_copySetupURI.bind(this)
    });
    this.plugin.addCommand({
      id: "livesync-copysetupurifull",
      name: "Copy the setup URI (Full)",
      callback: this.command_copySetupURIFull.bind(this)
    });
    this.plugin.addCommand({
      id: "livesync-opensetupuri",
      name: "Open the setup URI",
      callback: this.command_openSetupURI.bind(this)
    });
  }
  onInitializeDatabase(s) {}
  beforeReplicate(s) {}
  onResume() {}
  parseReplicationResultItem(s) {
    return false;
  }
  async realizeSettingSyncMode() {}
  async command_copySetupURI() {
    const s = await askString(this.app, "Encrypt your settings", "The passphrase to encrypt the setup URI", "", true);
    if (false === s) return;
    const r = {
      ...this.settings,
      configPassphraseStore: "",
      encryptedCouchDBConnection: "",
      encryptedPassphrase: ""
    }, o = Object.keys(r);
    for (const s of o) if (JSON.stringify(s in r ? r[s] : "") == JSON.stringify(s in DEFAULT_SETTINGS ? DEFAULT_SETTINGS[s] : "*")) delete r[s];
    const u = encodeURIComponent(await encrypt(JSON.stringify(r), s, false)), g = `${configURIBase}${u}`;
    await navigator.clipboard.writeText(g);
    Logger("Setup URI copied to clipboard", LOG_LEVEL_NOTICE);
  }
  async command_copySetupURIFull() {
    const s = await askString(this.app, "Encrypt your settings", "The passphrase to encrypt the setup URI", "", true);
    if (false === s) return;
    const r = {
      ...this.settings,
      configPassphraseStore: "",
      encryptedCouchDBConnection: "",
      encryptedPassphrase: ""
    }, o = encodeURIComponent(await encrypt(JSON.stringify(r), s, false)), u = `${configURIBase}${o}`;
    await navigator.clipboard.writeText(u);
    Logger("Setup URI copied to clipboard", LOG_LEVEL_NOTICE);
  }
  async command_openSetupURI() {
    const s = await askString(this.app, "Easy setup", "Set up URI", `${configURIBase}aaaaa`);
    if (false === s) return;
    if (!s.startsWith(`${configURIBase}`)) {
      Logger("Set up URI looks wrong.", LOG_LEVEL_NOTICE);
      return;
    }
    const r = decodeURIComponent(s.substring(configURIBase.length));
    console.dir(r);
    await this.setupWizard(r);
  }
  async setupWizard(s) {
    try {
      const r = JSON.parse(JSON.stringify(this.settings)), o = await askString(this.app, "Passphrase", "The passphrase to decrypt your setup URI", "", true);
      if (false === o) return;
      const u = await JSON.parse(await decrypt(s, o, false));
      if (u) {
        const s = void 0;
        if ("yes" == await askYesNo(this.app, "Importing LiveSync's conf, OK?")) {
          const s = Object.assign({}, DEFAULT_SETTINGS, u);
          this.plugin.replicator.closeReplication();
          this.settings.suspendFileWatching = true;
          console.dir(s);
          s.configPassphraseStore = "";
          s.encryptedPassphrase = "";
          s.encryptedCouchDBConnection = "";
          const o = "Just import setting", g = "Set it up as secondary or subsequent device", _ = "Secondary device but try keeping local changes", b = "Reconfigure and reconstitute the data", w = "Leave everything to me";
          s.syncInternalFiles = false;
          s.usePluginSync = false;
          if (!s.useIndexedDBAdapter) s.useIndexedDBAdapter = true;
          const E = await askSelectString(this.app, "How would you like to set it up?", [ g, b, _, o, w ]);
          if (E == o) {
            this.plugin.settings = s;
            this.plugin.usedPassphrase = "";
            await this.plugin.saveSettings();
          } else if (E == g) {
            this.plugin.settings = s;
            this.plugin.usedPassphrase = "";
            await this.fetchLocal();
          } else if (E == _) {
            this.plugin.settings = s;
            this.plugin.usedPassphrase = "";
            await this.fetchLocalWithKeepLocal();
          } else if (E == b) {
            const r = "I know this operation will rebuild all my databases with files on this device, and files that are on the remote database and I didn't synchronize to any other devices will be lost and want to proceed indeed.";
            if (await askSelectString(this.app, "Do you really want to do this?", [ "Cancel", r ]) != r) return;
            this.plugin.settings = s;
            this.plugin.usedPassphrase = "";
            await this.rebuildEverything();
          } else if (E == w) {
            const o = await askYesNo(this.app, "Keep local DB?"), u = await askYesNo(this.app, "Keep remote DB?");
            if ("yes" == o && "yes" == u) {
              this.plugin.settings = s;
              this.plugin.usedPassphrase = "";
              this.suspendAllSync();
              this.suspendExtraSync();
              await this.plugin.saveSettings();
              const r = void 0;
              if ("yes" == await askYesNo(this.app, "Unlock and replicate?")) {
                await this.plugin.replicate(true);
                await this.plugin.markRemoteUnlocked();
              }
              Logger("Configuration loaded.", LOG_LEVEL_NOTICE);
              return;
            }
            if ("no" == o && "no" == u) {
              const s = void 0;
              if ("yes" != await askYesNo(this.app, "Drop everything?")) {
                Logger("Cancelled", LOG_LEVEL_NOTICE);
                this.plugin.settings = r;
                return;
              }
            }
            let g;
            this.plugin.settings = s;
            this.plugin.usedPassphrase = "";
            await this.plugin.saveSettings();
            if ("no" == o) {
              await this.plugin.resetLocalDatabase();
              await this.plugin.localDatabase.initializeDatabase();
              const s = void 0;
              if ("yes" == await askYesNo(this.app, "Rebuild the database?")) g = this.plugin.initializeDatabase(true); else await this.plugin.markRemoteResolved();
            }
            if ("no" == u) {
              await this.plugin.tryResetRemoteDatabase();
              await this.plugin.markRemoteLocked();
            }
            if ("no" == o || "no" == u) {
              const s = void 0;
              if ("yes" == await askYesNo(this.app, "Replicate once?")) {
                if (null != g) await g;
                await this.plugin.replicate(true);
              }
            }
          }
        }
        Logger("Configuration loaded.", LOG_LEVEL_NOTICE);
      } else Logger("Cancelled.", LOG_LEVEL_NOTICE);
    } catch (s) {
      Logger("Couldn't parse or decrypt configuration uri.", LOG_LEVEL_NOTICE);
    }
  }
  suspendExtraSync() {
    Logger("Hidden files and plugin synchronization have been temporarily disabled. Please enable them after the fetching, if you need them.", LOG_LEVEL_NOTICE);
    this.plugin.settings.syncInternalFiles = false;
    this.plugin.settings.usePluginSync = false;
    this.plugin.settings.autoSweepPlugins = false;
  }
  async askHiddenFileConfiguration(s) {
    this.plugin.addOnSetup.suspendExtraSync();
    const r = `Would you like to enable \`Hidden File Synchronization\` or \`Customization sync\`?\n${s.enableFetch ? " - Fetch: Use files stored from other devices. \n" : ""}${s.enableOverwrite ? "- Overwrite: Use files from this device. \n" : ""}- Custom: Synchronize only customization files with a dedicated interface.\n- Keep them disabled: Do not use hidden file synchronization.\nOf course, we are able to disable these features.`, o = "Fetch", u = "Overwrite", g = "Custom", _ = "keep them disabled", b = [];
    if (null == s ? void 0 : s.enableFetch) b.push(o);
    if (null == s ? void 0 : s.enableOverwrite) b.push(u);
    b.push(g);
    b.push(_);
    const w = await confirmWithMessage(this.plugin, "Hidden file sync", r, b, _, 40);
    if (w == o) await this.configureHiddenFileSync("FETCH"); else if (w == u) await this.configureHiddenFileSync("OVERWRITE"); else if (w == _) await this.configureHiddenFileSync("DISABLE"); else if (w == g) await this.configureHiddenFileSync("CUSTOMIZE");
  }
  async configureHiddenFileSync(s) {
    this.plugin.addOnSetup.suspendExtraSync();
    if ("DISABLE" == s) {
      this.plugin.settings.syncInternalFiles = false;
      this.plugin.settings.usePluginSync = false;
      await this.plugin.saveSettings();
      return;
    }
    if ("CUSTOMIZE" != s) {
      Logger("Gathering files for enabling Hidden File Sync", LOG_LEVEL_NOTICE);
      if ("FETCH" == s) await this.plugin.addOnHiddenFileSync.syncInternalFilesAndDatabase("pullForce", true); else if ("OVERWRITE" == s) await this.plugin.addOnHiddenFileSync.syncInternalFilesAndDatabase("pushForce", true); else if ("MERGE" == s) await this.plugin.addOnHiddenFileSync.syncInternalFilesAndDatabase("safe", true);
      this.plugin.settings.syncInternalFiles = true;
      await this.plugin.saveSettings();
      Logger("Done! Restarting the app is strongly recommended!", LOG_LEVEL_NOTICE);
    } else if ("CUSTOMIZE" == s) {
      if (!this.plugin.deviceAndVaultName) {
        let s = await askString(this.app, "Device name", "Please set this device name", "desktop");
        if (!s) {
          if (import_obsidian.Platform.isAndroidApp) s = "android-app"; else if (import_obsidian.Platform.isIosApp) s = "ios"; else if (import_obsidian.Platform.isMacOS) s = "macos"; else if (import_obsidian.Platform.isMobileApp) s = "mobile-app"; else if (import_obsidian.Platform.isMobile) s = "mobile"; else if (import_obsidian.Platform.isSafari) s = "safari"; else if (import_obsidian.Platform.isDesktop) s = "desktop"; else if (import_obsidian.Platform.isDesktopApp) s = "desktop-app"; else s = "unknown";
          s += Math.random().toString(36).slice(-4);
        }
        this.plugin.deviceAndVaultName = s;
      }
      this.plugin.settings.usePluginSync = true;
      await this.plugin.saveSettings();
      await this.plugin.addOnConfigSync.scanAllConfigFiles(true);
    }
  }
  suspendAllSync() {
    this.plugin.settings.liveSync = false;
    this.plugin.settings.periodicReplication = false;
    this.plugin.settings.syncOnSave = false;
    this.plugin.settings.syncOnStart = false;
    this.plugin.settings.syncOnFileOpen = false;
    this.plugin.settings.syncAfterMerge = false;
  }
  async suspendReflectingDatabase() {
    if (this.plugin.settings.doNotSuspendOnFetching) return;
    Logger("Suspending reflection: Database and storage changes will not be reflected in each other until completely finished the fetching.", LOG_LEVEL_NOTICE);
    this.plugin.settings.suspendParseReplicationResult = true;
    this.plugin.settings.suspendFileWatching = true;
    await this.plugin.saveSettings();
  }
  async resumeReflectingDatabase() {
    if (this.plugin.settings.doNotSuspendOnFetching) return;
    Logger("Database and storage reflection has been resumed!", LOG_LEVEL_NOTICE);
    this.plugin.settings.suspendParseReplicationResult = false;
    this.plugin.settings.suspendFileWatching = false;
    await this.plugin.syncAllFiles(true);
    await this.plugin.loadQueuedFiles();
    this.plugin.procQueuedFiles();
    await this.plugin.saveSettings();
  }
  async askUseNewAdapter() {
    if (!this.plugin.settings.useIndexedDBAdapter) {
      const s = "Now this plugin has been configured to use the old database adapter for keeping compatibility. Do you want to deactivate it?", r = "Yes, disable and use latest", o = void 0, u = [ r, "No, keep compatibility" ], g = void 0;
      if (await confirmWithMessage(this.plugin, "Database adapter", s, u, r, 10) == r) this.plugin.settings.useIndexedDBAdapter = false;
    }
  }
  async fetchRemoteChunks() {
    if (!this.plugin.settings.doNotSuspendOnFetching && this.plugin.settings.readChunksOnline) {
      Logger("Fetching chunks", LOG_LEVEL_NOTICE);
      const s = await this.plugin.getReplicator().connectRemoteCouchDBWithSetting(this.settings, this.plugin.getIsMobile(), true);
      if ("string" == typeof s) Logger(s, LOG_LEVEL_NOTICE); else await fetchAllUsedChunks(this.localDatabase.localDatabase, s.db);
      Logger("Fetching chunks done", LOG_LEVEL_NOTICE);
    }
  }
  async fetchLocal() {
    this.suspendExtraSync();
    this.askUseNewAdapter();
    await this.suspendReflectingDatabase();
    await this.plugin.realizeSettingSyncMode();
    await this.plugin.resetLocalDatabase();
    await delay(1e3);
    await this.plugin.markRemoteResolved();
    await this.plugin.openDatabase();
    this.plugin.isReady = true;
    await delay(500);
    await this.plugin.replicateAllFromServer(true);
    await delay(1e3);
    await this.plugin.replicateAllFromServer(true);
    await this.fetchRemoteChunks();
    await this.resumeReflectingDatabase();
    await this.askHiddenFileConfiguration({
      enableFetch: true
    });
  }
  async fetchLocalWithKeepLocal() {
    this.suspendExtraSync();
    this.askUseNewAdapter();
    await this.suspendReflectingDatabase();
    await this.plugin.realizeSettingSyncMode();
    await this.plugin.resetLocalDatabase();
    await delay(1e3);
    await this.plugin.initializeDatabase(true);
    await this.plugin.markRemoteResolved();
    await this.plugin.openDatabase();
    this.plugin.isReady = true;
    await delay(500);
    await this.plugin.replicateAllFromServer(true);
    await delay(1e3);
    await this.plugin.replicateAllFromServer(true);
    await this.fetchRemoteChunks();
    await this.resumeReflectingDatabase();
    await this.askHiddenFileConfiguration({
      enableFetch: true
    });
  }
  async rebuildRemote() {
    this.suspendExtraSync();
    await this.plugin.realizeSettingSyncMode();
    await this.plugin.markRemoteLocked();
    await this.plugin.tryResetRemoteDatabase();
    await this.plugin.markRemoteLocked();
    await delay(500);
    await this.askHiddenFileConfiguration({
      enableOverwrite: true
    });
    await delay(1e3);
    await this.plugin.replicateAllToServer(true);
    await delay(1e3);
    await this.plugin.replicateAllToServer(true);
  }
  async rebuildEverything() {
    this.suspendExtraSync();
    this.askUseNewAdapter();
    await this.plugin.realizeSettingSyncMode();
    await this.plugin.resetLocalDatabase();
    await delay(1e3);
    await this.plugin.initializeDatabase(true);
    await this.plugin.markRemoteLocked();
    await this.plugin.tryResetRemoteDatabase();
    await this.plugin.markRemoteLocked();
    await delay(500);
    await this.askHiddenFileConfiguration({
      enableOverwrite: true
    });
    await delay(1e3);
    await this.plugin.replicateAllToServer(true);
    await delay(1e3);
    await this.plugin.replicateAllToServer(true);
  }
};

function add_css4(s) {
  append_styles(s, "svelte-1vjy5r1", ".svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{box-sizing:border-box}.globalhistory.svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{margin-bottom:2em}table.svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{width:100%}.more.svelte-1vjy5r1>div.svelte-1vjy5r1.svelte-1vjy5r1{display:flex}.more.svelte-1vjy5r1>div.svelte-1vjy5r1>button.svelte-1vjy5r1{flex-grow:1}th.svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{position:sticky;top:0;backdrop-filter:blur(10px)}td.mtime.svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{white-space:break-spaces}td.path.svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{word-break:break-word}.row.svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{display:flex;flex-direction:row;flex-wrap:wrap}.row.svelte-1vjy5r1>label.svelte-1vjy5r1.svelte-1vjy5r1{display:flex;align-items:center;min-width:5em}.row.svelte-1vjy5r1>input.svelte-1vjy5r1.svelte-1vjy5r1{flex-grow:1}.filenames.svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{display:flex;flex-direction:column}.filenames.svelte-1vjy5r1>.path.svelte-1vjy5r1.svelte-1vjy5r1{font-size:70%}.rev.svelte-1vjy5r1.svelte-1vjy5r1.svelte-1vjy5r1{text-overflow:ellipsis;max-width:3em;display:inline-block;overflow:hidden;white-space:nowrap}");
}

function get_each_context4(s, r, o) {
  const u = s.slice();
  u[26] = r[o];
  return u;
}

function create_if_block_52(s) {
  let r;
  return {
    c() {
      r = element("div");
      r.textContent = "Gathering information...";
      attr(r, "class", " svelte-1vjy5r1");
    },
    m(s, o) {
      insert(s, r, o);
    },
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_if_block_43(s) {
  let r;
  return {
    c() {
      r = element("th");
      r.textContent = "Chunks";
      attr(r, "class", "svelte-1vjy5r1");
    },
    m(s, o) {
      insert(s, r, o);
    },
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_else_block_22(s) {
  let r, o, u, g;
  return {
    c() {
      r = element("div");
      o = element("button");
      o.textContent = "+1 week";
      attr(o, "class", "svelte-1vjy5r1");
      attr(r, "class", "svelte-1vjy5r1");
    },
    m(_, b) {
      insert(_, r, b);
      append(r, o);
      if (!u) {
        g = listen(o, "click", s[17]);
        u = true;
      }
    },
    p: noop,
    d(s) {
      if (s) detach(r);
      u = false;
      g();
    }
  };
}

function create_if_block_33(s) {
  let r;
  return {
    c() {
      r = element("div");
      attr(r, "class", " svelte-1vjy5r1");
    },
    m(s, o) {
      insert(s, r, o);
    },
    p: noop,
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_else_block_13(s) {
  let r = s[26].rev + "", o;
  return {
    c() {
      o = text(r);
    },
    m(s, r) {
      insert(s, o, r);
    },
    p(s, u) {
      if (32 & u && r !== (r = s[26].rev + "")) set_data(o, r);
    },
    d(s) {
      if (s) detach(o);
    }
  };
}

function create_if_block_24(s) {
  let r, o = s[26].rev + "", u, g, _;
  function click_handler_2() {
    return s[19](s[26]);
  }
  return {
    c() {
      r = element("a");
      u = text(o);
      attr(r, "class", "svelte-1vjy5r1");
    },
    m(s, o) {
      insert(s, r, o);
      append(r, u);
      if (!g) {
        _ = listen(r, "click", click_handler_2);
        g = true;
      }
    },
    p(r, g) {
      s = r;
      if (32 & g && o !== (o = s[26].rev + "")) set_data(u, o);
    },
    d(s) {
      if (s) detach(r);
      g = false;
      _();
    }
  };
}

function create_if_block_14(s) {
  let r, o = s[26].chunks + "", u;
  return {
    c() {
      r = element("td");
      u = text(o);
      attr(r, "class", "svelte-1vjy5r1");
    },
    m(s, o) {
      insert(s, r, o);
      append(r, u);
    },
    p(s, r) {
      if (32 & r && o !== (o = s[26].chunks + "")) set_data(u, o);
    },
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_each_block4(s) {
  let r, o, u = s[26].mtimeDisp + "", g, _, b, w, E, S, L = s[26].dirname.split("/").join("​/") + "", O, D, k, C, T = s[26].filename + "", I, A, x, R, P, N, B = s[26].changes + "", F, M, V, G;
  function click_handler_1() {
    return s[18](s[26]);
  }
  function select_block_type_1(s, r) {
    if (s[26].isPlain) return create_if_block_24;
    return create_else_block_13;
  }
  let j = select_block_type_1(s, -1), q = j(s), z = s[1] && create_if_block_14(s);
  return {
    c() {
      r = element("tr");
      o = element("td");
      g = text(u);
      _ = space();
      b = element("td");
      w = element("div");
      E = element("span");
      S = text("/");
      O = text(L);
      D = space();
      k = element("span");
      C = element("a");
      I = text(T);
      A = space();
      x = element("td");
      R = element("span");
      q.c();
      P = space();
      N = element("td");
      F = text(B);
      M = space();
      if (z) z.c();
      attr(o, "class", "mtime svelte-1vjy5r1");
      attr(E, "class", "path svelte-1vjy5r1");
      attr(C, "class", "svelte-1vjy5r1");
      attr(k, "class", "filename svelte-1vjy5r1");
      attr(w, "class", "filenames svelte-1vjy5r1");
      attr(b, "class", "path svelte-1vjy5r1");
      attr(R, "class", "rev svelte-1vjy5r1");
      attr(x, "class", "svelte-1vjy5r1");
      attr(N, "class", "svelte-1vjy5r1");
      attr(r, "class", "svelte-1vjy5r1");
    },
    m(s, u) {
      insert(s, r, u);
      append(r, o);
      append(o, g);
      append(r, _);
      append(r, b);
      append(b, w);
      append(w, E);
      append(E, S);
      append(E, O);
      append(w, D);
      append(w, k);
      append(k, C);
      append(C, I);
      append(r, A);
      append(r, x);
      append(x, R);
      q.m(R, null);
      append(r, P);
      append(r, N);
      append(N, F);
      append(r, M);
      if (z) z.m(r, null);
      if (!V) {
        G = listen(C, "click", click_handler_1);
        V = true;
      }
    },
    p(o, _) {
      s = o;
      if (32 & _ && u !== (u = s[26].mtimeDisp + "")) set_data(g, u);
      if (32 & _ && L !== (L = s[26].dirname.split("/").join("​/") + "")) set_data(O, L);
      if (32 & _ && T !== (T = s[26].filename + "")) set_data(I, T);
      if (j === (j = select_block_type_1(s, _)) && q) q.p(s, _); else {
        q.d(1);
        q = j(s);
        if (q) {
          q.c();
          q.m(R, null);
        }
      }
      if (32 & _ && B !== (B = s[26].changes + "")) set_data(F, B);
      if (s[1]) if (z) z.p(s, _); else {
        z = create_if_block_14(s);
        z.c();
        z.m(r, null);
      } else if (z) {
        z.d(1);
        z = null;
      }
    },
    d(s) {
      if (s) detach(r);
      q.d();
      if (z) z.d();
      V = false;
      G();
    }
  };
}

function create_else_block4(s) {
  let r, o, u, g;
  return {
    c() {
      r = element("div");
      o = element("button");
      o.textContent = "+1 week";
      attr(o, "class", "svelte-1vjy5r1");
      attr(r, "class", "svelte-1vjy5r1");
    },
    m(_, b) {
      insert(_, r, b);
      append(r, o);
      if (!u) {
        g = listen(o, "click", s[20]);
        u = true;
      }
    },
    p: noop,
    d(s) {
      if (s) detach(r);
      u = false;
      g();
    }
  };
}

function create_if_block4(s) {
  let r;
  return {
    c() {
      r = element("div");
      attr(r, "class", " svelte-1vjy5r1");
    },
    m(s, o) {
      insert(s, r, o);
    },
    p: noop,
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_fragment4(s) {
  let r, o, u, g, _, b, w, E, S, L, O, D, k, C, T, I, A, x, R, P, N, B, F, M, V, G, j, q, z, U, W, H, K, Q, J, Y, X, Z, ee, te, ne, ie, se, re, ae, oe, le, ce = s[6] && create_if_block_52(s), ue = s[1] && create_if_block_43(s);
  function select_block_type(s, r) {
    if (s[6]) return create_if_block_33;
    return create_else_block_22;
  }
  let de = select_block_type(s, -1), fe = de(s), he = ensure_array_like(s[5]), pe = [];
  for (let r = 0; r < he.length; r += 1) pe[r] = create_each_block4(get_each_context4(s, he, r));
  function select_block_type_2(s, r) {
    if (s[6]) return create_if_block4;
    return create_else_block4;
  }
  let ge = select_block_type_2(s, -1), me = ge(s);
  return {
    c() {
      r = element("div");
      o = element("h1");
      o.textContent = "Vault history";
      u = space();
      g = element("div");
      _ = element("div");
      b = element("label");
      b.textContent = "From:";
      w = element("input");
      E = space();
      S = element("div");
      L = element("label");
      L.textContent = "To:";
      O = element("input");
      D = space();
      k = element("div");
      C = element("label");
      C.textContent = "Info:";
      T = space();
      I = element("label");
      A = element("input");
      x = element("span");
      x.textContent = "Diff";
      R = space();
      P = element("label");
      N = element("input");
      B = element("span");
      B.textContent = "Chunks";
      F = space();
      M = element("label");
      V = element("input");
      G = element("span");
      G.textContent = "File integrity";
      j = space();
      if (ce) ce.c();
      q = space();
      z = element("table");
      U = element("tr");
      W = element("th");
      W.textContent = "Date";
      H = space();
      K = element("th");
      K.textContent = "Path";
      Q = space();
      J = element("th");
      J.textContent = "Rev";
      Y = space();
      X = element("th");
      X.textContent = "Stat";
      Z = space();
      if (ue) ue.c();
      ee = space();
      te = element("tr");
      ne = element("td");
      fe.c();
      ie = space();
      for (let s = 0; s < pe.length; s += 1) pe[s].c();
      se = space();
      re = element("tr");
      ae = element("td");
      me.c();
      attr(o, "class", "svelte-1vjy5r1");
      attr(b, "for", "");
      attr(b, "class", "svelte-1vjy5r1");
      attr(w, "type", "date");
      w.disabled = s[6];
      attr(w, "class", "svelte-1vjy5r1");
      attr(_, "class", "row svelte-1vjy5r1");
      attr(L, "for", "");
      attr(L, "class", "svelte-1vjy5r1");
      attr(O, "type", "date");
      O.disabled = s[6];
      attr(O, "class", "svelte-1vjy5r1");
      attr(S, "class", "row svelte-1vjy5r1");
      attr(C, "for", "");
      attr(C, "class", "svelte-1vjy5r1");
      attr(A, "type", "checkbox");
      A.disabled = s[6];
      attr(A, "class", "svelte-1vjy5r1");
      attr(x, "class", "svelte-1vjy5r1");
      attr(I, "class", "svelte-1vjy5r1");
      attr(N, "type", "checkbox");
      N.disabled = s[6];
      attr(N, "class", "svelte-1vjy5r1");
      attr(B, "class", "svelte-1vjy5r1");
      attr(P, "class", "svelte-1vjy5r1");
      attr(V, "type", "checkbox");
      V.disabled = s[6];
      attr(V, "class", "svelte-1vjy5r1");
      attr(G, "class", "svelte-1vjy5r1");
      attr(M, "class", "svelte-1vjy5r1");
      attr(k, "class", "row svelte-1vjy5r1");
      attr(g, "class", "control svelte-1vjy5r1");
      attr(W, "class", "svelte-1vjy5r1");
      attr(K, "class", "svelte-1vjy5r1");
      attr(J, "class", "svelte-1vjy5r1");
      attr(X, "class", "svelte-1vjy5r1");
      attr(U, "class", "svelte-1vjy5r1");
      attr(ne, "colspan", "5");
      attr(ne, "class", "more svelte-1vjy5r1");
      attr(te, "class", "svelte-1vjy5r1");
      attr(ae, "colspan", "5");
      attr(ae, "class", "more svelte-1vjy5r1");
      attr(re, "class", "svelte-1vjy5r1");
      attr(z, "class", "svelte-1vjy5r1");
      attr(r, "class", "globalhistory svelte-1vjy5r1");
    },
    m(de, he) {
      insert(de, r, he);
      append(r, o);
      append(r, u);
      append(r, g);
      append(g, _);
      append(_, b);
      append(_, w);
      set_input_value(w, s[3]);
      append(g, E);
      append(g, S);
      append(S, L);
      append(S, O);
      set_input_value(O, s[4]);
      append(g, D);
      append(g, k);
      append(k, C);
      append(k, T);
      append(k, I);
      append(I, A);
      A.checked = s[0];
      append(I, x);
      append(k, R);
      append(k, P);
      append(P, N);
      N.checked = s[1];
      append(P, B);
      append(k, F);
      append(k, M);
      append(M, V);
      V.checked = s[2];
      append(M, G);
      append(r, j);
      if (ce) ce.m(r, null);
      append(r, q);
      append(r, z);
      append(z, U);
      append(U, W);
      append(U, H);
      append(U, K);
      append(U, Q);
      append(U, J);
      append(U, Y);
      append(U, X);
      append(U, Z);
      if (ue) ue.m(U, null);
      append(z, ee);
      append(z, te);
      append(te, ne);
      fe.m(ne, null);
      append(z, ie);
      for (let s = 0; s < pe.length; s += 1) if (pe[s]) pe[s].m(z, null);
      append(z, se);
      append(z, re);
      append(re, ae);
      me.m(ae, null);
      if (!oe) {
        le = [ listen(w, "input", s[12]), listen(O, "input", s[13]), listen(A, "change", s[14]), listen(N, "change", s[15]), listen(V, "change", s[16]) ];
        oe = true;
      }
    },
    p(s, [o]) {
      if (64 & o) w.disabled = s[6];
      if (8 & o) set_input_value(w, s[3]);
      if (64 & o) O.disabled = s[6];
      if (16 & o) set_input_value(O, s[4]);
      if (64 & o) A.disabled = s[6];
      if (1 & o) A.checked = s[0];
      if (64 & o) N.disabled = s[6];
      if (2 & o) N.checked = s[1];
      if (64 & o) V.disabled = s[6];
      if (4 & o) V.checked = s[2];
      if (s[6]) if (ce) ; else {
        ce = create_if_block_52(s);
        ce.c();
        ce.m(r, q);
      } else if (ce) {
        ce.d(1);
        ce = null;
      }
      if (s[1]) if (ue) ; else {
        ue = create_if_block_43(s);
        ue.c();
        ue.m(U, null);
      } else if (ue) {
        ue.d(1);
        ue = null;
      }
      if (de === (de = select_block_type(s, o)) && fe) fe.p(s, o); else {
        fe.d(1);
        fe = de(s);
        if (fe) {
          fe.c();
          fe.m(ne, null);
        }
      }
      if (1570 & o) {
        he = ensure_array_like(s[5]);
        let r;
        for (r = 0; r < he.length; r += 1) {
          const u = get_each_context4(s, he, r);
          if (pe[r]) pe[r].p(u, o); else {
            pe[r] = create_each_block4(u);
            pe[r].c();
            pe[r].m(z, se);
          }
        }
        for (;r < pe.length; r += 1) pe[r].d(1);
        pe.length = he.length;
      }
      if (ge === (ge = select_block_type_2(s, o)) && me) me.p(s, o); else {
        me.d(1);
        me = ge(s);
        if (me) {
          me.c();
          me.m(ae, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(s) {
      if (s) detach(r);
      if (ce) ce.d();
      if (ue) ue.d();
      fe.d();
      destroy_each(pe, s);
      me.d();
      oe = false;
      run_all(le);
    }
  };
}

function mtimeToDate(s) {
  return new Date(s).toLocaleString();
}

function instance4(s, r, o) {
  let {plugin: u} = r, g = false, _ = false, b = false, w = Date.now() - 6048e5, E = Date.now() + 1728e5;
  const S = (new Date).getTimezoneOffset();
  let L = new Date(w - S).toISOString().split("T")[0], O = new Date(E - S).toISOString().split("T")[0], D = [], k = false;
  async function fetchChanges() {
    var s, r;
    try {
      const o = u.localDatabase;
      let S = [];
      for await (const L of o.findAllNormalDocs()) {
        if (L.mtime < w) continue;
        if ("newnote" != L.type && "plain" != L.type) continue;
        const O = u.getPath(L), D = isPlainText(L.path), k = void 0;
        let C;
        const T = (await o.getRaw(L._id, {
          revs_info: true
        }))._revs_info.reverse(), I = -1, A = 0, x = 1;
        for (const k of T) if ("available" == k.status) {
          const T = !D && g || b && k.rev == L._rev ? await o.getDBEntry(O, {
            rev: k.rev
          }, false, false, true) : await o.getDBEntryMeta(O, {
            rev: k.rev
          }, true);
          if (false === T) continue;
          const R = k.rev, P = "mtime" in T ? T.mtime : 0;
          if (w > P) continue;
          if (E < P) continue;
          let N = "";
          if (g && !D) {
            const s = getDocData(T.data);
            if (void 0 === C) C = s;
            if (C != s) {
              const r = new import_diff_match_patch.diff_match_patch, o = r.diff_main(C, s);
              r.diff_cleanupSemantic(o);
              C = s;
              const u = {
                [I]: 0,
                [A]: 0,
                [x]: 0
              }, g = o.reduce(((s, r) => {
                var o;
                return {
                  ...s,
                  [r[0]]: (null !== (o = s[r[0]]) && void 0 !== o ? o : 0) + r[1].length
                };
              }), u);
              N = `-${g[I]}, +${g[x]}`;
            }
          }
          const B = T._deleted || (null == T ? void 0 : T.deleted) || false;
          if (B) N += " 🗑️";
          if (R == L._rev) if (b) {
            const s = u.app.vault.getAbstractFileByPath(stripAllPrefixes(u.getPath(L)));
            if (s instanceof import_obsidian.TFile) {
              let r = false;
              if (isPlainText(L.path)) {
                const o = void 0;
                r = isDocContentSame(await u.app.vault.read(s), T.data);
              } else {
                const o = await u.app.vault.readBinary(s), g = void 0;
                r = isDocContentSame(await arrayBufferToBase64(o), T.data);
              }
              if (r) N += " ⚖️"; else N += " ⚠️";
            }
          }
          const F = u.getPath(T), [M, ...V] = F.split("/").reverse();
          let G = "";
          if (_) {
            const r = null !== (s = null == T ? void 0 : T.children) && void 0 !== s ? s : [], u = await o.allDocsRaw({
              keys: [ ...r ]
            }), g = u.rows.length, _ = u.rows.filter((s => "error" in s)).length;
            if (0 == _) G = `✅ ${g}`; else G = `🔎 ${_} ✅ ${g}`;
          }
          S.push({
            id: T._id,
            rev: T._rev,
            path: F,
            dirname: V.reverse().join("/"),
            filename: M,
            mtime: P,
            mtimeDisp: mtimeToDate(P),
            size: null !== (r = null == T ? void 0 : T.size) && void 0 !== r ? r : 0,
            isDeleted: B,
            changes: N,
            chunks: G,
            isPlain: D
          });
        }
      }
      return [ ...S ].sort(((s, r) => r.mtime - s.mtime));
    } finally {
      o(6, k = false);
    }
  }
  async function getHistory(s, r, u) {
    o(6, k = true);
    const g = [], _ = await fetchChanges();
    g.push(..._);
    o(5, D = [ ...g ]);
  }
  function nextWeek() {
    o(4, O = new Date(E - S + 6048e5).toISOString().split("T")[0]);
  }
  function prevWeek() {
    o(3, L = new Date(w - S - 6048e5).toISOString().split("T")[0]);
  }
  onMount((async () => {
    await getHistory(g, _, b);
  }));
  onDestroy((() => {}));
  function showHistory(s, r) {
    new DocumentHistoryModal(u.app, u, s, null, r).open();
  }
  function openFile(s) {
    u.app.workspace.openLinkText(s, s);
  }
  function input0_input_handler() {
    L = this.value;
    o(3, L);
  }
  function input1_input_handler() {
    O = this.value;
    o(4, O);
  }
  function input2_change_handler() {
    g = this.checked;
    o(0, g);
  }
  function input3_change_handler() {
    _ = this.checked;
    o(1, _);
  }
  function input4_change_handler() {
    b = this.checked;
    o(2, b);
  }
  const click_handler = () => nextWeek(), click_handler_1 = s => openFile(s.path), click_handler_2 = s => showHistory(s.path, s.rev), click_handler_3 = () => prevWeek();
  s.$$set = s => {
    if ("plugin" in s) o(11, u = s.plugin);
  };
  s.$$.update = () => {
    if (31 & s.$$.dirty) {
      w = new Date(L).getTime() + S;
      E = new Date(O).getTime() + S;
      getHistory(g, _, b);
    }
  };
  return [ g, _, b, L, O, D, k, nextWeek, prevWeek, showHistory, openFile, u, input0_input_handler, input1_input_handler, input2_change_handler, input3_change_handler, input4_change_handler, click_handler, click_handler_1, click_handler_2, click_handler_3 ];
}

var GlobalHistory = class extends SvelteComponent {
  constructor(s) {
    super();
    init2(this, s, instance4, create_fragment4, safe_not_equal, {
      plugin: 11
    }, add_css4);
  }
}, GlobalHistory_default = GlobalHistory, VIEW_TYPE_GLOBAL_HISTORY = "global-history", GlobalHistoryView = class extends import_obsidian.ItemView {
  constructor(s, r) {
    super(s);
    this.plugin = r;
  }
  getIcon() {
    return "clock";
  }
  getViewType() {
    return VIEW_TYPE_GLOBAL_HISTORY;
  }
  getDisplayText() {
    return "Vault history";
  }
  async onOpen() {
    this.component = new GlobalHistory_default({
      target: this.contentEl,
      props: {
        plugin: this.plugin
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
}, import_obsidian4 = require("obsidian");

function add_css5(s) {
  append_styles(s, "svelte-1j0mkaj", ".svelte-1j0mkaj.svelte-1j0mkaj{box-sizing:border-box}.logpane.svelte-1j0mkaj.svelte-1j0mkaj{display:flex;height:100%;flex-direction:column}.log.svelte-1j0mkaj.svelte-1j0mkaj{overflow-y:scroll;user-select:text;padding-bottom:2em}.log.svelte-1j0mkaj>pre.svelte-1j0mkaj{margin:0}.log.svelte-1j0mkaj>pre.wrap-right.svelte-1j0mkaj{word-break:break-all;max-width:100%;width:100%;white-space:normal}.row.svelte-1j0mkaj.svelte-1j0mkaj{display:flex;flex-direction:row;justify-content:flex-end}.row.svelte-1j0mkaj>label.svelte-1j0mkaj{display:flex;align-items:center;min-width:5em;margin-right:1em}");
}

function get_each_context5(s, r, o) {
  const u = s.slice();
  u[10] = r[o];
  return u;
}

function create_each_block5(s) {
  let r, o = s[10] + "", u;
  return {
    c() {
      r = element("pre");
      u = text(o);
      attr(r, "class", "svelte-1j0mkaj");
      toggle_class(r, "wrap-right", s[1]);
    },
    m(s, o) {
      insert(s, r, o);
      append(r, u);
    },
    p(s, g) {
      if (1 & g && o !== (o = s[10] + "")) set_data(u, o);
      if (2 & g) toggle_class(r, "wrap-right", s[1]);
    },
    d(s) {
      if (s) detach(r);
    }
  };
}

function create_fragment5(s) {
  let r, o, u, g, _, b, w, E, S, L, O, D, k, C, T, I, A, x, R, P, N = ensure_array_like(s[0]), B = [];
  for (let r = 0; r < N.length; r += 1) B[r] = create_each_block5(get_each_context5(s, N, r));
  return {
    c() {
      r = element("div");
      o = comment(" <h1>Self-hosted LiveSync Log</h1> ");
      u = space();
      g = element("div");
      _ = element("div");
      b = element("label");
      w = element("input");
      E = element("span");
      E.textContent = "Wrap";
      S = space();
      L = element("label");
      O = element("input");
      D = element("span");
      D.textContent = "Auto scroll";
      k = space();
      C = element("label");
      T = element("input");
      I = element("span");
      I.textContent = "Pause";
      A = space();
      x = element("div");
      for (let s = 0; s < B.length; s += 1) B[s].c();
      attr(w, "type", "checkbox");
      attr(w, "class", "svelte-1j0mkaj");
      attr(E, "class", "svelte-1j0mkaj");
      attr(b, "class", "svelte-1j0mkaj");
      attr(O, "type", "checkbox");
      attr(O, "class", "svelte-1j0mkaj");
      attr(D, "class", "svelte-1j0mkaj");
      attr(L, "class", "svelte-1j0mkaj");
      attr(T, "type", "checkbox");
      attr(T, "class", "svelte-1j0mkaj");
      attr(I, "class", "svelte-1j0mkaj");
      attr(C, "class", "svelte-1j0mkaj");
      attr(_, "class", "row svelte-1j0mkaj");
      attr(g, "class", "control svelte-1j0mkaj");
      attr(x, "class", "log svelte-1j0mkaj");
      attr(r, "class", "logpane svelte-1j0mkaj");
    },
    m(N, F) {
      insert(N, r, F);
      append(r, o);
      append(r, u);
      append(r, g);
      append(g, _);
      append(_, b);
      append(b, w);
      w.checked = s[1];
      append(b, E);
      append(_, S);
      append(_, L);
      append(L, O);
      O.checked = s[2];
      append(L, D);
      append(_, k);
      append(_, C);
      append(C, T);
      T.checked = s[3];
      append(C, I);
      append(r, A);
      append(r, x);
      for (let s = 0; s < B.length; s += 1) if (B[s]) B[s].m(x, null);
      s[8](x);
      if (!R) {
        P = [ listen(w, "change", s[5]), listen(O, "change", s[6]), listen(T, "change", s[7]) ];
        R = true;
      }
    },
    p(s, [r]) {
      if (2 & r) w.checked = s[1];
      if (4 & r) O.checked = s[2];
      if (8 & r) T.checked = s[3];
      if (3 & r) {
        N = ensure_array_like(s[0]);
        let o;
        for (o = 0; o < N.length; o += 1) {
          const u = get_each_context5(s, N, o);
          if (B[o]) B[o].p(u, r); else {
            B[o] = create_each_block5(u);
            B[o].c();
            B[o].m(x, null);
          }
        }
        for (;o < B.length; o += 1) B[o].d(1);
        B.length = N.length;
      }
    },
    i: noop,
    o: noop,
    d(o) {
      if (o) detach(r);
      destroy_each(B, o);
      s[8](null);
      R = false;
      run_all(P);
    }
  };
}

function instance5(s, r, o) {
  let u, g = [], _ = false, b = true, w = false, E;
  onMount((async () => {
    u = logMessageStore.observe((s => {
      if (!w) {
        o(0, g = [ ...s ]);
        if (b) if (E) o(4, E.scrollTop = E.scrollHeight, E);
      }
    }));
    logMessageStore.invalidate();
    setTimeout((() => {
      if (E) o(4, E.scrollTop = E.scrollHeight, E);
    }), 100);
  }));
  onDestroy((() => {
    if (u) u();
  }));
  function input0_change_handler() {
    _ = this.checked;
    o(1, _);
  }
  function input1_change_handler() {
    b = this.checked;
    o(2, b);
  }
  function input2_change_handler() {
    w = this.checked;
    o(3, w);
  }
  function div2_binding(s) {
    binding_callbacks[s ? "unshift" : "push"]((() => {
      E = s;
      o(4, E);
    }));
  }
  return [ g, _, b, w, E, input0_change_handler, input1_change_handler, input2_change_handler, div2_binding ];
}

var LogPane = class extends SvelteComponent {
  constructor(s) {
    super();
    init2(this, s, instance5, create_fragment5, safe_not_equal, {}, add_css5);
  }
}, LogPane_default = LogPane, VIEW_TYPE_LOG = "log-log", LogPaneView = class extends import_obsidian4.ItemView {
  constructor(s, r) {
    super(s);
    this.plugin = r;
  }
  getIcon() {
    return "view-log";
  }
  getViewType() {
    return VIEW_TYPE_LOG;
  }
  getDisplayText() {
    return "Self-hosted LiveSync Log";
  }
  async onOpen() {
    this.component = new LogPane_default({
      target: this.contentEl,
      props: {}
    });
  }
  async onClose() {
    this.component.$destroy();
  }
}, isDebug = false;

setNoticeClass(import_obsidian.Notice);

setGlobalLogFunction(((s, r, o) => {
  const u = {
    message: s,
    level: r,
    key: o
  };
  logStore.push(u);
}));

logStore.intercept((s => s.slice(Math.min(s.length - 200, 0))));

var ObsidianLiveSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.isMobile = false;
    this.isReady = false;
    this.packageVersion = "";
    this.manifestVersion = "";
    this.addOnHiddenFileSync = new HiddenFileSync(this);
    this.addOnSetup = new SetupLiveSync(this);
    this.addOnConfigSync = new ConfigSync(this);
    this.addOns = [ this.addOnHiddenFileSync, this.addOnSetup, this.addOnConfigSync ];
    this.periodicSyncProcessor = new PeriodicProcessor(this, (async () => await this.replicate()));
    this.last_successful_post = false;
    this.processReplication = s => this.parseReplicationResult(s);
    this.replicationStat = new ObservableStore({
      sent: 0,
      arrived: 0,
      maxPullSeq: 0,
      maxPushSeq: 0,
      lastSyncPullSeq: 0,
      lastSyncPushSeq: 0,
      syncStatus: "CLOSED"
    });
    this.usedPassphrase = "";
    this.notifies = {};
    this.lastLog = "";
    this.queuedEntries = [];
    this.dbChangeProcRunning = false;
    this.queuedFiles = [];
    this.queuedFilesStore = getGlobalStore("queuedFiles", {
      queuedItems: [],
      fileEventItems: []
    });
    this.chunkWaitTimeout = 6e4;
    this.lastMessage = "";
    this.conflictedCheckFiles = [];
    this.ignoreFileCache = new LRUCache(300, 25e4, true);
    this.ignoreFiles = [];
  }
  getLastPostFailedBySize() {
    return !this.last_successful_post;
  }
  async fetchByAPI(s) {
    var r, o;
    const u = await (0, import_obsidian.requestUrl)(s);
    if (u.status - u.status % 100 != 200) {
      const s = new Error(`Request Error:${u.status}`);
      if (u.json) {
        s.message = u.json.reason;
        s.name = `${null != (r = u.json.error) ? r : ""}:${null != (o = u.json.message) ? o : ""}`;
      }
      s.status = u.status;
      throw s;
    }
    return u;
  }
  getDatabase() {
    return this.localDatabase.localDatabase;
  }
  getSettings() {
    return this.settings;
  }
  getIsMobile() {
    return this.isMobile;
  }
  async connectRemoteCouchDB(s, r, o, u, g, _, b) {
    if (!isValidRemoteCouchDBURI(s)) return "Remote URI is not valid";
    if (s.toLowerCase() != s) return "Remote URI and database name could not contain capital letters.";
    if (-1 !== s.indexOf(" ")) return "Remote URI and database name could not contain spaces.";
    let w = "";
    if (r.username && r.password) {
      const s = String.fromCharCode.apply(null, (new TextEncoder).encode(`${r.username}:${r.password}`)), o = window.btoa(s);
      w = "Basic " + o;
    } else w = "";
    const E = void 0, S = new index_es_default(s, {
      adapter: "http",
      auth: r,
      skip_setup: !_,
      fetch: async (r, u) => {
        var g, _;
        let b = "";
        const E = r.toString().substring(s.length), S = null != (g = u.method) ? g : "GET";
        if (u.body) {
          const r = u.body.toString().length;
          if (r > 1e7) if (isCloudantURI(s)) {
            this.last_successful_post = false;
            Logger("This request should fail on IBM Cloudant.", LOG_LEVEL_VERBOSE);
            throw new Error("This request should fail on IBM Cloudant.");
          }
          b = ` (${r})`;
        }
        if (!o && "string" == typeof r && "string" == typeof (null != (_ = u.body) ? _ : "")) {
          const s = u.body, o = {
            ...u.headers
          };
          if ("" != w) o["authorization"] = w;
          delete o["host"];
          delete o["Host"];
          delete o["content-length"];
          delete o["Content-Length"];
          const g = {
            url: r,
            method: u.method,
            body: s,
            headers: o,
            contentType: "application/json"
          };
          try {
            const s = await this.fetchByAPI(g);
            if ("POST" == S || "PUT" == S) this.last_successful_post = s.status - s.status % 100 == 200; else this.last_successful_post = true;
            Logger(`HTTP:${S}${b} to:${E} -> ${s.status}`, LOG_LEVEL_DEBUG);
            return new Response(s.arrayBuffer, {
              headers: s.headers,
              status: s.status,
              statusText: `${s.status}`
            });
          } catch (s) {
            Logger(`HTTP:${S}${b} to:${E} -> failed`, LOG_LEVEL_VERBOSE);
            if (-1 !== r.toString().indexOf("_bulk_docs")) this.last_successful_post = false;
            Logger(s);
            throw s;
          }
        }
        try {
          const s = await fetch(r, u);
          if ("POST" == S || "PUT" == S) this.last_successful_post = s.ok; else this.last_successful_post = true;
          Logger(`HTTP:${S}${b} to:${E} -> ${s.status}`, LOG_LEVEL_DEBUG);
          return s;
        } catch (s) {
          Logger(`HTTP:${S}${b} to:${E} -> failed`, LOG_LEVEL_VERBOSE);
          if (-1 !== r.toString().indexOf("_bulk_docs")) this.last_successful_post = false;
          Logger(s);
          throw s;
        }
      }
    });
    if ("false" !== u && "string" == typeof u) enableEncryption(S, u, g);
    if (b) return {
      db: S,
      info: {
        db_name: "",
        doc_count: 0,
        update_seq: ""
      }
    };
    try {
      const s = await S.info();
      return {
        db: S,
        info: s
      };
    } catch (s) {
      let r = `${s.name}:${s.message}`;
      if ("TypeError" == s.name && "Failed to fetch" == s.message) r += "\n**Note** This error caused by many reasons. The only sure thing is you didn't touch the server.\nTo check details, open inspector.";
      Logger(s, LOG_LEVEL_VERBOSE);
      return r;
    }
  }
  id2path(s, r, o) {
    const u = id2path(s, r);
    if (o && isInternalMetadata(u)) {
      const s = void 0;
      return stripInternalMetadataPrefix(u);
    }
    return u;
  }
  getPath(s) {
    return getPath2(s);
  }
  getPathWithoutPrefix(s) {
    return getPathWithoutPrefix(s);
  }
  async path2id(s, r) {
    const o = addPrefix(s, r);
    return await path2id(o, this.settings.usePathObfuscation ? this.settings.passphrase : "");
  }
  createPouchDBInstance(s, r) {
    if (this.settings.useIndexedDBAdapter) {
      r.adapter = "indexeddb";
      r.purged_infos_limit = 1;
      return new index_es_default(s + "-indexeddb", r);
    }
    return new index_es_default(s, r);
  }
  beforeOnUnload(s) {
    this.kvDB.close();
  }
  onClose(s) {
    this.kvDB.close();
  }
  async onInitializeDatabase(s) {
    this.kvDB = await OpenKeyValueDatabase(s.dbname + "-livesync-kv");
    this.replicator = new LiveSyncDBReplicator(this);
  }
  async onResetDatabase(s) {
    await this.kvDB.destroy();
    this.kvDB = await OpenKeyValueDatabase(s.dbname + "-livesync-kv");
    this.replicator = new LiveSyncDBReplicator(this);
  }
  getReplicator() {
    return this.replicator;
  }
  getVaultName() {
    var s;
    return this.app.vault.getName() + ((null == (s = this.settings) ? void 0 : s.additionalSuffixOfDatabaseName) ? "-" + this.settings.additionalSuffixOfDatabaseName : "");
  }
  setInterval(s, r) {
    const o = window.setInterval(s, r);
    this.registerInterval(o);
    return o;
  }
  isRedFlagRaised() {
    const s = void 0;
    if (null != getAbstractFileByPath(normalizePath(FLAGMD_REDFLAG))) return true;
    return false;
  }
  isRedFlag2Raised() {
    const s = void 0;
    if (null != getAbstractFileByPath(normalizePath(FLAGMD_REDFLAG2))) return true;
    return false;
  }
  async deleteRedFlag2() {
    const s = getAbstractFileByPath(normalizePath(FLAGMD_REDFLAG2));
    if (null != s) await app.vault.delete(s, true);
  }
  isRedFlag3Raised() {
    const s = void 0;
    if (null != getAbstractFileByPath(normalizePath(FLAGMD_REDFLAG3))) return true;
    return false;
  }
  async deleteRedFlag3() {
    const s = getAbstractFileByPath(normalizePath(FLAGMD_REDFLAG3));
    if (null != s) await app.vault.delete(s, true);
  }
  showHistory(s, r) {
    new DocumentHistoryModal(this.app, this, s, r).open();
  }
  async fileHistory() {
    const s = [];
    for await (const r of this.localDatabase.findAllDocs()) s.push({
      id: r._id,
      path: this.getPath(r),
      dispPath: this.getPathWithoutPrefix(r),
      mtime: r.mtime
    });
    s.sort(((s, r) => r.mtime - s.mtime));
    const r = s.map((s => s.dispPath)), o = await askSelectString(this.app, "File to view History", r);
    if (o) {
      const r = s.find((s => s.dispPath == o));
      this.showHistory(r.path, void 0);
    }
  }
  async pickFileForResolve() {
    const s = [];
    for await (const r of this.localDatabase.findAllDocs({
      conflicts: true
    })) {
      if (!("_conflicts" in r)) continue;
      s.push({
        id: r._id,
        path: this.getPath(r),
        dispPath: this.getPathWithoutPrefix(r),
        mtime: r.mtime
      });
    }
    s.sort(((s, r) => r.mtime - s.mtime));
    const r = s.map((s => s.dispPath));
    if (0 == r.length) {
      Logger("There are no conflicted documents", LOG_LEVEL_NOTICE);
      return false;
    }
    const o = await askSelectString(this.app, "File to view History", r);
    if (o) {
      const r = s.find((s => s.dispPath == o));
      await this.resolveConflicted(r.path);
      return true;
    }
    return false;
  }
  async resolveConflicted(s) {
    if (isInternalMetadata(s)) await this.addOnHiddenFileSync.resolveConflictOnInternalFile(s); else if (isPluginMetadata(s)) await this.resolveConflictByNewerEntry(s); else await this.showIfConflicted(s);
  }
  async collectDeletedFiles() {
    const s = this.settings.automaticallyDeleteMetadataOfDeletedFiles;
    if (s <= 0) return;
    Logger("Checking expired file history");
    const r = Date.now() - 864e5 * s, o = [];
    for await (const s of this.localDatabase.findAllDocs({
      conflicts: true
    })) if ("newnote" == s.type || "plain" == s.type) if (s.deleted && s.mtime - r < 0) o.push({
      path: this.getPath(s),
      mtime: s.mtime,
      ttl: (s.mtime - r) / 1e3 / 86400,
      doc: s
    });
    if (0 == o.length) {
      Logger("There are no old documents");
      Logger("Checking expired file history done");
      return;
    }
    for (const s of o) {
      Logger(`Deletion history expired: ${s.path}`);
      const r = s.doc;
      r._deleted = true;
      await this.localDatabase.putRaw(r);
    }
    Logger("Checking expired file history done");
  }
  async onLayoutReady() {
    this.registerFileWatchEvents();
    if (!this.localDatabase.isReady) {
      Logger("Something went wrong! The local database is not ready", LOG_LEVEL_NOTICE);
      return;
    }
    try {
      if (this.isRedFlagRaised() || this.isRedFlag2Raised() || this.isRedFlag3Raised()) {
        this.settings.batchSave = false;
        this.addOnSetup.suspendAllSync();
        this.addOnSetup.suspendExtraSync();
        this.settings.suspendFileWatching = true;
        await this.saveSettings();
        if (this.isRedFlag2Raised()) {
          Logger(`${FLAGMD_REDFLAG2} has been detected! Self-hosted LiveSync suspends all sync and rebuild everything.`, LOG_LEVEL_NOTICE);
          await this.addOnSetup.rebuildEverything();
          await this.deleteRedFlag2();
          if ("yes" == await askYesNo(this.app, "Do you want to disable Suspend file watching and restart obsidian now?")) {
            this.settings.suspendFileWatching = false;
            await this.saveSettings();
            this.app.commands.executeCommandById("app:reload");
          }
        } else if (this.isRedFlag3Raised()) {
          Logger(`${FLAGMD_REDFLAG3} has been detected! Self-hosted LiveSync will discard the local database and fetch everything from the remote once again.`, LOG_LEVEL_NOTICE);
          await this.addOnSetup.fetchLocal();
          await this.deleteRedFlag3();
          if (this.settings.suspendFileWatching) if ("yes" == await askYesNo(this.app, "Do you want to disable Suspend file watching and restart obsidian now?")) {
            this.settings.suspendFileWatching = false;
            await this.saveSettings();
            this.app.commands.executeCommandById("app:reload");
          }
        } else {
          this.settings.writeLogToTheFile = true;
          await this.openDatabase();
          const s = "The red flag is raised! The whole initialize steps are skipped, and any file changes are not captured.";
          Logger(s, LOG_LEVEL_NOTICE);
          this.setStatusBarText(s);
        }
      } else {
        if (this.settings.suspendFileWatching) Logger("'Suspend file watching' turned on. Are you sure this is what you intended? Every modification on the vault will be ignored.", LOG_LEVEL_NOTICE);
        if (this.settings.suspendParseReplicationResult) Logger("'Suspend database reflecting' turned on. Are you sure this is what you intended? Every replicated change will be postponed until disabling this option.", LOG_LEVEL_NOTICE);
        const s = void 0;
        if (!await this.initializeDatabase(false, false)) return false;
      }
      await this.realizeSettingSyncMode();
      this.registerWatchEvents();
      if (this.settings.syncOnStart) this.replicator.openReplication(this.settings, false, false);
      this.scanStat();
    } catch (s) {
      Logger("Error while loading Self-hosted LiveSync", LOG_LEVEL_NOTICE);
      Logger(s, LOG_LEVEL_VERBOSE);
    }
  }
  async scanStat() {
    const s = [];
    Logger("Additional safety scan..", LOG_LEVEL_VERBOSE);
    for await (const r of this.localDatabase.findAllDocs({
      conflicts: true
    })) {
      if (!("_conflicts" in r)) continue;
      s.push({
        path: this.getPath(r),
        mtime: r.mtime
      });
    }
    if (s.length > 0) {
      Logger('Some files have been left conflicted! Please resolve them by "Pick a file to resolve conflict". The list is written in the log.', LOG_LEVEL_NOTICE);
      for (const r of s) Logger(`Conflicted: ${r.path}`);
    } else Logger("There are no conflicted files", LOG_LEVEL_VERBOSE);
    Logger("Additional safety scan done", LOG_LEVEL_VERBOSE);
  }
  async onload() {
    logStore.subscribe((s => this.addLog(s.message, s.level, s.key)));
    Logger("loading plugin");
    const s = "0.19.19", r = "0.19.19";
    this.manifestVersion = s;
    this.packageVersion = r;
    Logger(`Self-hosted LiveSync v${s} ${r} `);
    const o = "obsidian-live-sync-ver" + this.getVaultName(), u = localStorage.getItem(o);
    await this.loadSettings();
    const g = void 0;
    if (~~(versionNumberString2Number(s) / 1e3) > this.settings.lastReadUpdates) Logger("Self-hosted LiveSync has undergone a major upgrade. Please open the setting dialog, and check the information pane.", LOG_LEVEL_NOTICE);
    if (this.app.isMobile) {
      this.isMobile = true;
      this.settings.disableRequestURI = true;
    }
    if (u && Number(u) < VER) {
      this.settings.liveSync = false;
      this.settings.syncOnSave = false;
      this.settings.syncOnStart = false;
      this.settings.syncOnFileOpen = false;
      this.settings.syncAfterMerge = false;
      this.settings.periodicReplication = false;
      this.settings.versionUpFlash = "Self-hosted LiveSync has been upgraded and some behaviors have changed incompatibly. All automatic synchronization is now disabled temporary. Ensure that other devices are also upgraded, and enable synchronization again.";
      this.saveSettings();
    }
    localStorage.setItem(o, `${VER}`);
    await this.openDatabase();
    this.watchWorkspaceOpen = (0, import_obsidian.debounce)(this.watchWorkspaceOpen.bind(this), 1e3, false);
    this.watchWindowVisibility = (0, import_obsidian.debounce)(this.watchWindowVisibility.bind(this), 1e3, false);
    this.watchOnline = (0, import_obsidian.debounce)(this.watchOnline.bind(this), 500, false);
    this.parseReplicationResult = this.parseReplicationResult.bind(this);
    this.loadQueuedFiles = this.loadQueuedFiles.bind(this);
    this.triggerRealizeSettingSyncMode = (0, import_obsidian.debounce)(this.triggerRealizeSettingSyncMode.bind(this), 1e3);
    this.statusBar = this.addStatusBarItem();
    this.statusBar.addClass("syncstatusbar");
    (0, import_obsidian.addIcon)("replicate", '<g transform="matrix(1.15 0 0 1.15 -8.31 -9.52)" fill="currentColor" fill-rule="evenodd">\n            <path d="m85 22.2c-0.799-4.74-4.99-8.37-9.88-8.37-0.499 0-1.1 0.101-1.6 0.101-2.4-3.03-6.09-4.94-10.3-4.94-6.09 0-11.2 4.14-12.8 9.79-5.59 1.11-9.78 6.05-9.78 12 0 6.76 5.39 12.2 12 12.2h29.9c5.79 0 10.1-4.74 10.1-10.6 0-4.84-3.29-8.88-7.68-10.2zm-2.99 14.7h-29.5c-2.3-0.202-4.29-1.51-5.29-3.53-0.899-2.12-0.699-4.54 0.698-6.46 1.2-1.61 2.99-2.52 4.89-2.52 0.299 0 0.698 0 0.998 0.101l1.8 0.303v-2.02c0-3.63 2.4-6.76 5.89-7.57 0.599-0.101 1.2-0.202 1.8-0.202 2.89 0 5.49 1.62 6.79 4.24l0.598 1.21 1.3-0.504c0.599-0.202 1.3-0.303 2-0.303 1.3 0 2.5 0.404 3.59 1.11 1.6 1.21 2.6 3.13 2.6 5.15v1.61h2c2.6 0 4.69 2.12 4.69 4.74-0.099 2.52-2.2 4.64-4.79 4.64z"/>\n            <path d="m53.2 49.2h-41.6c-1.8 0-3.2 1.4-3.2 3.2v28.6c0 1.8 1.4 3.2 3.2 3.2h15.8v4h-7v6h24v-6h-7v-4h15.8c1.8 0 3.2-1.4 3.2-3.2v-28.6c0-1.8-1.4-3.2-3.2-3.2zm-2.8 29h-36v-23h36z"/>\n            <path d="m73 49.2c1.02 1.29 1.53 2.97 1.53 4.56 0 2.97-1.74 5.65-4.39 7.04v-4.06l-7.46 7.33 7.46 7.14v-4.06c7.66-1.98 12.2-9.61 10-17-0.102-0.297-0.205-0.595-0.307-0.892z"/>\n            <path d="m24.1 43c-0.817-0.991-1.53-2.97-1.53-4.56 0-2.97 1.74-5.65 4.39-7.04v4.06l7.46-7.33-7.46-7.14v4.06c-7.66 1.98-12.2 9.61-10 17 0.102 0.297 0.205 0.595 0.307 0.892z"/>\n           </g>');
    (0, import_obsidian.addIcon)("view-log", '<g transform="matrix(1.28 0 0 1.28 -131 -411)" fill="currentColor" fill-rule="evenodd">\n        <path d="m103 330h76v12h-76z"/>\n        <path d="m106 346v44h70v-44zm45 16h-20v-8h20z"/>\n       </g>');
    await Promise.all(this.addOns.map((s => s.onload())));
    this.addRibbonIcon("replicate", "Replicate", (async () => {
      await this.replicate(true);
    }));
    this.addRibbonIcon("view-log", "Show log", (() => {
      this.showView(VIEW_TYPE_LOG);
    }));
    this.addSettingTab(new ObsidianLiveSyncSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
    this.addCommand({
      id: "livesync-replicate",
      name: "Replicate now",
      callback: async () => {
        await this.replicate();
      }
    });
    this.addCommand({
      id: "livesync-dump",
      name: "Dump information of this doc ",
      editorCallback: (s, r) => {
        this.localDatabase.getDBEntry(getPathFromTFile(r.file), {}, true, false);
      }
    });
    this.addCommand({
      id: "livesync-checkdoc-conflicted",
      name: "Resolve if conflicted.",
      editorCallback: async (s, r) => {
        await this.showIfConflicted(getPathFromTFile(r.file));
      }
    });
    this.addCommand({
      id: "livesync-toggle",
      name: "Toggle LiveSync",
      callback: async () => {
        if (this.settings.liveSync) {
          this.settings.liveSync = false;
          Logger("LiveSync Disabled.", LOG_LEVEL_NOTICE);
        } else {
          this.settings.liveSync = true;
          Logger("LiveSync Enabled.", LOG_LEVEL_NOTICE);
        }
        await this.realizeSettingSyncMode();
        this.saveSettings();
      }
    });
    this.addCommand({
      id: "livesync-suspendall",
      name: "Toggle All Sync.",
      callback: async () => {
        if (this.suspended) {
          this.suspended = false;
          Logger("Self-hosted LiveSync resumed", LOG_LEVEL_NOTICE);
        } else {
          this.suspended = true;
          Logger("Self-hosted LiveSync suspended", LOG_LEVEL_NOTICE);
        }
        await this.realizeSettingSyncMode();
        this.saveSettings();
      }
    });
    this.addCommand({
      id: "livesync-history",
      name: "Show history",
      editorCallback: (s, r) => {
        this.showHistory(r.file, null);
      }
    });
    this.addCommand({
      id: "livesync-scan-files",
      name: "Scan storage and database again",
      callback: async () => {
        await this.syncAllFiles(true);
      }
    });
    this.triggerRealizeSettingSyncMode = (0, import_obsidian.debounce)(this.triggerRealizeSettingSyncMode.bind(this), 1e3);
    this.addCommand({
      id: "livesync-filehistory",
      name: "Pick a file to show history",
      callback: () => {
        this.fileHistory();
      }
    });
    this.addCommand({
      id: "livesync-conflictcheck",
      name: "Pick a file to resolve conflict",
      callback: () => {
        this.pickFileForResolve();
      }
    });
    this.addCommand({
      id: "livesync-all-conflictcheck",
      name: "Resolve all conflicted files",
      callback: async () => {
        for (;await this.pickFileForResolve(); ) ;
      }
    });
    this.addCommand({
      id: "livesync-runbatch",
      name: "Run pended batch processes",
      callback: async () => {
        await this.applyBatchChange();
      }
    });
    this.addCommand({
      id: "livesync-abortsync",
      name: "Abort synchronization immediately",
      callback: () => {
        this.replicator.terminateSync();
      }
    });
    this.registerView(VIEW_TYPE_GLOBAL_HISTORY, (s => new GlobalHistoryView(s, this)));
    this.registerView(VIEW_TYPE_LOG, (s => new LogPaneView(s, this)));
    this.addCommand({
      id: "livesync-global-history",
      name: "Show vault history",
      callback: () => {
        this.showGlobalHistory();
      }
    });
  }
  async showView(s) {
    const r = this.app.workspace.getLeavesOfType(s);
    if (0 == r.length) await this.app.workspace.getLeaf(true).setViewState({
      type: s,
      active: true
    }); else r[0].setViewState({
      type: s,
      active: true
    });
    if (r.length > 0) this.app.workspace.revealLeaf(r[0]);
  }
  showGlobalHistory() {
    this.showView(VIEW_TYPE_GLOBAL_HISTORY);
  }
  onunload() {
    var s;
    for (const s of this.addOns) s.onunload();
    if (null != this.localDatabase) this.localDatabase.onunload();
    null == (s = this.periodicSyncProcessor) || s.disable();
    if (null != this.localDatabase) {
      this.replicator.closeReplication();
      this.localDatabase.close();
    }
    cancelAllPeriodicTask();
    cancelAllTasks();
    Logger("unloading plugin");
  }
  async openDatabase() {
    if (null != this.localDatabase) await this.localDatabase.close();
    const s = this.getVaultName();
    Logger("Waiting for ready...");
    this.isMobile = this.app.isMobile;
    this.localDatabase = new LiveSyncLocalDB(s, this);
    this.observeForLogs();
    return await this.localDatabase.initializeDatabase();
  }
  getPassphrase(s) {
    const r = {
      "": () => Promise.resolve("*"),
      LOCALSTORAGE: () => {
        var s;
        return Promise.resolve(null != (s = localStorage.getItem("ls-setting-passphrase")) ? s : false);
      },
      ASK_AT_LAUNCH: () => askString(this.app, "Passphrase", "passphrase", "")
    }, o = s.configPassphraseStore, u = void 0;
    return (o in r ? r[o] : r[""])();
  }
  async decryptConfigurationItem(s, r) {
    const o = await tryDecrypt(s, r + SALT_OF_PASSPHRASE, false);
    if (o) {
      this.usedPassphrase = r;
      return o;
    }
    return false;
  }
  tryDecodeJson(s) {
    try {
      if (!s) return false;
      return JSON.parse(s);
    } catch (s) {
      return false;
    }
  }
  async encryptConfigurationItem(s, r) {
    if ("" != this.usedPassphrase) return await encrypt(s, this.usedPassphrase + SALT_OF_PASSPHRASE, false);
    const o = await this.getPassphrase(r);
    if (false === o) {
      Logger("Could not determine passphrase to save data.json! You probably make the configuration sure again!", LOG_LEVEL_URGENT);
      return "";
    }
    const u = await encrypt(s, o + SALT_OF_PASSPHRASE, false);
    if (u) {
      this.usedPassphrase = o;
      return u;
    }
    return "";
  }
  async loadSettings() {
    const s = Object.assign({}, DEFAULT_SETTINGS, await this.loadData()), r = await this.getPassphrase(s);
    if (false === r) Logger("Could not determine passphrase for reading data.json! DO NOT synchronize with the remote before making sure your configuration is!", LOG_LEVEL_URGENT); else {
      if (s.encryptedCouchDBConnection) {
        const o = [ "couchDB_URI", "couchDB_USER", "couchDB_PASSWORD", "couchDB_DBNAME" ], u = this.tryDecodeJson(await this.decryptConfigurationItem(s.encryptedCouchDBConnection, r));
        if (u) {
          for (const r of o) if (r in u) s[r] = u[r];
        } else {
          Logger("Could not decrypt passphrase for reading data.json! DO NOT synchronize with the remote before making sure your configuration is!", LOG_LEVEL_URGENT);
          for (const r of o) s[r] = "";
        }
      }
      if (s.encrypt && s.encryptedPassphrase) {
        const o = s.encryptedPassphrase, u = await this.decryptConfigurationItem(o, r);
        if (u) s.passphrase = u; else {
          Logger("Could not decrypt passphrase for reading data.json! DO NOT synchronize with the remote before making sure your configuration is!", LOG_LEVEL_URGENT);
          s.passphrase = "";
        }
      }
    }
    this.settings = s;
    if ("workingEncrypt" in this.settings) delete this.settings.workingEncrypt;
    if ("workingPassphrase" in this.settings) delete this.settings.workingPassphrase;
    this.settings.disableRequestURI = true;
    this.settings.gcDelay = 0;
    this.settings.useHistory = true;
    const o = "obsidian-live-sync-vaultanddevicename-" + this.getVaultName();
    if ("" != this.settings.deviceAndVaultName) if (!localStorage.getItem(o)) {
      this.deviceAndVaultName = this.settings.deviceAndVaultName;
      localStorage.setItem(o, this.deviceAndVaultName);
      this.settings.deviceAndVaultName = "";
    }
    if (isCloudantURI(this.settings.couchDB_URI) && 0 != this.settings.customChunkSize) {
      Logger("Configuration verification founds problems with your configuration. This has been fixed automatically. But you may already have data that cannot be synchronised. If this is the case, please rebuild everything.", LOG_LEVEL_NOTICE);
      this.settings.customChunkSize = 0;
    }
    this.deviceAndVaultName = localStorage.getItem(o) || "";
    this.ignoreFiles = this.settings.ignoreFiles.split(",").map((s => s.trim()));
  }
  triggerRealizeSettingSyncMode() {
    (async () => {
      await this.realizeSettingSyncMode();
    })();
  }
  async saveSettings() {
    const s = "obsidian-live-sync-vaultanddevicename-" + this.getVaultName();
    localStorage.setItem(s, this.deviceAndVaultName || "");
    const r = {
      ...this.settings
    };
    if ("" == this.usedPassphrase && !await this.getPassphrase(r)) Logger("Could not determine passphrase for saving data.json! Our data.json have insecure items!", LOG_LEVEL_NOTICE); else {
      if ("" != r.couchDB_PASSWORD || "" != r.couchDB_URI || "" != r.couchDB_USER || r.couchDB_DBNAME) {
        const s = {
          couchDB_DBNAME: r.couchDB_DBNAME,
          couchDB_PASSWORD: r.couchDB_PASSWORD,
          couchDB_URI: r.couchDB_URI,
          couchDB_USER: r.couchDB_USER
        };
        r.encryptedCouchDBConnection = await this.encryptConfigurationItem(JSON.stringify(s), r);
        r.couchDB_PASSWORD = "";
        r.couchDB_DBNAME = "";
        r.couchDB_URI = "";
        r.couchDB_USER = "";
      }
      if (r.encrypt && "" != r.passphrase) {
        r.encryptedPassphrase = await this.encryptConfigurationItem(r.passphrase, r);
        r.passphrase = "";
      }
    }
    await this.saveData(r);
    this.localDatabase.settings = this.settings;
    this.ignoreFiles = this.settings.ignoreFiles.split(",").map((s => s.trim()));
    this.triggerRealizeSettingSyncMode();
  }
  registerFileWatchEvents() {
    this.vaultManager = new StorageEventManagerObsidian(this);
  }
  registerWatchEvents() {
    this.registerEvent(this.app.workspace.on("file-open", this.watchWorkspaceOpen));
    this.registerDomEvent(document, "visibilitychange", this.watchWindowVisibility);
    this.registerDomEvent(window, "online", this.watchOnline);
    this.registerDomEvent(window, "offline", this.watchOnline);
  }
  watchOnline() {
    this.watchOnlineAsync();
  }
  async watchOnlineAsync() {
    if (navigator.onLine && this.localDatabase.needScanning) {
      this.localDatabase.needScanning = false;
      await this.syncAllFiles();
    }
  }
  watchWindowVisibility() {
    this.watchWindowVisibilityAsync();
  }
  async watchWindowVisibilityAsync() {
    var s;
    if (this.settings.suspendFileWatching) return;
    if (!this.isReady) return;
    const r = document.hidden;
    await this.applyBatchChange();
    if (r) {
      this.replicator.closeReplication();
      null == (s = this.periodicSyncProcessor) || s.disable();
    } else {
      if (this.suspended) return;
      await Promise.all(this.addOns.map((s => s.onResume())));
      if (this.settings.liveSync) this.replicator.openReplication(this.settings, true, false);
      if (this.settings.syncOnStart) this.replicator.openReplication(this.settings, false, false);
      this.periodicSyncProcessor.enable(this.settings.periodicReplication ? 1e3 * this.settings.periodicReplicationInterval : 0);
    }
  }
  async procFileEvent(s) {
    if (!this.isReady) return;
    if (this.settings.batchSave && !this.settings.liveSync) if (!s && this.vaultManager.getQueueLength() < FileWatchEventQueueMax) {
      scheduleTask("applyBatchAuto", 3e4, (() => {
        this.procFileEvent(true);
      }));
      return;
    }
    cancelTask("applyBatchAuto");
    const r = void 0;
    return await runWithLock("procFiles", true, (async () => {
      do {
        const s = this.vaultManager.fetchEvent();
        if (false === s) break;
        if (void 0 === s) break;
        const r = s.args.file, o = `file-last-proc-${s.type}-${r.path}`, u = Number(await this.kvDB.get(o) || 0);
        let g = r.mtime;
        if ("DELETE" == s.type) {
          await this.deleteFromDBbyPath(r.path);
          g = r.mtime - 1;
          const s = `file-last-proc-CREATE-${r.path}`, o = `file-last-proc-CHANGED-${r.path}`;
          await this.kvDB.set(s, g);
          await this.kvDB.set(o, g);
        } else if ("INTERNAL" == s.type) {
          await this.addOnHiddenFileSync.watchVaultRawEventsAsync(r.path);
          await this.addOnConfigSync.watchVaultRawEventsAsync(r.path);
        } else {
          const o = this.app.vault.getAbstractFileByPath(r.path);
          if (!(o instanceof import_obsidian.TFile)) {
            Logger(`Target file was not found: ${r.path}`, LOG_LEVEL_INFO);
            continue;
          }
          if (r.mtime == u) {
            Logger(`File has been already scanned on ${s.type}, skip: ${r.path}`, LOG_LEVEL_VERBOSE);
            continue;
          }
          const _ = s.args.cache;
          if ("CREATE" == s.type || "CHANGED" == s.type) {
            const u = `file-last-proc-DELETED-${r.path}`;
            await this.kvDB.set(u, g);
            if (!await this.updateIntoDB(o, false, _)) {
              Logger(`DB -> STORAGE: failed, cancel the relative operations: ${o.path}`, LOG_LEVEL_INFO);
              this.vaultManager.cancelRelativeEvent(s);
              continue;
            }
          }
          if ("RENAME" == s.type) await this.watchVaultRenameAsync(o, s.args.oldPath);
        }
        await this.kvDB.set(o, g);
      } while (this.vaultManager.getQueueLength() > 0);
      return true;
    }));
  }
  watchWorkspaceOpen(s) {
    if (this.settings.suspendFileWatching) return;
    if (!this.isReady) return;
    this.watchWorkspaceOpenAsync(s);
  }
  async watchWorkspaceOpenAsync(s) {
    if (this.settings.suspendFileWatching) return;
    if (!this.isReady) return;
    await this.applyBatchChange();
    if (null == s) return;
    if (this.settings.syncOnFileOpen && !this.suspended) await this.replicate();
    await this.showIfConflicted(getPathFromTFile(s));
  }
  async applyBatchChange() {
    if (this.settings.batchSave && !this.settings.liveSync) return await this.procFileEvent(true);
  }
  getFilePath(s) {
    if (s instanceof import_obsidian.TFolder) {
      if (s.isRoot()) return "";
      return this.getFilePath(s.parent) + "/" + s.name;
    }
    if (s instanceof import_obsidian.TFile) return this.getFilePath(s.parent) + "/" + s.name;
    return this.getFilePath(s.parent) + "/" + s.name;
  }
  async watchVaultRenameAsync(s, r, o) {
    Logger(`${r} renamed to ${s.path}`, LOG_LEVEL_VERBOSE);
    if (s instanceof import_obsidian.TFile) try {
      if (await this.updateIntoDB(s, false, o)) await this.deleteFromDBbyPath(r); else Logger(`Could not save new file: ${s.path} `, LOG_LEVEL_NOTICE);
    } catch (s) {
      Logger(s);
    }
  }
  async addLog(s, r = LOG_LEVEL_INFO, o = "") {
    var u, g;
    if (r == LOG_LEVEL_DEBUG && !isDebug) return;
    if (r < LOG_LEVEL_INFO && this.settings && this.settings.lessInformationInLog) return;
    if (this.settings && !this.settings.showVerboseLog && r == LOG_LEVEL_VERBOSE) return;
    const _ = this.getVaultName(), b = new Date, w = b.toLocaleString(), E = "string" == typeof s ? s : s instanceof Error ? `${s.name}:${s.message}` : JSON.stringify(s, null, 2);
    if (s instanceof Error) console.dir(s.stack);
    const S = w + "->" + E;
    console.log(_ + ":" + S);
    if (null == (u = this.settings) ? void 0 : u.writeLogToTheFile) {
      const s = b.toISOString().split("T")[0], r = `${PREFIXMD_LOGFILE}${s}.md`, o = void 0;
      if (!this.app.vault.getAbstractFileByPath(normalizePath(r))) this.app.vault.adapter.append(normalizePath(r), "```\n");
      this.app.vault.adapter.append(normalizePath(r), _ + ":" + S + "\n");
    }
    logMessageStore.apply((s => [ ...s, S ].slice(-100)));
    this.setStatusBarText(null, E);
    if (r >= LOG_LEVEL_NOTICE) {
      if (!o) o = E;
      if (o in this.notifies) {
        const s = void 0;
        if (!(null == (g = this.notifies[o].notice.noticeEl) ? void 0 : g.isShown())) this.notifies[o].notice = new import_obsidian.Notice(E, 0);
        clearTimeout(this.notifies[o].timer);
        if (o == E) {
          this.notifies[o].count++;
          this.notifies[o].notice.setMessage(`(${this.notifies[o].count}):${E}`);
        } else this.notifies[o].notice.setMessage(`${E}`);
        this.notifies[o].timer = setTimeout((() => {
          const s = this.notifies[o].notice;
          delete this.notifies[o];
          try {
            s.hide();
          } catch (s) {}
        }), 5e3);
      } else {
        const s = new import_obsidian.Notice(E, 0);
        this.notifies[o] = {
          count: 0,
          notice: s,
          timer: setTimeout((() => {
            delete this.notifies[o];
            s.hide();
          }), 5e3)
        };
      }
    }
  }
  async ensureDirectory(s) {
    const r = s.split("/");
    r.pop();
    let o = "";
    for (const s of r) {
      o += s;
      try {
        await this.app.vault.createFolder(o);
      } catch (s) {
        if (s.message && "Folder already exists." == s.message) ; else {
          Logger("Folder Create Error");
          Logger(s);
        }
      }
      o += "/";
    }
  }
  async doc2storage(s, r, o) {
    var u;
    const g = null == r ? "create" : "modify", _ = this.getPath(s);
    if (shouldBeIgnored(_)) return;
    if (!await this.isTargetFile(_)) return;
    if (s._deleted || s.deleted) {
      const s = await this.localDatabase.getDBEntry(_, {
        conflicts: true
      });
      if (_ != r.path) Logger(`delete skipped: ${r.path} :Not exactly matched`, LOG_LEVEL_VERBOSE);
      if (false === s) await this.deleteVaultItem(r); else if (s._conflicts) if (this.settings.writeDocumentsIfConflicted) {
        Logger(`Delete: ${r.path}: Conflicted revision has been deleted, but there were more conflicts. `, LOG_LEVEL_INFO);
        await this.pullFile(_, null, true);
      } else {
        Logger(`Delete: ${r.path}: Conflicted revision has been deleted, but there were more conflicts...`);
        this.queueConflictedOnlyActiveFile(r);
      } else {
        Logger(`Delete: ${r.path}: Conflict revision has been deleted and resolved`);
        await this.pullFile(_, null, true);
      }
      return;
    }
    const b = ~~(((null == (u = null == r ? void 0 : r.stat) ? void 0 : u.mtime) || 0) / 1e3), w = ~~(s.mtime / 1e3), E = await this.localDatabase.getDBEntry(_, {
      rev: s._rev
    });
    if (false === E) return;
    const S = `DB -> STORAGE (${g}${o ? ",force" : ""},${E.datatype}) `;
    if ("newnote" != E.datatype && "plain" != E.datatype) {
      Logger(S + "ERROR, Invalid datatype: " + _ + "(" + E.datatype + ")", LOG_LEVEL_NOTICE);
      return;
    }
    if (!o && b >= w) return;
    if (!isValidPath(_)) {
      Logger(S + "ERROR, invalid path: " + _, LOG_LEVEL_NOTICE);
      return;
    }
    const L = "newnote" == E.datatype ? base64ToArrayBuffer(E.data) : getDocData(E.data);
    await this.ensureDirectoryEx(_);
    try {
      let s;
      if ("create" == g) s = await createFile(normalizePath(_), L, {
        ctime: E.ctime,
        mtime: E.mtime
      }); else {
        await modifyFile(r, L, {
          ctime: E.ctime,
          mtime: E.mtime
        });
        s = getAbstractFileByPath(getPathFromTFile(r));
      }
      Logger(S + _);
      touch(s);
      this.app.vault.trigger(g, s);
    } catch (s) {
      Logger(S + "ERROR, Could not write: " + _, LOG_LEVEL_NOTICE);
      Logger(s, LOG_LEVEL_VERBOSE);
    }
  }
  async deleteVaultItem(s) {
    if (s instanceof import_obsidian.TFile) if (!await this.isTargetFile(s)) return;
    const r = s.parent;
    if (this.settings.trashInsteadDelete) await this.app.vault.trash(s, false); else await this.app.vault.delete(s);
    Logger(`xxx <- STORAGE (deleted) ${s.path}`);
    Logger(`files: ${r.children.length}`);
    if (0 == r.children.length) if (!this.settings.doNotDeleteFolder) {
      Logger(`All files under the parent directory (${r}) have been deleted, so delete this one.`);
      await this.deleteVaultItem(r);
    }
  }
  handleDBChanged(s) {
    const r = app.workspace.getActiveFile();
    if (r && r.path == this.getPath(s)) {
      this.queuedEntries = this.queuedEntries.filter((r => r._id != s._id));
      return this.handleDBChangedAsync(s);
    }
    this.queuedEntries.push(s);
    this.execDBchanged();
  }
  async execDBchanged() {
    if (this.dbChangeProcRunning) return false;
    this.dbChangeProcRunning = true;
    const s = Semaphore(4);
    try {
      do {
        const r = this.queuedEntries.shift();
        if (this.queuedEntries.some((s => s._id == r._id))) continue;
        const o = getPath2(r);
        try {
          const u = await s.acquire(1);
          runWithLock(`dbchanged-${o}`, false, (async () => {
            Logger(`Applying ${o} (${r._id}: ${r._rev}) change...`, LOG_LEVEL_VERBOSE);
            await this.handleDBChangedAsync(r);
            Logger(`Applied ${o} (${r._id}:${r._rev}) change...`);
          })).finally((() => {
            u();
          }));
        } catch (s) {
          Logger(`Failed to apply the change of ${o} (${r._id}:${r._rev})`);
        }
      } while (this.queuedEntries.length > 0);
    } finally {
      this.dbChangeProcRunning = false;
    }
  }
  queueConflictedOnlyActiveFile(s) {
    if (!this.settings.checkConflictOnlyOnOpen) {
      this.queueConflictedCheck(s);
      return true;
    } else {
      const r = this.app.workspace.getActiveFile();
      if (r && r.path == s.path) {
        this.queueConflictedCheck(s);
        return true;
      }
    }
    return false;
  }
  async handleDBChangedAsync(s) {
    const r = getAbstractFileByPath(this.getPathWithoutPrefix(s));
    if (null == r) {
      if (s._deleted || s.deleted) return;
      const r = s;
      await this.doc2storage(r);
    } else if (r instanceof import_obsidian.TFile) {
      const o = s, u = r;
      if (this.settings.writeDocumentsIfConflicted) {
        await this.doc2storage(o, u);
        this.queueConflictedOnlyActiveFile(u);
      } else {
        const r = await this.localDatabase.getDBEntryMeta(this.getPath(s), {
          conflicts: true
        }, true);
        if (r && !r._conflicts) await this.doc2storage(o, u); else if (!this.queueConflictedOnlyActiveFile(u)) Logger(`${this.getPath(s)} is conflicted, write to the storage has been postponed.`, LOG_LEVEL_NOTICE);
      }
    } else Logger(`${this.getPath(s)} is already exist as the folder`);
  }
  saveQueuedFiles() {
    const s = JSON.stringify(this.queuedFiles.filter((s => !s.done)).map((s => s.entry._id))), r = "obsidian-livesync-queuefiles-" + this.getVaultName();
    localStorage.setItem(r, s);
  }
  async loadQueuedFiles() {
    if (!this.settings.suspendParseReplicationResult) {
      const s = "obsidian-livesync-queuefiles-" + this.getVaultName(), r = [ ...new Set(JSON.parse(localStorage.getItem(s) || "[]")) ], o = await this.localDatabase.allDocsRaw({
        keys: r,
        include_docs: true
      });
      for (const s of o.rows) if (s.doc && !this.queuedFiles.some((r => r.entry._id == s.doc._id))) await this.parseIncomingDoc(s.doc);
    }
  }
  procQueuedFiles() {
    this.saveQueuedFiles();
    for (const s of this.queuedFiles) {
      if (s.done) continue;
      const r = (new Date).getTime();
      if (0 == s.missingChildren.length) {
        s.done = true;
        if (isInternalMetadata(s.entry._id)) {
          const r = this.getPathWithoutPrefix(s.entry);
          this.addOnHiddenFileSync.procInternalFile(r);
        } else if (isValidPath(this.getPath(s.entry))) this.handleDBChanged(s.entry); else Logger(`Skipped: ${s.entry._id}`, LOG_LEVEL_VERBOSE);
      } else if (r > s.timeout) {
        if (!s.warned) Logger(`Timed out: ${s.entry._id} could not collect ${s.missingChildren.length} chunks. plugin keeps watching, but you have to check the file after the replication.`, LOG_LEVEL_NOTICE);
        s.warned = true;
        continue;
      }
    }
    this.queuedFiles = this.queuedFiles.filter((s => !s.done));
    this.queuedFilesStore.apply((s => ({
      ...s,
      queuedItems: this.queuedFiles
    })));
    this.saveQueuedFiles();
  }
  parseIncomingChunk(s) {
    const r = (new Date).getTime();
    let o = false;
    for (const u of this.queuedFiles) {
      if (u.done) continue;
      if (-1 !== u.missingChildren.indexOf(s._id)) {
        u.missingChildren = u.missingChildren.filter((r => r != s._id));
        u.timeout = r + this.chunkWaitTimeout;
      }
      if (0 == u.missingChildren.length) {
        for (const s of this.queuedFiles) if (s.entry._id == u.entry._id && s.entry.mtime < u.entry.mtime) s.done = true;
        o = true;
      }
    }
    if (o) this.procQueuedFiles();
  }
  async parseIncomingDoc(s) {
    const r = this.getPath(s);
    if (!await this.isTargetFile(r)) return;
    const o = this.settings.skipOlderFilesOnSync && false;
    if (isInternalMetadata(s._id) && !this.settings.syncInternalFiles) return;
    const u = [ "_design/replicate", "_design/chunks", FLAGMD_REDFLAG, FLAGMD_REDFLAG2, FLAGMD_REDFLAG3 ];
    if (!isInternalMetadata(s._id) && u.contains(r)) return;
    if (!isInternalMetadata(s._id) && o) {
      const o = getAbstractFileByPath(stripAllPrefixes(r));
      if (o && o instanceof import_obsidian.TFile) {
        const u = void 0, g = void 0;
        if (~~(o.stat.mtime / 1e3) >= ~~(s.mtime / 1e3)) {
          Logger(`${r} (${s._id}, ${s._rev}) Skipped, older than storage.`, LOG_LEVEL_VERBOSE);
          return;
        }
      }
    }
    const g = void 0, _ = {
      entry: s,
      missingChildren: [],
      timeout: (new Date).getTime() + this.chunkWaitTimeout
    };
    if (!this.settings.readChunksOnline && "children" in s) {
      const o = void 0, u = (await this.localDatabase.collectChunksWithCache(s.children)).filter((s => false === s.chunk)).map((s => s.id));
      if (u.length > 0) Logger(`${r} (${s._id}, ${s._rev}) Queued (waiting ${u.length} items)`, LOG_LEVEL_VERBOSE);
      _.missingChildren = u;
      this.queuedFiles.push(_);
    } else this.queuedFiles.push(_);
    this.saveQueuedFiles();
    this.procQueuedFiles();
  }
  async parseReplicationResult(s) {
    const r = s.sort(((s, r) => {
      var o, u;
      return null != (u = null != (o = null == r ? void 0 : r.mtime) ? o : 0 - (null == s ? void 0 : s.mtime)) ? u : 0;
    }));
    e: for (const s of r) {
      if (isChunk(s._id)) {
        if (!this.settings.suspendParseReplicationResult) await this.parseIncomingChunk(s);
        continue;
      }
      if (!this.settings.suspendParseReplicationResult) for (const r of this.addOns) if (await r.parseReplicationResultItem(s)) continue e;
      if (s._id == SYNCINFO_ID) continue;
      if (s._id.startsWith("_design")) continue;
      if ("leaf" != s.type && "versioninfo" != s.type && "milestoneinfo" != s.type && "nodeinfo" != s.type) if (this.settings.suspendParseReplicationResult) {
        const r = {
          entry: s,
          missingChildren: [],
          timeout: 0
        };
        Logger(`Processing scheduled: ${s.path}`, LOG_LEVEL_INFO);
        this.queuedFiles.push(r);
        this.saveQueuedFiles();
        continue;
      } else {
        await this.parseIncomingDoc(s);
        continue;
      }
      if ("versioninfo" == s.type) if (s.version > VER) {
        this.replicator.closeReplication();
        Logger("Remote database updated to incompatible version. update your self-hosted-livesync plugin.", LOG_LEVEL_NOTICE);
      }
    }
  }
  async realizeSettingSyncMode() {
    var s;
    this.replicator.closeReplication();
    null == (s = this.periodicSyncProcessor) || s.disable();
    this.localDatabase.refreshSettings();
    await this.applyBatchChange();
    await Promise.all(this.addOns.map((s => s.realizeSettingSyncMode())));
    if (this.suspended) return;
    await Promise.all(this.addOns.map((s => s.onResume())));
    if (this.settings.liveSync) this.replicator.openReplication(this.settings, true, false);
    this.periodicSyncProcessor.enable(this.settings.periodicReplication ? 1e3 * this.settings.periodicReplicationInterval : 0);
  }
  observeForLogs() {
    const s = observeStores(this.queuedFilesStore, lockStore), r = void 0;
    observeStores(s, this.replicationStat).observe((s => {
      var r;
      const o = s.sent, u = s.arrived, g = s.maxPullSeq, _ = s.maxPushSeq, b = s.lastSyncPullSeq, w = s.lastSyncPushSeq;
      let E = "", S = "", L = "";
      switch (s.syncStatus) {
       case "CLOSED":
       case "COMPLETED":
       case "NOT_CONNECTED":
        L = "⏹";
        break;

       case "STARTED":
        L = "🌀";
        break;

       case "PAUSED":
        L = "💤";
        break;

       case "CONNECTED":
        L = "⚡";
        E = 0 == w ? "" : w >= _ ? " (LIVE)" : ` (${_ - w})`;
        S = 0 == b ? "" : b >= g ? " (LIVE)" : ` (${g - b})`;
        break;

       case "ERRORED":
        L = "⚠";
        break;

       default:
        L = "?";
      }
      this.statusBar.title = s.syncStatus;
      let O = "";
      if (this.settings.batchSave && !this.settings.liveSync) {
        const s = null == (r = this.vaultManager) ? void 0 : r.getQueueLength();
        if (0 != s) O = ` 🛫${s}`;
      }
      let D = "";
      const k = Object.entries(s.queuedItems).filter((s => !s[1].warned)), C = k.length;
      if (C) {
        const s = void 0;
        D = ` 🧩${C} (${k.map((s => s[1].missingChildren)).reduce(((s, r) => s + r.length), 0)})`;
      }
      const T = s.count, I = void 0, A = `Sync: ${L} ↑${o}${E} ↓${u}${S}${O}${0 == T ? "" : ` ⏳${T}`}${D}`;
      function getProcKind(s) {
        const r = s.indexOf("-");
        if (-1 == r) return s;
        return s.substring(0, r);
      }
      const x = s.pending.length ? s.pending.length < 10 ? "\nPending: " + Object.entries(s.pending.reduce(((s, r) => {
        var o;
        return {
          ...s,
          [getProcKind(r)]: (null != (o = s[getProcKind(r)]) ? o : 0) + 1
        };
      }), {})).map((s => `${s[0]}${1 == s[1] ? "" : `(${s[1]})`}`)).join(", ") : `\n Pending: ${s.pending.length}` : "", R = s.running.length ? s.running.length < 10 ? "\nRunning: " + Object.entries(s.running.reduce(((s, r) => {
        var o;
        return {
          ...s,
          [getProcKind(r)]: (null != (o = s[getProcKind(r)]) ? o : 0) + 1
        };
      }), {})).map((s => `${s[0]}${1 == s[1] ? "" : `(${s[1]})`}`)).join(", ") : `\n Running: ${s.running.length}` : "";
      this.setStatusBarText(A + x + R);
    }));
  }
  refreshStatusText() {
    return;
  }
  setStatusBarText(s = null, r = null) {
    if (!this.statusBar) return;
    const o = "string" == typeof s ? s : this.lastMessage, u = "string" == typeof r ? r : this.lastLog;
    if (`${this.lastMessage}-${this.lastLog}` != `${o}-${u}`) {
      this.statusBar.setText(o.split("\n")[0]);
      if (this.settings.showStatusOnEditor) {
        const s = void 0, r = void 0;
        activeDocument.documentElement.querySelectorAll(".CodeMirror-wrap,.cm-s-obsidian>.cm-editor,.canvas-wrapper").forEach((s => s.setAttr("data-log", o + "\n" + u)));
      } else {
        const s = void 0, r = void 0;
        activeDocument.documentElement.querySelectorAll(".CodeMirror-wrap,.cm-s-obsidian>.cm-editor,.canvas-wrapper").forEach((s => s.setAttr("data-log", "")));
      }
      scheduleTask("log-hide", 3e3, (() => this.setStatusBarText(null, "")));
      this.lastMessage = o;
      this.lastLog = u;
    }
  }
  updateStatusBarText() {}
  async replicate(s) {
    if (!this.isReady) return;
    if (isLockAcquired("cleanup")) {
      Logger("Database cleaning up is in process. replication has been cancelled", LOG_LEVEL_NOTICE);
      return;
    }
    if ("" != this.settings.versionUpFlash) {
      Logger("Open settings and check message, please. replication has been cancelled.", LOG_LEVEL_NOTICE);
      return;
    }
    await this.applyBatchChange();
    await Promise.all(this.addOns.map((r => r.beforeReplicate(s))));
    await this.loadQueuedFiles();
    const r = await this.replicator.openReplication(this.settings, false, s);
    if (!r) if (this.replicator.remoteLockedAndDeviceNotAccepted) if (this.replicator.remoteCleaned && this.settings.useIndexedDBAdapter) {
      Logger("The remote database has been cleaned.", s ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
      await runWithLock("cleanup", true, (async () => {
        const r = void 0, o = `The remote database has been cleaned up.\nTo synchronize, this device must be also cleaned up. ${await purgeUnreferencedChunks(this.localDatabase.localDatabase, true)} chunk(s) will be erased from this device.\nHowever, If there are many chunks to be deleted, maybe fetching again is faster.\nWe will lose the history of this device if we fetch the remote database again.\nEven if you choose to clean up, you will see this option again if you exit Obsidian and then synchronise again.`, u = "Fetch again", g = "Cleanup", _ = "Dismiss", b = await confirmWithMessage(this, "Cleaned", o, [ u, g, _ ], _, 30);
        if (b == u) await performRebuildDB(this, "localOnly");
        if (b == g) {
          const r = await this.getReplicator().connectRemoteCouchDBWithSetting(this.settings, this.getIsMobile(), true);
          if ("string" == typeof r) {
            Logger(r, LOG_LEVEL_NOTICE);
            return false;
          }
          await purgeUnreferencedChunks(this.localDatabase.localDatabase, false);
          this.localDatabase.hashCaches.clear();
          if (await this.replicator.openReplication(this.settings, false, s, true)) {
            await balanceChunkPurgedDBs(this.localDatabase.localDatabase, r.db);
            await purgeUnreferencedChunks(this.localDatabase.localDatabase, false);
            this.localDatabase.hashCaches.clear();
            await this.getReplicator().markRemoteResolved(this.settings);
            Logger("The local database has been cleaned up.", s ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
          } else Logger("Replication has been cancelled. Please try it again.", s ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO);
        }
      }));
    } else {
      const s = "\nThe remote database has been rebuilt.\nTo synchronize, this device must fetch everything again once.\nOr if you are sure know what had been happened, we can unlock the database from the setting dialog.\n                    ", r = "Fetch again", o = "Dismiss", u = void 0;
      if (await confirmWithMessage(this, "Locked", s, [ r, o ], o, 10) == r) await performRebuildDB(this, "localOnly");
    }
    return r;
  }
  async initializeDatabase(s, r = true) {
    this.isReady = false;
    if (!r || await this.openDatabase()) {
      if (this.localDatabase.isReady) await this.syncAllFiles(s);
      await Promise.all(this.addOns.map((r => r.onInitializeDatabase(s))));
      this.isReady = true;
      await this.procFileEvent(true);
      return true;
    } else {
      this.isReady = false;
      return false;
    }
  }
  async replicateAllToServer(s) {
    if (!this.isReady) return false;
    await Promise.all(this.addOns.map((r => r.beforeReplicate(s))));
    return await this.replicator.replicateAllToServer(this.settings, s);
  }
  async replicateAllFromServer(s) {
    if (!this.isReady) return false;
    return await this.replicator.replicateAllFromServer(this.settings, s);
  }
  async markRemoteLocked(s) {
    return await this.replicator.markRemoteLocked(this.settings, true, s);
  }
  async markRemoteUnlocked() {
    return await this.replicator.markRemoteLocked(this.settings, false, false);
  }
  async markRemoteResolved() {
    return await this.replicator.markRemoteResolved(this.settings);
  }
  async syncAllFiles(s) {
    let r = false;
    if (s) Logger("Initializing", LOG_LEVEL_NOTICE, "syncAll");
    Logger("Initialize and checking database files");
    Logger("Checking deleted files");
    await this.collectDeletedFiles();
    Logger("Collecting local files on the storage", LOG_LEVEL_VERBOSE);
    const o = this.app.vault.getFiles(), u = [];
    for (const s of o) if (await this.isTargetFile(s.path)) u.push(s);
    const g = u.map((s => s.path));
    Logger("Collecting local files on the DB", LOG_LEVEL_VERBOSE);
    const _ = [];
    let b = 0;
    for await (const r of this.localDatabase.findAllNormalDocs()) {
      b++;
      if (b % 25 == 0) Logger(`Collecting local files on the DB: ${b}`, s ? LOG_LEVEL_NOTICE : LOG_LEVEL_INFO, "syncAll");
      const o = getPath2(r);
      if (isValidPath(o) && await this.isTargetFile(o)) _.push(o);
    }
    Logger("Opening the key-value database", LOG_LEVEL_VERBOSE);
    const w = await this.kvDB.get("initialized") || false;
    if (0 == _.length && !w) {
      r = true;
      Logger("Database looks empty, save files as initial sync data");
    }
    const E = u.filter((s => -1 == _.indexOf(getPathFromTFile(s)))), S = _.filter((s => -1 == g.indexOf(s))), L = E.map((s => s.path)), O = u.filter((s => -1 == L.indexOf(s.path)));
    Logger("Updating database by new files");
    this.setStatusBarText("UPDATE DATABASE");
    const runAll = async (s, r, o) => {
      Logger(s);
      if (!this.localDatabase.isReady) throw Error("Database is not ready!");
      const u = r.map((r => async () => {
        try {
          await o(r);
          return true;
        } catch (r) {
          Logger(`Error while ${s}`, LOG_LEVEL_NOTICE);
          Logger(r, LOG_LEVEL_VERBOSE);
          return false;
        }
      }));
      let g = 0, _ = 0;
      for await (const s of processAllTasksWithConcurrencyLimit(10, u)) if ("ok" in s && s.ok) g++; else _++;
      Logger(`${s}: PASS:${g}, FAILED:${_}`);
    };
    await runAll("UPDATE DATABASE", E, (async s => {
      Logger(`UPDATE DATABASE ${s.path}`);
      await this.updateIntoDB(s, r);
    }));
    if (!r) await runAll("UPDATE STORAGE", S, (async s => {
      const r = await this.localDatabase.getDBEntryMeta(s, {}, true);
      if (r && !(r.deleted || r._deleted)) {
        Logger(`Check or pull from db:${s}`);
        await this.pullFile(s, u, false, null, false);
        Logger(`Check or pull from db:${s} OK`);
      } else if (r) Logger(`Deletion history skipped: ${s}`, LOG_LEVEL_VERBOSE); else Logger(`entry not found: ${s}`);
    }));
    if (!r) {
      let s = {};
      s = await this.kvDB.get("diff-caches") || {};
      const o = void 0, u = [ ...arrayToChunkedArray(O, 100) ].map(((o, u, g) => async () => {
        const _ = void 0, b = (await mapAllTasksWithConcurrencyLimit(10, o.map((s => async () => ({
          file: s,
          id: await this.path2id(getPathFromTFile(s))
        }))))).map((s => "ok" in s ? s.ok : void 0)).filter((s => s)), w = void 0, E = (await this.localDatabase.allDocsRaw({
          keys: b.map((s => s.id)),
          include_docs: true
        })).rows.reduce(((s, r) => ({
          ...s,
          [r.id]: r.doc
        })), {}), S = b.map((s => ({
          file: s.file,
          doc: E[s.id]
        })));
        await runAll(`CHECK FILE STATUS:${u + 1}/${g.length}`, S, (async o => {
          s = await this.syncFileBetweenDBandStorage(o.file, o.doc, r, s);
        }));
      }));
      await mapAllTasksWithConcurrencyLimit(2, u);
      await this.kvDB.set("diff-caches", s);
    }
    this.setStatusBarText("NOW TRACKING!");
    Logger("Initialized, NOW TRACKING!");
    if (!w) await this.kvDB.set("initialized", true);
    if (s) Logger("Initialize done!", LOG_LEVEL_NOTICE, "syncAll");
  }
  async getConflictedDoc(s, r) {
    try {
      const o = await this.localDatabase.getDBEntry(s, {
        rev: r
      }, false, false, true);
      if (false === o) return false;
      let u = getDocData(o.data);
      if ("newnote" == o.datatype) u = base64ToString(u); else if ("plain" == o.datatype) ;
      return {
        deleted: o.deleted || o._deleted,
        ctime: o.ctime,
        mtime: o.mtime,
        rev: r,
        data: u
      };
    } catch (s) {
      if (isErrorOfMissingDoc(s)) return false;
    }
    return false;
  }
  async mergeSensibly(s, r, o, u) {
    var g, _, b, w;
    const E = await this.getConflictedDoc(s, r), S = await this.getConflictedDoc(s, o), L = await this.getConflictedDoc(s, u);
    let O = false;
    if (false == E || false == S || false == L) return false;
    const D = new import_diff_match_patch.diff_match_patch, k = D.diff_linesToChars_(E.data, S.data), C = D.diff_main(k.chars1, k.chars2, false);
    D.diff_charsToLines_(C, k.lineArray);
    const T = D.diff_linesToChars_(E.data, L.data), I = D.diff_main(T.chars1, T.chars2, false);
    D.diff_charsToLines_(I, T.lineArray);
    function splitDiffPiece(s) {
      const r = [];
      do {
        const o = s.shift();
        if (void 0 === o) return r;
        const u = o[1].split(/([^\n]*\n)/).filter((s => "" != s));
        if ("undefined" == typeof o) break;
        if (o[0] != import_diff_match_patch.DIFF_DELETE) r.push(...u.map((s => [ o[0], s ])));
        if (o[0] == import_diff_match_patch.DIFF_DELETE) {
          const g = s.shift();
          if ("undefined" != typeof g) {
            const s = g[1].split(/([^\n]*\n)/).filter((s => "" != s));
            if (g[0] == import_diff_match_patch.DIFF_INSERT) {
              for (const g of u) {
                r.push([ o[0], g ]);
                const u = s.shift();
                if ("undefined" != typeof u) r.push([ import_diff_match_patch.DIFF_INSERT, u ]);
              }
              r.push(...s.map((s => [ g[0], s ])));
            } else {
              r.push(...u.map((s => [ o[0], s ])));
              r.push(...s.map((s => [ g[0], s ])));
            }
          } else r.push(...u.map((s => [ 0, s ])));
        }
      } while (s.length > 0);
      return r;
    }
    const A = splitDiffPiece(C), x = splitDiffPiece(I);
    let R = 0, P = 0;
    const N = [];
    O = true;
    e: do {
      if (P >= A.length && R >= x.length) break e;
      const s = null != (g = A[P]) ? g : [ 0, "" ], r = null != (_ = x[R]) ? _ : [ 0, "" ];
      P++;
      R++;
      if (s[0] == import_diff_match_patch.DIFF_EQUAL && r[0] == import_diff_match_patch.DIFF_EQUAL && s[1] == r[1]) {
        N.push(s);
        continue;
      }
      if (s[0] == import_diff_match_patch.DIFF_DELETE && r[0] == import_diff_match_patch.DIFF_DELETE && s[1] == r[1]) {
        const r = P, o = R, [u, g] = [ null != (b = A[r]) ? b : [ 0, "" ], null != (w = x[o]) ? w : [ 0, "" ] ];
        if (u[0] == import_diff_match_patch.DIFF_INSERT && g[0] == import_diff_match_patch.DIFF_INSERT && u[1] != g[1]) {
          O = false;
          break;
        } else {
          N.push(s);
          continue;
        }
      }
      if (s[0] == import_diff_match_patch.DIFF_INSERT && r[0] == import_diff_match_patch.DIFF_INSERT) if (s[1] == r[1]) {
        N.push(s);
        continue;
      } else if (S.mtime <= L.mtime) {
        N.push(s);
        N.push(r);
        continue;
      } else {
        N.push(r);
        N.push(s);
        continue;
      }
      if (s[0] == import_diff_match_patch.DIFF_INSERT) {
        R--;
        N.push(s);
        continue;
      }
      if (r[0] == import_diff_match_patch.DIFF_INSERT) {
        P--;
        N.push(r);
        continue;
      }
      if (r[1] != s[1]) {
        Logger(`MERGING PANIC:${s[0]},${s[1]} == ${r[0]},${r[1]}`, LOG_LEVEL_VERBOSE);
        O = false;
        break e;
      }
      if (s[0] == import_diff_match_patch.DIFF_DELETE) if (r[0] == import_diff_match_patch.DIFF_EQUAL) {
        N.push(s);
        continue;
      } else {
        O = false;
        break e;
      }
      if (r[0] == import_diff_match_patch.DIFF_DELETE) if (s[0] == import_diff_match_patch.DIFF_EQUAL) {
        N.push(r);
        continue;
      } else {
        O = false;
        break e;
      }
      Logger(`Weird condition:${s[0]},${s[1]} == ${r[0]},${r[1]}`, LOG_LEVEL_VERBOSE);
      break e;
    } while (P < A.length || R < x.length);
    if (O) {
      Logger("Sensibly merge available", LOG_LEVEL_VERBOSE);
      return N;
    } else return false;
  }
  async mergeObject(s, r, o, u) {
    try {
      const g = await this.getConflictedDoc(s, r), _ = await this.getConflictedDoc(s, o), b = await this.getConflictedDoc(s, u);
      if (false == g || false == _ || false == b) return false;
      const w = {
        data: tryParseJSON(g.data, {})
      }, E = {
        data: tryParseJSON(_.data, {})
      }, S = {
        data: tryParseJSON(b.data, {})
      }, L = generatePatchObj(w, E), O = generatePatchObj(w, S), D = new Map(flattenObject(L)), k = new Map(flattenObject(O));
      for (const [s, r] of D) if (k.has(s)) if (k.get(s) == r) k.delete(s);
      for (const [s, r] of k) if (D.has(s) && D.get(s) != r) return false;
      const C = [ {
        mtime: _.mtime,
        patch: L
      }, {
        mtime: b.mtime,
        patch: O
      } ].sort(((s, r) => s.mtime - r.mtime));
      let T = {
        ...w
      };
      for (const s of C) T = applyPatch(T, s.patch);
      return JSON.stringify(T.data);
    } catch (s) {
      Logger("Could not merge object");
      Logger(s, LOG_LEVEL_VERBOSE);
      return false;
    }
  }
  async getConflictedStatus(s) {
    var r, o;
    const u = await this.localDatabase.getDBEntry(s, {
      conflicts: true,
      revs_info: true
    }, false, false, true);
    if (false === u) return false;
    if (null == u) return false;
    if (!u._conflicts) return false;
    if (0 == u._conflicts.length) return false;
    const g = u._conflicts.sort(((s, r) => Number(s.split("-")[0]) - Number(r.split("-")[0])));
    if ((isSensibleMargeApplicable(s) || isObjectMargeApplicable(s)) && !this.settings.disableMarkdownAutoMerge) {
      const _ = g[0], b = Number(_.split("-")[0]), w = void 0, E = null != (o = null == (r = (await this.localDatabase.getRaw(await this.path2id(s), {
        revs_info: true
      }))._revs_info.filter((s => "available" == s.status && Number(s.rev.split("-")[0]) < b)).first()) ? void 0 : r.rev) ? o : "";
      let S;
      if (E) {
        if (isSensibleMargeApplicable(s)) {
          const r = await this.mergeSensibly(s, E, u._rev, _);
          if (r) {
            S = r.filter((s => s[0] != import_diff_match_patch.DIFF_DELETE)).map((s => s[1])).join("");
            Logger(`Sensible merge:${s}`, LOG_LEVEL_INFO);
          } else Logger("Sensible merge is not applicable.", LOG_LEVEL_VERBOSE);
        } else if (isObjectMargeApplicable(s)) {
          const r = await this.mergeObject(s, E, u._rev, _);
          if (r) {
            Logger(`Object merge:${s}`, LOG_LEVEL_INFO);
            S = r;
          } else Logger("Object merge is not applicable.", LOG_LEVEL_VERBOSE);
        }
        if (null != S) {
          await this.localDatabase.deleteDBEntry(s, {
            rev: _
          });
          const r = getAbstractFileByPath(stripAllPrefixes(s));
          if (r) {
            await this.app.vault.modify(r, S);
            await this.updateIntoDB(r);
          } else {
            const r = await this.app.vault.create(s, S);
            await this.updateIntoDB(r);
          }
          await this.pullFile(s);
          Logger(`Automatically merged (sensible) :${s}`, LOG_LEVEL_INFO);
          return true;
        }
      }
    }
    const _ = await this.getConflictedDoc(s, u._rev), b = await this.getConflictedDoc(s, g[0]);
    if (false == _) {
      Logger(`could not get current revisions:${s}`, LOG_LEVEL_NOTICE);
      return false;
    }
    if (false == b) {
      await this.localDatabase.deleteDBEntry(s, {
        rev: g[0]
      });
      await this.pullFile(s, null, true);
      Logger(`could not get old revisions, automatically used newer one:${s}`, LOG_LEVEL_NOTICE);
      return true;
    }
    if (_.data == b.data && _.deleted == b.deleted) {
      let r = _;
      if (_.mtime > b.mtime) r = b;
      await this.localDatabase.deleteDBEntry(s, {
        rev: r.rev
      });
      await this.pullFile(s, null, true);
      Logger(`automatically merged:${s}`);
      return true;
    }
    if (this.settings.resolveConflictsByNewerFile) {
      const r = void 0, o = void 0;
      let u = _;
      if (~~(_.mtime / 1e3) > ~~(b.mtime / 1e3)) u = b;
      await this.localDatabase.deleteDBEntry(s, {
        rev: u.rev
      });
      await this.pullFile(s, null, true);
      Logger(`Automatically merged (newerFileResolve) :${s}`, LOG_LEVEL_NOTICE);
      return true;
    }
    const w = new import_diff_match_patch.diff_match_patch, E = w.diff_main(_.data, b.data);
    w.diff_cleanupSemantic(E);
    Logger(`conflict(s) found:${s}`);
    return {
      left: _,
      right: b,
      diff: E
    };
  }
  showMergeDialog(s, r) {
    return runWithLock("resolve-conflict:" + s, false, (() => new Promise(((o, u) => {
      Logger("open conflict dialog", LOG_LEVEL_VERBOSE);
      new ConflictResolveModal(this.app, s, r, (async u => {
        const g = await this.localDatabase.getDBEntry(s, {
          conflicts: true
        }, false, false, true);
        if (false === g) {
          Logger("Missing file..", LOG_LEVEL_VERBOSE);
          return o(true);
        }
        if (!g._conflicts) {
          Logger("Nothing have to do with this conflict", LOG_LEVEL_VERBOSE);
          return o(true);
        }
        const _ = u, b = r.left.rev != _ ? r.left.rev : r.right.rev;
        if ("" == _) {
          const o = r.diff.map((s => s[1])).join("");
          await this.localDatabase.deleteDBEntry(s, {
            rev: g._conflicts[0]
          });
          const u = getAbstractFileByPath(stripAllPrefixes(s));
          if (u) {
            await this.app.vault.modify(u, o);
            await this.updateIntoDB(u);
          } else {
            const r = await this.app.vault.create(s, o);
            await this.updateIntoDB(r);
          }
          await this.pullFile(s);
          Logger("concat both file");
          if (this.settings.syncAfterMerge && !this.suspended) await this.replicate();
          setTimeout((() => {
            this.showIfConflicted(s);
          }), 50);
        } else if (null == _) Logger("Leave it still conflicted"); else {
          await this.localDatabase.deleteDBEntry(s, {
            rev: _
          });
          await this.pullFile(s, null, true, b);
          Logger(`Conflict resolved:${s}`);
          if (this.settings.syncAfterMerge && !this.suspended) await this.replicate();
          setTimeout((() => {
            this.showIfConflicted(s);
          }), 50);
        }
        return o(true);
      })).open();
    }))));
  }
  queueConflictedCheck(s) {
    this.conflictedCheckFiles = this.conflictedCheckFiles.filter((r => r != s.path));
    this.conflictedCheckFiles.push(getPathFromTFile(s));
    scheduleTask("check-conflict", 100, (async () => {
      const s = JSON.parse(JSON.stringify(this.conflictedCheckFiles));
      for (const r of s) try {
        const s = getAbstractFileByPath(r);
        if (null != s && s instanceof import_obsidian.TFile) await this.showIfConflicted(getPathFromTFile(s));
      } catch (s) {
        Logger(s);
      }
    }));
  }
  async showIfConflicted(s) {
    await runWithLock("conflicted", false, (async () => {
      const r = await this.getConflictedStatus(s);
      if (false === r) return;
      if (true === r) {
        if (this.settings.syncAfterMerge && !this.suspended) await this.replicate();
        Logger("conflict:Automatically merged, but we have to check it again");
        setTimeout((() => {
          this.showIfConflicted(s);
        }), 50);
        return;
      }
      await this.showMergeDialog(s, r);
    }));
  }
  async pullFile(s, r, o, u, g = true) {
    const _ = getAbstractFileByPath(stripAllPrefixes(s));
    if (!await this.isTargetFile(s)) return;
    if (null == _) {
      const r = await this.localDatabase.getDBEntry(s, u ? {
        rev: u
      } : null, false, g);
      if (false === r) {
        Logger(`${s} Skipped`);
        return;
      }
      await this.doc2storage(r, void 0, o);
    } else if (_ instanceof import_obsidian.TFile) {
      const r = _, b = await this.localDatabase.getDBEntry(s, u ? {
        rev: u
      } : null, false, g);
      if (false === b) {
        Logger(`${s} Skipped`);
        return;
      }
      await this.doc2storage(b, r, o);
    } else Logger(`target files:${s} is exists as the folder`);
  }
  async syncFileBetweenDBandStorage(s, r, o, u) {
    if (!r) throw new Error(`Missing doc:${s.path}`);
    if (!(s instanceof import_obsidian.TFile) && "path" in s) {
      const r = getAbstractFileByPath(s.path);
      if (r instanceof import_obsidian.TFile) s = r; else throw new Error(`Missing file:${s.path}`);
    }
    const g = ~~(s.stat.mtime / 1e3), _ = ~~(r.mtime / 1e3), b = `${s.path}-diff`, w = b in u ? u[b] : {
      storageMtime: 0,
      docMtime: 0
    };
    if (w.docMtime == _ && w.storageMtime == g) {
      u[b] = {
        storageMtime: g,
        docMtime: _
      };
      return u;
    }
    if (g > _) {
      Logger("STORAGE -> DB :" + s.path);
      Logger(`${g} > ${_}`);
      await this.updateIntoDB(s, o);
      u[b] = {
        storageMtime: g,
        docMtime: _
      };
      return u;
    } else if (g < _) {
      Logger("STORAGE <- DB :" + s.path);
      Logger(`${g} < ${_}`);
      const r = await this.localDatabase.getDBEntry(getPathFromTFile(s), null, false, false);
      if (false != r) await this.doc2storage(r, s); else Logger("STORAGE <- DB :" + s.path + " Skipped");
      u[b] = {
        storageMtime: g,
        docMtime: _
      };
      return u;
    }
    Logger("STORAGE == DB :" + s.path, LOG_LEVEL_VERBOSE);
    u[b] = {
      storageMtime: g,
      docMtime: _
    };
    return u;
  }
  async updateIntoDB(s, r, o, u) {
    if (!await this.isTargetFile(s)) return true;
    if (shouldBeIgnored(s.path)) return true;
    let g, _ = "newnote";
    if (!o) if (!isPlainText(s.name)) {
      Logger(`Reading   : ${s.path}`, LOG_LEVEL_VERBOSE);
      const r = await this.app.vault.readBinary(s);
      Logger(`Processing: ${s.path}`, LOG_LEVEL_VERBOSE);
      try {
        g = await arrayBufferToBase64(r);
      } catch (r) {
        Logger(`The file ${s.path} could not be encoded`);
        Logger(r, LOG_LEVEL_VERBOSE);
        return false;
      }
      _ = "newnote";
    } else {
      g = await this.app.vault.read(s);
      _ = "plain";
    } else if (o instanceof ArrayBuffer) {
      Logger(`Processing: ${s.path}`, LOG_LEVEL_VERBOSE);
      try {
        g = await arrayBufferToBase64(o);
      } catch (r) {
        Logger(`The file ${s.path} could not be encoded`);
        Logger(r, LOG_LEVEL_VERBOSE);
        return false;
      }
      _ = "newnote";
    } else {
      g = o;
      _ = "plain";
    }
    const b = getPathFromTFile(s), w = void 0, E = {
      _id: await this.path2id(b),
      path: getPathFromTFile(s),
      data: g,
      ctime: s.stat.ctime,
      mtime: s.stat.mtime,
      size: s.stat.size,
      children: [],
      datatype: _,
      type: _
    }, S = `DB <- STORAGE (${_}) `, L = void 0;
    if (await runWithLock("file-" + b, false, (async () => {
      if (recentlyTouched(s)) return true;
      try {
        const s = await this.localDatabase.getDBEntry(b, null, false, false);
        if (false !== s) {
          const r = {
            data: s.data,
            deleted: s._deleted || s.deleted
          }, o = {
            data: E.data,
            deleted: E._deleted || E.deleted
          };
          if (r.deleted != o.deleted) return false;
          if (!isDocContentSame(s.data, o.data)) return false;
          Logger(S + "Skipped (not changed) " + b + (E._deleted || E.deleted ? " (deleted)" : ""), LOG_LEVEL_VERBOSE);
          return true;
        }
      } catch (s) {
        if (u) Logger(S + "Error, Could not check the diff for the old one." + (u ? "force writing." : "") + b + (E._deleted || E.deleted ? " (deleted)" : ""), LOG_LEVEL_VERBOSE); else Logger(S + "Error, Could not check the diff for the old one." + b + (E._deleted || E.deleted ? " (deleted)" : ""), LOG_LEVEL_VERBOSE);
        return !u;
      }
      return false;
    }))) return true;
    const O = await this.localDatabase.putDBEntry(E, r);
    this.queuedFiles = this.queuedFiles.map((s => ({
      ...s,
      ...s.entry._id == E._id ? {
        done: true
      } : {}
    })));
    Logger(S + b);
    if (this.settings.syncOnSave && !this.suspended) await this.replicate();
    return false != O;
  }
  async deleteFromDB(s) {
    if (!await this.isTargetFile(s)) return;
    const r = getPathFromTFile(s);
    Logger(`deleteDB By path:${r}`);
    await this.deleteFromDBbyPath(r);
    if (this.settings.syncOnSave && !this.suspended) await this.replicate();
  }
  async deleteFromDBbyPath(s) {
    await this.localDatabase.deleteDBEntry(s);
    if (this.settings.syncOnSave && !this.suspended) await this.replicate();
  }
  async resetLocalDatabase() {
    clearTouched();
    await this.localDatabase.resetDatabase();
  }
  async tryResetRemoteDatabase() {
    await this.replicator.tryResetRemoteDatabase(this.settings);
  }
  async tryCreateRemoteDatabase() {
    await this.replicator.tryCreateRemoteDatabase(this.settings);
  }
  async ensureDirectoryEx(s) {
    const r = s.split("/");
    r.pop();
    let o = "";
    for (const s of r) {
      o += s;
      try {
        await this.app.vault.adapter.mkdir(o);
      } catch (s) {
        if (s.message && "Folder already exists." == s.message) ; else {
          Logger("Folder Create Error");
          Logger(s);
        }
      }
      o += "/";
    }
  }
  filterTargetFiles(s, r = false) {
    const o = this.settings.syncInternalFilesIgnorePatterns.replace(/\n| /g, "").split(",").filter((s => s)).map((s => new RegExp(s, "i")));
    return s.filter((s => !o.some((r => s.path.match(r))))).filter((s => !r || r && -1 !== r.indexOf(s.path)));
  }
  async applyMTimeToFile(s) {
    await this.app.vault.adapter.append(s.path, "", {
      ctime: s.ctime,
      mtime: s.mtime
    });
  }
  async resolveConflictByNewerEntry(s) {
    const r = await this.path2id(s), o = await this.localDatabase.getRaw(r, {
      conflicts: true
    });
    if (!("_conflicts" in o)) return false;
    if (0 == o._conflicts.length) return false;
    Logger(`Hidden file conflicted:${this.getPath(o)}`);
    const u = o._conflicts.sort(((s, r) => Number(s.split("-")[0]) - Number(r.split("-")[0]))), g = o._rev, _ = u[0], b = await this.localDatabase.getRaw(r, {
      rev: _
    }), w = void 0, E = void 0, S = ("mtime" in o && o.mtime || 0) < ("mtime" in b && b.mtime || 0) ? g : _;
    await this.localDatabase.removeRaw(r, S);
    Logger(`Older one has been deleted:${this.getPath(o)}`);
    return true;
  }
  async readIgnoreFile(s) {
    try {
      const r = void 0, o = (await this.app.vault.adapter.read(s)).split(/\r?\n/g);
      this.ignoreFileCache.set(s, o);
      return o;
    } catch (r) {
      this.ignoreFileCache.set(s, false);
      return false;
    }
  }
  async getIgnoreFile(s) {
    if (this.ignoreFileCache.has(s)) return this.ignoreFileCache.get(s); else return await this.readIgnoreFile(s);
  }
  async isIgnoredByIgnoreFiles(s) {
    if (!this.settings.useIgnoreFiles) return false;
    const r = s instanceof import_obsidian.TFile ? s.path : s;
    if (this.ignoreFileCache.has(r)) await this.readIgnoreFile(r);
    if (!await isAcceptedAll(stripAllPrefixes(r), this.ignoreFiles, (s => this.getIgnoreFile(s)))) return true;
    return false;
  }
  async isTargetFile(s) {
    const r = s instanceof import_obsidian.TFile ? s.path : s;
    if (this.settings.useIgnoreFiles && await this.isIgnoredByIgnoreFiles(s)) return false;
    return this.localDatabase.isTargetFile(r);
  }
  async dryRunGC() {
    await runWithLock("cleanup", true, (async () => {
      const s = await this.getReplicator().connectRemoteCouchDBWithSetting(this.settings, this.isMobile);
      if ("string" == typeof s) {
        Logger(s);
        return;
      }
      await purgeUnreferencedChunks(s.db, true, this.settings, false);
      await purgeUnreferencedChunks(this.localDatabase.localDatabase, true);
      this.localDatabase.hashCaches.clear();
    }));
  }
  async dbGC() {
    await runWithLock("cleanup", true, (async () => {
      this.getReplicator().markRemoteLocked(this.settings, true, true);
      const s = await this.getReplicator().connectRemoteCouchDBWithSetting(this.settings, this.isMobile);
      if ("string" == typeof s) {
        Logger(s);
        return;
      }
      await purgeUnreferencedChunks(s.db, false, this.settings, true);
      await purgeUnreferencedChunks(this.localDatabase.localDatabase, false);
      this.localDatabase.hashCaches.clear();
      await balanceChunkPurgedDBs(this.localDatabase.localDatabase, s.db);
      this.localDatabase.refreshSettings();
      Logger("The remote database has been cleaned up! Other devices will be cleaned up on the next synchronisation.");
    }));
  }
};
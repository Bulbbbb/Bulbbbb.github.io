---
aliases: 
tags: 
---
*常用的 IO 有两种类型：*
+ *磁盘 io，从磁盘中读取数据*
+ *网络 io，从 socket（网卡缓冲区） 中读取数据*

*bio、nio、aio 这些都是网络 io 中的概念，因为磁盘 io 中没有 block 的概念。*

*网络 io 的步骤如下：*
1. *在发起 io 调用之后，进程执行系统调用进入内核态，从进程缓冲区中读取数据*
2. *操作系统等待远程客户端发送数据，并将 socket 协议栈中的数据拷贝到内核缓冲区*
3. *操作系统将内核缓冲区的数据拷贝到进程缓冲区*
4. *进程获取到数据返回用户态继续执行*

*所谓的：*
+ *BIO：进程执行完步骤 1 之后阻塞等待，并且操作系统执行步骤 3 时，也是阻塞的*
+ *NIO：进程执行步骤 1 之后是非阻塞的，也就是立即返回用户态，此时进程不断轮询步骤 2 是否完成，也就是客户端是否将数据发送完，如果步骤 2 完成则阻塞等待步骤 3 完成*
+ *AIO：进程在执行步骤 1 和执行步骤 3 的过程中，都是不会阻塞的*


*同步的意思是，事情一件一件的发生，异步的意思是，这件事情还没有干完，又来了一件事情。*

*NIO 中，线程在等待步骤 2 完成的时候，并不是只进行轮询，可以干其他事，不过是定期轮询，而且在之期间还可以进行其他 io 请求。也就是说可以使用一个线程进行多个 io 请求，这是 BIO 中无法实现的。*

*随着 NIO 中的 io 请求越来越多，这个线程变得不堪重负，轮询完所有的 IO 中步骤 2 是否完成的时间变得越来越长（轮询是一个系统调用），也就是说在 NIO 中如果 IO 请求太多，性能是不够的。*

*于是，出现了 IO 多路复用，IO 多路复用是操作系统实现的，具体来说就是上面的轮询逻辑不需要我们自己来了，操作系统为我们提供了这个轮询的 API。
操作系统来执行有什么好处呢，我们只需要执行一次系统调用，后续轮询的逻辑因为实在内核态进行的就不许要切换内核态了。*

*IO 多路复用的实现逻辑有 select、poll、epoll：*
+ *select*
![[Pasted image 20230823135953.png]]
*每次调用时将文件描述符打包传入 select 函数，操作系统进行轮询，然后返回准备好的 io 的数量。然后通过检查传入的 fd_set 来检查哪些请求就绪*
+ *poll*
*poll 与 select 的区别在于 fd_set 的不同，select 是一个数组，poll 是一个链表，没有最大数量的限制*
+ *epoll*
1. *epoll 在创建的时候会把需要监听的 fd 全部拷贝到内核中，不需要每次调用都拷贝。内存中的 socket 使用红黑树组织*
2. *epoll 是事件驱动的，当有 socket 就绪后，将会将 socket 放到链表中，不需要每次都遍历。*

*在 epoll 添加 fd 时，需要注册该 fd 的事件：*
+ *EPOLLIN：缓冲区可以读*
+ *EPOLLOUT：缓冲区可以写*

*边沿触发：*
+ *对于 EPOLLIN，socket 缓冲区从不可读到可读时触发，即数据从无到有*
+ *对于 EPOLLOUT，socket 缓冲区从不可写到可写时触发，也就是从满到不满*
*水平出发：*
+ *对于 EPOLLIN，只要有数据就会一直触发*
+ *对于 EPOLLOUT，只要可写就会一直触发*


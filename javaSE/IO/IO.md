---
aliases: 
tags: 
---

## 流

*按照我的理解，流是一种动态的过程，这个动指的是是读或者写，是 Java 对底层 read 和 write 系统调用的封装。创建一个流代表要去读或者去写。*

*而读的对象可以是一个文件（硬盘），网络，或者其他程序中。*

*Java 中的流按照传输单位有两种流,这 4 个流是所有流的基类，他们是抽象类：*
+ *字符流（Reader/Writer）*
+ *字节流（InputStream/OutputStream）*

|        | 输入流      | 输出流       |
| ------ | ----------- | ------------ |
| 字节流 | InputStream | OutputStream |
| 字符流 | Reader      | Writer       | 

*字节流每次操作的单位是一个字节（Byte），字符流每次操作的单位是一个字符（char）。*

*流的方向以内存为参照（读输入，写输出），按照流的方向可以将流分明为输入流和输出流两种：*
*从文件流向内存：input、读*
*从内存流向文件：output、写*


*从流的作用可以将流划分为结点流和处理流 (包装流)：*
+ *结点流：直接连接数据源的流*
+ *处理流：处理流的输入是一个节点流，通过装饰者设计模式对节点流增加更多功能，对节点流进行包装。*

## 流的常用操作

### read

*常用的读操作有下面 3 种，如果读取到文件末尾，下次再进行读的时候，会返回 -1，我们通过是否返回 -1 来判断是否读完。*

```tx
| 方法 || 描述|  
|字节流|字符流|^^|
|:----:|:---:|:----:|
|int read() |int read()|读取单个字节/字符，返回字节/字符的 int 值|
|int read(Byte[] cbuf)|int read(char[] cbuf)|读取 cbuf.lenght 个字符/字节的数据，并将其存储在字符/字节数组 cbuf 中，返回读取到的字符/字节数|
|int read(Byte[] cbuf,int off,int len)|int read(char[] cbuf,int off,int len)|读取 len 个字符/字节的数据并存储在 cbuf 中，从 off 位置开始存，返回读取到的字符/字节数|
```

### Write

```tx
| 方法 || 描述|  
|字节流|字符流|^^|
|:----:|:---:|:----:|
|void write(c) |void write(c)|写入单个字节/字符|
|void write(byte[] buf)|void write(char[] buf)|将字节/字符数组中的数据写入|
|void write(byte[] buf,int off,int len)|void write(char[] buf,int off,int len)|将字节/字符数组中从off位置开始，长度为len的字节/字符写入|
| |void write(String c)|将str字符串中包含的字符进行写入|
| |void write(String c,int off,int len)|将str字符串中从off位置开始，长度为len的字符写入|
```

### 指针操作

+ *markSupported()：该输入流是否支持 mark() 和 reset() 方法*
+ *mark(int readlimit)：标记当前位置，在读取 readlimit 个字节/字符后标记失效*
+ *reset()：将指针重新定位到最后一次对此输入流调用 mark() 方法时的位置*

*指针操作实现了从 mark 的地方开始，长度为 readlimit 的字符/字节的重复利用。Stream 流是只能读取一次的，所以指针操作需要借用外部工具，比如字节数据等实现。所以并不是所有的输入流都支持指针操作。*

> [!note] *只有输入流支持指针操作，并不是所有的输入流都支持指针操作。*

### flush

*向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个 `byte[]` 数组），等到缓冲区写满了，再一次性写入文件或者网络。*
*这样做可以避免频繁的 IO 操作。*

*有的时候我们向文件写的内容并不能填满缓冲区，这时候就需要手动调用 flush() 来强制刷新。*

*实际上，`InputStream` 也有缓冲区。例如，从 `FileInputStream` 读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用 `int read()` 读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致 IO 操作。当缓冲区全部读完后继续调用 `read()`，则会触发操作系统的下一次读取并再次填满缓冲区。*

*这里的缓冲区指的是操作系统级别的缓冲区，并不是语言级别的缓冲区。*

### close

*close 操作用来关闭流，在使用流的过程中通常需要很多资源，比如内存等，这些资源不能被 GC，需要手动来释放，比如关闭打开的文件。*

